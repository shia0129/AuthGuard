diff -urN ..\hss-frontend\src\/api/hss/common/accountManage/accountApi.js .\src\/api/hss/common/accountManage/accountApi.js
--- ..\hss-frontend\src\/api/hss/common/accountManage/accountApi.js	2025-02-19 14:50:03.743808500 +0900
+++ .\src\/api/hss/common/accountManage/accountApi.js	2025-03-11 11:21:08.719466400 +0900
@@ -1,96 +1,137 @@
 import baseApi from '@api/common/baseApi';
 
-const accountApi = {
-  ...baseApi,
-
-  getAccountList: async (parameters) => {
+async function getAccountListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await accountApi.axios.post('/api/account', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getAccountDetails: async (parameters) => {
-    const result = await accountApi.axios.post(`/api/account`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getAccountListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function getAccountDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await accountApi.axios.post('/api/account', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertAccountData: async (data) => {
-    try {
-      const result = await accountApi.axios.post(
-        '/api/account',
-        {
-          run_type: 'add',
-          ...data,
-        },
-        { timeout: 60000 }, // 60초
-      );
-
-      if (!result.data.errorYn) {
-        return '계정 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '계정 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getAccountDetailsInternal(parameters, retryCount - 1);
     }
-  },
-
-  updateAccountData: async (data) => {
-    try {
-      const result = await accountApi.axios.post('/api/account', {
-        run_type: 'put',
+    throw error;
+  }
+}
+
+async function insertAccountDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountApi.axios.post(
+      '/api/account',
+      {
+        run_type: 'add',
         ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '계정 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '계정 정보 수정이 실패되었습니다.';
+        signal,
+      },
+      { timeout: 60000 }
+    );
+    if (!result.data.errorYn) {
+      return '계정 정보가 등록 되었습니다.';
     }
-  },
-
-  deleteAccountData: async (parameters) => {
-    try {
-      const result = await accountApi.axios.post('/api/account', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '계정 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertAccountDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '계정 정보 삭제가 실패되었습니다.';
+      return finalErrorMessage;
+    }
+    return '계정 정보 등록이 실패되었습니다.';
+  }
+}
+
+async function updateAccountDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountApi.axios.post('/api/account', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '계정 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateAccountDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
     }
-  },
+    return '계정 정보 수정이 실패되었습니다.';
+  }
+}
+
+async function deleteAccountDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountApi.axios.post('/api/account', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '계정 정보가 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteAccountDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '계정 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const accountApi = {
+  ...baseApi,
+  getAccountList: getAccountListInternal,
+  getAccountDetails: getAccountDetailsInternal,
+  insertAccountData: insertAccountDataInternal,
+  updateAccountData: updateAccountDataInternal,
+  deleteAccountData: deleteAccountDataInternal,
 };
 
 export default accountApi;
diff -urN ..\hss-frontend\src\/api/hss/common/accountManage/accountGroupApi.js .\src\/api/hss/common/accountManage/accountGroupApi.js
--- ..\hss-frontend\src\/api/hss/common/accountManage/accountGroupApi.js	2025-02-19 14:50:03.744808400 +0900
+++ .\src\/api/hss/common/accountManage/accountGroupApi.js	2025-03-11 11:22:39.196536000 +0900
@@ -1,103 +1,161 @@
 import baseApi from '@api/common/baseApi';
 
-const accountGroupApi = {
-  ...baseApi,
-
-  getAccountGroupList: async (parameters) => {
+// 계정 그룹 목록 조회 (재시도 로직 포함)
+async function getAccountGroupListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await accountGroupApi.axios.post('/api/account-group', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getAccountGroupDetails: async (parameters) => {
-    const result = await accountGroupApi.axios.post(`/api/account-group`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getAccountGroupListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 계정 그룹 상세 조회 (재시도 로직 포함)
+async function getAccountGroupDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await accountGroupApi.axios.post('/api/account-group', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getAccountGroupColumnList: async (parameter) => {
-    const result = await accountGroupApi.axios.post(`/api/account-group`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getAccountGroupDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 계정 그룹 컬럼 목록 조회 (재시도 로직 포함)
+async function getAccountGroupColumnListInternal(parameter, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await accountGroupApi.axios.post('/api/account-group', {
       run_type: 'get',
       column: parameter,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertAccountGroupData: async (data) => {
-    try {
-      const result = await accountGroupApi.axios.post('/api/account-group', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '계정 그룹 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '계정 그룹 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getAccountGroupColumnListInternal(parameter, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 계정 그룹 등록 (재시도 로직 포함)
+async function insertAccountGroupDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountGroupApi.axios.post('/api/account-group', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '계정 그룹 정보가 등록 되었습니다.';
     }
-  },
-
-  updateAccountGroupData: async (data) => {
-    try {
-      const result = await accountGroupApi.axios.post('/api/account-group', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '계정 그룹 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '계정 그룹 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertAccountGroupDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '계정 그룹 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 계정 그룹 수정 (재시도 로직 포함)
+async function updateAccountGroupDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountGroupApi.axios.post('/api/account-group', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '계정 그룹 정보가 수정 되었습니다.';
     }
-  },
-
-  deleteAccountGroupData: async (parameters) => {
-    try {
-      const result = await accountGroupApi.axios.post('/api/account-group', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '계정 그룹 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '계정 그룹 정보 삭제가 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateAccountGroupDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '계정 그룹 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 계정 그룹 삭제 (재시도 로직 포함)
+async function deleteAccountGroupDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await accountGroupApi.axios.post('/api/account-group', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '계정 그룹 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteAccountGroupDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '계정 그룹 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const accountGroupApi = {
+  ...baseApi,
+  getAccountGroupList: getAccountGroupListInternal,
+  getAccountGroupDetails: getAccountGroupDetailsInternal,
+  getAccountGroupColumnList: getAccountGroupColumnListInternal,
+  insertAccountGroupData: insertAccountGroupDataInternal,
+  updateAccountGroupData: updateAccountGroupDataInternal,
+  deleteAccountGroupData: deleteAccountGroupDataInternal,
 };
 
 export default accountGroupApi;
diff -urN ..\hss-frontend\src\/api/hss/common/logManage/logApi.js .\src\/api/hss/common/logManage/logApi.js
--- ..\hss-frontend\src\/api/hss/common/logManage/logApi.js	2025-02-19 14:50:03.746808000 +0900
+++ .\src\/api/hss/common/logManage/logApi.js	2025-03-11 11:23:23.140627400 +0900
@@ -1,30 +1,60 @@
 import baseApi from '@api/common/baseApi';
 
-const logApi = {
-  ...baseApi,
-
-  getLogList: async (parameters) => {
+// 로그 목록 조회 (재시도 로직 포함)
+async function getLogListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await logApi.axios.post('/api/log', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getLogCount: async (parameters) => {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getLogListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 로그 개수 조회 (재시도 로직 포함)
+async function getLogCountInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await logApi.axios.post('/api/log', {
       run_type: 'get',
       count: true,
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getLogCountInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const logApi = {
+  ...baseApi,
+  getLogList: getLogListInternal,
+  getLogCount: getLogCountInternal,
 };
 
-export default logApi;
\ No newline at end of file
+export default logApi;
diff -urN ..\hss-frontend\src\/api/hss/common/networkManage/interfaceApi.js .\src\/api/hss/common/networkManage/interfaceApi.js
--- ..\hss-frontend\src\/api/hss/common/networkManage/interfaceApi.js	2025-02-19 14:50:03.746808000 +0900
+++ .\src\/api/hss/common/networkManage/interfaceApi.js	2025-03-12 15:54:18.128213500 +0900
@@ -1,114 +1,205 @@
 import baseApi from '@api/common/baseApi';
 
-const interfaceApi = {
-  ...baseApi,
-
-  getInterfaceList: async (parameters) => {
+// 인터페이스 목록 조회 (재시도 로직 포함)
+async function getInterfaceListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await interfaceApi.axios.post('/api/interface', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getInterfaceDetails: async (parameters) => {
-    const result = await interfaceApi.axios.post(`/api/interface`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getInterfaceListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 인터페이스 상세 조회 (재시도 로직 포함)
+async function getInterfaceDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await interfaceApi.axios.post('/api/interface', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getInterfaceColumnList: async (parameter) => {
-    const result = await interfaceApi.axios.post(`/api/interface`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getInterfaceDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 인터페이스 컬럼 목록 조회 (재시도 로직 포함)
+async function getInterfaceColumnListInternal(parameter, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await interfaceApi.axios.post('/api/interface', {
       run_type: 'get',
       column: parameter,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getInterfaceMemberList: async (parameter) => {
-    const result = await interfaceApi.axios.post(`/api/interface`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getInterfaceColumnListInternal(parameter, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 인터페이스 멤버 목록 조회 (재시도 로직 포함)
+async function getInterfaceMemberListInternal(parameter, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await interfaceApi.axios.post('/api/interface', {
       run_type: 'get',
       member: parameter,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertInterfaceData: async (data) => {
-    try {
-      const result = await interfaceApi.axios.post('/api/interface', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '인터페이스 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '인터페이스 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getInterfaceMemberListInternal(parameter, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 인터페이스 등록 (재시도 로직 포함)
+async function insertInterfaceDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await interfaceApi.axios.post('/api/interface', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '인터페이스 정보가 등록 되었습니다.';
     }
-  },
-
-  updateInterfaceData: async (data) => {
-    try {
-      const result = await interfaceApi.axios.post('/api/interface', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '인터페이스 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '인터페이스 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertInterfaceDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '인터페이스 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 인터페이스 수정 (재시도 로직 포함)
+async function updateInterfaceDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await interfaceApi.axios.post('/api/interface', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '인터페이스 정보가 수정 되었습니다.';
     }
-  },
-
-  deleteInterfaceData: async (parameters) => {
-    try {
-      const result = await interfaceApi.axios.post('/api/interface', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '인터페이스 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '인터페이스 정보 삭제가 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateInterfaceDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '인터페이스 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 인터페이스 삭제 (재시도 로직 포함)
+async function deleteInterfaceDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await interfaceApi.axios.post('/api/interface', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '인터페이스 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteInterfaceDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '인터페이스 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const interfaceApi = {
+  ...baseApi,
+  getInterfaceList: getInterfaceListInternal,
+  getInterfaceDetails: getInterfaceDetailsInternal,
+  getInterfaceColumnList: getInterfaceColumnListInternal,
+  getInterfaceMemberList: getInterfaceMemberListInternal,
+  insertInterfaceData: insertInterfaceDataInternal,
+  updateInterfaceData: updateInterfaceDataInternal,
+  deleteInterfaceData: deleteInterfaceDataInternal,
 };
 
 export default interfaceApi;
diff -urN ..\hss-frontend\src\/api/hss/common/systemManage/dashboardApi.js .\src\/api/hss/common/systemManage/dashboardApi.js
--- ..\hss-frontend\src\/api/hss/common/systemManage/dashboardApi.js	2025-02-19 14:50:03.747808100 +0900
+++ .\src\/api/hss/common/systemManage/dashboardApi.js	2025-03-12 15:54:48.665927300 +0900
@@ -1,16 +1,31 @@
 import baseApi from '@api/common/baseApi';
 
-const dashboardApi = {
-  ...baseApi,
-
-  getServiceStatus: ({ hasToken = true }) => {
-    return dashboardApi.axios.get('/api/system/service/status', {
+async function getServiceStatusInternal({ hasToken = true }, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await dashboardApi.axios.get('/api/system/service/status', {
       headers: {
         Authorization: '',
       },
       ...(!hasToken && { headers: { Authorization: '' } }),
+      signal,
     });
-  },
+    return result;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getServiceStatusInternal({ hasToken }, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const dashboardApi = {
+  ...baseApi,
+
+  getServiceStatus: ({ hasToken = true }) =>
+    getServiceStatusInternal({ hasToken }),
 };
 
 export default dashboardApi;
diff -urN ..\hss-frontend\src\/api/hss/common/systemManage/defaultFactoryApi.js .\src\/api/hss/common/systemManage/defaultFactoryApi.js
--- ..\hss-frontend\src\/api/hss/common/systemManage/defaultFactoryApi.js	2025-03-12 13:30:03.132238500 +0900
+++ .\src\/api/hss/common/systemManage/defaultFactoryApi.js	2025-03-14 18:07:35.799739000 +0900
@@ -1,15 +1,28 @@
 import baseApi from '@api/common/baseApi';
 
-const defaultFactoryApi = {
-  ...baseApi,
-
-  defaultFactory: async () => {
+// 장비 초기화 API (재시도 로직 포함)
+async function defaultFactoryInternal(retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await defaultFactoryApi.axios.post('/api/system/default-factory', {
       action: 'start',
+      signal,
     });
-
     return result;
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 요청이 취소된 경우 1초 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return defaultFactoryInternal(retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const defaultFactoryApi = {
+  ...baseApi,
+  defaultFactory: defaultFactoryInternal,
 };
 
 export default defaultFactoryApi;
diff -urN ..\hss-frontend\src\/api/hss/common/systemManage/licenseApi.js .\src\/api/hss/common/systemManage/licenseApi.js
--- ..\hss-frontend\src\/api/hss/common/systemManage/licenseApi.js	2025-02-19 14:50:03.748808000 +0900
+++ .\src\/api/hss/common/systemManage/licenseApi.js	2025-03-11 11:26:08.772361800 +0900
@@ -1,18 +1,31 @@
 import baseApi from '@api/common/baseApi';
 
-const licenseApi = {
-  ...baseApi,
+async function insertLicenseDataInternal(fileList, retryCount = 3) {
+  const formData = new FormData();
+  fileList.forEach((file) => formData.append('file', file));
+  formData.append('run_type', 'add');
 
-  insertLicenseData: async (fileList) => {
-    const formData = new FormData();
-    fileList.forEach((file) => formData.append('file', file));
-    formData.append('run_type', 'add');
+  const controller = new AbortController();
+  const signal = controller.signal;
 
-    const result = await licenseApi.axios.post('/api/system/license', formData);
+  try {
+    const result = await licenseApi.axios.post('/api/system/license', formData, { signal });
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertLicenseDataInternal(fileList, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const licenseApi = {
+  ...baseApi,
+  insertLicenseData: insertLicenseDataInternal,
 };
 
 export default licenseApi;
diff -urN ..\hss-frontend\src\/api/hss/common/systemManage/powerApi.js .\src\/api/hss/common/systemManage/powerApi.js
--- ..\hss-frontend\src\/api/hss/common/systemManage/powerApi.js	2025-02-19 14:50:03.749809000 +0900
+++ .\src\/api/hss/common/systemManage/powerApi.js	2025-03-11 11:26:38.467965500 +0900
@@ -1,23 +1,47 @@
 import baseApi from '@api/common/baseApi';
 
-const powerApi = {
-  ...baseApi,
-
-  shutdown: async () => {
+// shutdown 재시도 로직 포함 함수
+async function shutdownInternal(retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await powerApi.axios.post('/api/system/power', {
       action: 'shutdown',
+      signal,
     });
-
     return result;
-  },
-
-  reboot: async () => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return shutdownInternal(retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// reboot 재시도 로직 포함 함수
+async function rebootInternal(retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await powerApi.axios.post('/api/system/power', {
       action: 'reboot',
+      signal,
     });
-
     return result;
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return rebootInternal(retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const powerApi = {
+  ...baseApi,
+  shutdown: shutdownInternal,
+  reboot: rebootInternal,
 };
 
 export default powerApi;
diff -urN ..\hss-frontend\src\/api/hss/common/systemManage/versionApi.js .\src\/api/hss/common/systemManage/versionApi.js
--- ..\hss-frontend\src\/api/hss/common/systemManage/versionApi.js	2025-02-19 14:50:03.750808700 +0900
+++ .\src\/api/hss/common/systemManage/versionApi.js	2025-03-11 11:27:07.577205800 +0900
@@ -1,17 +1,29 @@
 import baseApi from '@api/common/baseApi';
 
-const versionApi = {
-  ...baseApi,
-
-  getVersionDetail: async () => {
-    const result = await versionApi.axios.post(`/api/system/version`, {
+async function getVersionDetailInternal(retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await versionApi.axios.post('/api/system/version', {
       run_type: 'get',
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getVersionDetailInternal(retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+const versionApi = {
+  ...baseApi,
+  getVersionDetail: getVersionDetailInternal,
 };
 
 export default versionApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDefaultManage/blackListGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyDefaultManage/blackListGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDefaultManage/blackListGroupStatusApi.js	2025-03-12 13:30:03.132833400 +0900
+++ .\src\/api/hss/sslswg/policy/policyDefaultManage/blackListGroupStatusApi.js	2025-03-11 11:04:41.707783500 +0900
@@ -1,140 +1,200 @@
 import baseApi from '@api/common/baseApi';
 
-const blackListGroupStatusApi = {
-  ...baseApi,
-
-  getBlackListGroupStatusList: async (parameters) => {
+// 블랙리스트 그룹 상태 목록 조회 함수 (재시도 로직 포함)
+async function getBlackListGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await blackListGroupStatusApi.axios.post(
       '/api/sslswg/policy-manage/black-list-group',
       {
         run_type: 'get',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getBlackListGroupStatusDetails: async (parameters) => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 대기 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getBlackListGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 그룹 상태 상세 조회 함수 (재시도 로직 포함)
+async function getBlackListGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await blackListGroupStatusApi.axios.post(
-      `/api/sslswg/policy-manage/black-list-group`,
+      '/api/sslswg/policy-manage/black-list-group',
       {
         run_type: 'get',
         id: parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertBlackListGroupStatusData: async (data) => {
-    try {
-      const result = await blackListGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/black-list-group',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '블랙리스트 그룹 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '블랙리스트 그룹 정보 등록이 실패되었습니다.';
-    }
-  },
-
-  updateBlackListGroupStatusData: async (data) => {
-    try {
-      const result = await blackListGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/black-list-group',
-        {
-          run_type: 'put',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '블랙리스트 그룹 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '블랙리스트 그룹 정보 수정이 실패되었습니다.';
-    }
-  },
-
-  updateEnabledBlackListGroupStatusData: async ({ data, enabled }) => {
-    try {
-      const result = await blackListGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/black-list-group',
-        {
-          run_type: 'put',
-          data,
-          enabled,
-        },
-      );
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return enabled
-          ? '블랙리스트 그룹 정보가 활성화되었습니다.'
-          : '블랙리스트 그룹 정보가 비활성화되었습니다.';
-      }
-      return '블랙리스트 그룹 활성화 여부 변경이 실패되었습니다.';
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '블랙리스트 그룹 활성화 여부 변경이 실패되었습니다.';
-    }
-  },
-
-  deleteBlackListGroupStatusData: async (parameters) => {
-    try {
-      const result = await blackListGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/black-list-group',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '블랙리스트 그룹 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getBlackListGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 그룹 상태 등록 함수 (재시도 로직 포함)
+async function insertBlackListGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list-group',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return '블랙리스트 그룹 정보가 등록 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertBlackListGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '블랙리스트 그룹 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 블랙리스트 그룹 상태 수정 함수 (재시도 로직 포함)
+async function updateBlackListGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list-group',
+      {
+        run_type: 'put',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return '블랙리스트 그룹 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateBlackListGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '블랙리스트 그룹 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 블랙리스트 그룹 활성화/비활성화 변경 함수 (재시도 로직 포함)
+async function updateEnabledBlackListGroupStatusDataInternal({ data, enabled }, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list-group',
+      {
+        run_type: 'put',
+        data,
+        enabled,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return enabled
+        ? '블랙리스트 그룹 정보가 활성화되었습니다.'
+        : '블랙리스트 그룹 정보가 비활성화되었습니다.';
+    }
+    return '블랙리스트 그룹 활성화 여부 변경이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateEnabledBlackListGroupStatusDataInternal({ data, enabled }, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '블랙리스트 그룹 활성화 여부 변경이 실패되었습니다.';
+  }
+}
+
+// 블랙리스트 그룹 삭제 함수 (재시도 로직 포함)
+async function deleteBlackListGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list-group',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
       }
-      return '블랙리스트 그룹 정보 삭제가 실패되었습니다.';
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '블랙리스트 그룹 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteBlackListGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '블랙리스트 그룹 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const blackListGroupStatusApi = {
+  ...baseApi,
+
+  getBlackListGroupStatusList: getBlackListGroupStatusListInternal,
+
+  getBlackListGroupStatusDetails: getBlackListGroupStatusDetailsInternal,
+
+  insertBlackListGroupStatusData: insertBlackListGroupStatusDataInternal,
+
+  updateBlackListGroupStatusData: updateBlackListGroupStatusDataInternal,
+
+  updateEnabledBlackListGroupStatusData: updateEnabledBlackListGroupStatusDataInternal,
+
+  deleteBlackListGroupStatusData: deleteBlackListGroupStatusDataInternal,
 };
 
 export default blackListGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDefaultManage/blackListStatusApi.js .\src\/api/hss/sslswg/policy/policyDefaultManage/blackListStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDefaultManage/blackListStatusApi.js	2025-03-12 13:30:03.133355600 +0900
+++ .\src\/api/hss/sslswg/policy/policyDefaultManage/blackListStatusApi.js	2025-03-11 11:06:33.026662000 +0900
@@ -1,159 +1,125 @@
 import baseApi from '@api/common/baseApi';
 
-const blackListStatusApi = {
-  ...baseApi,
-
-  getBlackListStatusList: async (parameters) => {
-    const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
-      run_type: 'get',
-      ...parameters,
-    });
-
+// 블랙리스트 상태 목록 조회 (재시도 로직 포함)
+async function getBlackListStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getReasonListAllWithBlackListId: async (parameters) => {
-    const result = await blackListStatusApi.axios.post(`/api/sslswg/policy-manage/black-list`, {
-      run_type: 'get',
-      mode: 'reason',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 대기 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getBlackListStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 상세 조회 (사유 목록 포함) (재시도 로직 포함)
+async function getReasonListAllWithBlackListIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list',
+      {
+        run_type: 'get',
+        mode: 'reason',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  updateReasonListWithBlackListId: async (parameters) => {
-    const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
-      run_type: 'put',
-      mode: 'reason',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getReasonListAllWithBlackListIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 사유 수정 (재시도 로직 포함)
+async function updateReasonListWithBlackListIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list',
+      {
+        run_type: 'put',
+        mode: 'reason',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  // getBlackListStatusDetails: async (parameters) => {
-  //   const result = await blackListStatusApi.axios.post(`/api/sslswg/policy-manage/black-list`, {
-  //     run_type: 'get',
-  //     id: parameters,
-  //   });
-
-  //   if (!result.data.errorYn) {
-  //     return result.data.data;
-  //   }
-  // },
-
-  // insertBlackListStatusData: async (data) => {
-  //   try {
-  //     const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
-  //       run_type: 'add',
-  //       ...data,
-  //     });
-
-  //     if (!result.data.errorYn) {
-  //       return '블랙리스트 정보가 등록 되었습니다.';
-  //     }
-  //   } catch (error) {
-  //     if (error.response && error.response.data.errorYn) {
-  //       const errorMessage = error.response.data.error.errorMessage;
-  //       let finalErrorMessage = '';
-  //       if (typeof errorMessage === 'object') {
-  //         finalErrorMessage = Object.values(errorMessage)
-  //           .flat() // 배열의 배열을 평탄화
-  //           .shift(); // 배열의 첫 번째 요소
-  //       } else {
-  //         finalErrorMessage = errorMessage;
-  //       }
-  //       return finalErrorMessage;
-  //     }
-  //     return '블랙리스트 정보 등록이 실패되었습니다.';
-  //   }
-  // },
-
-  // updateBlackListStatusData: async (data) => {
-  //   try {
-  //     const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
-  //       run_type: 'put',
-  //       ...data,
-  //     });
-
-  //     if (!result.data.errorYn) {
-  //       return '블랙리스트 정보가 수정 되었습니다.';
-  //     }
-  //   } catch (error) {
-  //     if (error.response && error.response.data.errorYn) {
-  //       const errorMessage = error.response.data.error.errorMessage;
-  //       let finalErrorMessage = '';
-  //       if (typeof errorMessage === 'object') {
-  //         finalErrorMessage = Object.values(errorMessage)
-  //           .flat() // 배열의 배열을 평탄화
-  //           .shift(); // 배열의 첫 번째 요소
-  //       } else {
-  //         finalErrorMessage = errorMessage;
-  //       }
-  //       return finalErrorMessage;
-  //     }
-  //     return '블랙리스트 정보 수정이 실패되었습니다.';
-  //   }
-  // },
-
-  updateEnabledBlackListStatusData: async ({ data, enabled }) => {
-    try {
-      const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateReasonListWithBlackListIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 활성화/비활성화 변경 (재시도 로직 포함)
+async function updateEnabledBlackListStatusDataInternal({ data, enabled }, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await blackListStatusApi.axios.post(
+      '/api/sslswg/policy-manage/black-list',
+      {
         run_type: 'put',
         data,
         enabled,
-      });
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return enabled
-          ? '블랙리스트 정보가 활성화되었습니다.'
-          : '블랙리스트 정보가 비활성화되었습니다.';
+        signal,
       }
-      return '블랙리스트 활성화 여부 변경이 실패되었습니다.';
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '블랙리스트 활성화 여부 변경이 실패되었습니다.';
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return enabled
+        ? '블랙리스트 정보가 활성화되었습니다.'
+        : '블랙리스트 정보가 비활성화되었습니다.';
+    }
+    return '블랙리스트 활성화 여부 변경이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateEnabledBlackListStatusDataInternal({ data, enabled }, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
     }
-  },
+    return '블랙리스트 활성화 여부 변경이 실패되었습니다.';
+  }
+}
+
+const blackListStatusApi = {
+  ...baseApi,
+
+  getBlackListStatusList: getBlackListStatusListInternal,
+
+  getReasonListAllWithBlackListId: getReasonListAllWithBlackListIdInternal,
+
+  updateReasonListWithBlackListId: updateReasonListWithBlackListIdInternal,
 
-  // deleteBlackListStatusData: async (parameters) => {
-  //   try {
-  //     const result = await blackListStatusApi.axios.post('/api/sslswg/policy-manage/black-list', {
-  //       run_type: 'del',
-  //       data: parameters,
-  //     });
-
-  //     if (!result.data.errorYn && result.data.data.count > 0) {
-  //       return '블랙리스트 정보가 삭제 되었습니다.';
-  //     }
-  //   } catch (error) {
-  //     if (error.response && error.response.data.errorYn) {
-  //       return error.response.data.error.errorMessage;
-  //     }
-  //     return '블랙리스트 정보 삭제가 실패되었습니다.';
-  //   }
-  // },
-
-  // getBlackListStatusExcelList: (parameters) => {
-  //   console.log(parameters);
-  //   return blackListStatusApi.axios.post(
-  //     '/api/sslswg/policy-manage/black-list',
-  //     {
-  //       run_type: 'get',
-  //       excel: true,
-  //       ...parameters,
-  //     },
-  //     { responseType: 'blob' },
-  //   );
-  // },
+  updateEnabledBlackListStatusData: updateEnabledBlackListStatusDataInternal,
 };
 
 export default blackListStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/patternGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/patternGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/patternGroupStatusApi.js	2025-03-12 13:30:03.133873700 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/patternGroupStatusApi.js	2025-03-11 11:08:42.957828200 +0900
@@ -1,116 +1,185 @@
 import baseApi from '@api/common/baseApi';
 
-const patternGroupStatusApi = {
-  ...baseApi,
-
-  getPatternGroupStatusList: async (parameters) => {
+// 블랙리스트 그룹 상태 목록 조회 (재시도 로직 포함)
+async function getPatternGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await patternGroupStatusApi.axios.post(
       '/api/sslswg/policy-manage/pattern-group',
       {
         run_type: 'get',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getPatternGroupStatusDetails: async (parameters) => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPatternGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 블랙리스트 그룹 상태 상세 조회 (재시도 로직 포함)
+async function getPatternGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await patternGroupStatusApi.axios.post(
       '/api/sslswg/policy-manage/pattern-group',
       {
         run_type: 'get',
         id: parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getMappingListAllWithPatternGroupId: async (parameters) => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPatternGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 패턴 그룹 매핑 목록 조회 (재시도 로직 포함)
+async function getMappingListAllWithPatternGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await patternGroupStatusApi.axios.post(
       '/api/sslswg/policy-manage/pattern-group',
       {
         run_type: 'get',
         mode: 'mapping',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertPatternGroupStatusData: async (data) => {
-    try {
-      const result = await patternGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/pattern-group',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '패턴 그룹 정책이 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getMappingListAllWithPatternGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 패턴 그룹 상태 등록 (재시도 로직 포함)
+async function insertPatternGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await patternGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/pattern-group',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
       }
-      return '패턴 그룹 정책 등록이 실패되었습니다.';
+    );
+    if (!result.data.errorYn) {
+      return '패턴 그룹 정책이 등록 되었습니다.';
     }
-  },
-
-  updateMappingListWithPatternGroupId: async (parameters) => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertPatternGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '패턴 그룹 정책 등록이 실패되었습니다.';
+  }
+}
+
+// 패턴 그룹 매핑 수정 (재시도 로직 포함)
+async function updateMappingListWithPatternGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await patternGroupStatusApi.axios.post(
       '/api/sslswg/policy-manage/pattern-group',
       {
         run_type: 'put',
         mode: 'mapping',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  deletePatternGroupStatusData: async (parameters) => {
-    try {
-      const result = await patternGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/pattern-group',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '패턴 그룹 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateMappingListWithPatternGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 패턴 그룹 상태 삭제 (재시도 로직 포함)
+async function deletePatternGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await patternGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/pattern-group',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
       }
-      return '패턴 그룹 정책 삭제가 실패되었습니다.';
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '패턴 그룹 정책이 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deletePatternGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '패턴 그룹 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const patternGroupStatusApi = {
+  ...baseApi,
+
+  getPatternGroupStatusList: getPatternGroupStatusListInternal,
+
+  getPatternGroupStatusDetails: getPatternGroupStatusDetailsInternal,
+
+  getMappingListAllWithPatternGroupId: getMappingListAllWithPatternGroupIdInternal,
+
+  insertPatternGroupStatusData: insertPatternGroupStatusDataInternal,
+
+  updateMappingListWithPatternGroupId: updateMappingListWithPatternGroupIdInternal,
+
+  deletePatternGroupStatusData: deletePatternGroupStatusDataInternal,
 };
 
 export default patternGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/siteGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/siteGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/siteGroupStatusApi.js	2025-03-12 13:30:03.134395100 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/siteGroupStatusApi.js	2025-03-11 11:10:24.764194100 +0900
@@ -1,98 +1,184 @@
 import baseApi from '@api/common/baseApi';
 
-const siteGroupStatusApi = {
-  ...baseApi,
-
-  getSiteGroupStatusList: async (parameters) => {
-    const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
-      run_type: 'get',
-      ...parameters,
-    });
-
+// 사이트 그룹 상태 목록 조회 (재시도 로직 포함)
+async function getSiteGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSiteGroupStatusDetails: async (parameters) => {
-    const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
-      run_type: 'get',
-      id: parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSiteGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 사이트 그룹 상태 상세 조회 (재시도 로직 포함)
+async function getSiteGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
+        run_type: 'get',
+        id: parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getMappingListAllWithSiteGroupId: async (parameters) => {
-    const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
-      run_type: 'get',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSiteGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 사이트 그룹 매핑 목록 조회 (재시도 로직 포함)
+async function getMappingListAllWithSiteGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
+        run_type: 'get',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertSiteGroupStatusData: async (data) => {
-    try {
-      const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getMappingListAllWithSiteGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 사이트 그룹 상태 등록 (재시도 로직 포함)
+async function insertSiteGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
         run_type: 'add',
         ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '사이트 그룹 정책이 등록 되었습니다.';
+        signal,
       }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '사이트 그룹 정책 등록이 실패되었습니다.';
-    }
-  },
-
-  updateMappingListWithSiteGroupId: async (parameters) => {
-    const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
-      run_type: 'put',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+    );
+    if (!result.data.errorYn) {
+      return '사이트 그룹 정책이 등록 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertSiteGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '사이트 그룹 정책 등록이 실패되었습니다.';
+  }
+}
+
+// 사이트 그룹 매핑 수정 (재시도 로직 포함)
+async function updateMappingListWithSiteGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
+        run_type: 'put',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  deleteSiteGroupStatusData: async (parameters) => {
-    try {
-      const result = await siteGroupStatusApi.axios.post('/api/sslswg/policy-manage/site-group', {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateMappingListWithSiteGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 사이트 그룹 상태 삭제 (재시도 로직 포함)
+async function deleteSiteGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/site-group',
+      {
         run_type: 'del',
         data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '사이트 그룹 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+        signal,
       }
-      return '사이트 그룹 정책 삭제가 실패되었습니다.';
-    }
-  },
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '사이트 그룹 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteSiteGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '사이트 그룹 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const siteGroupStatusApi = {
+  ...baseApi,
+
+  getSiteGroupStatusList: getSiteGroupStatusListInternal,
+
+  getSiteGroupStatusDetails: getSiteGroupStatusDetailsInternal,
+
+  getMappingListAllWithSiteGroupId: getMappingListAllWithSiteGroupIdInternal,
+
+  insertSiteGroupStatusData: insertSiteGroupStatusDataInternal,
+
+  updateMappingListWithSiteGroupId: updateMappingListWithSiteGroupIdInternal,
+
+  deleteSiteGroupStatusData: deleteSiteGroupStatusDataInternal,
 };
 
 export default siteGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/siteStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/siteStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/siteStatusApi.js	2025-03-12 13:30:03.134913900 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/siteStatusApi.js	2025-03-11 10:59:41.241181800 +0900
@@ -1,101 +1,152 @@
 import baseApi from '@api/common/baseApi';
 
-const siteStatusApi = {
-  ...baseApi,
-
-  getSiteStatusList: async (parameters) => {
+async function getSiteStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
 
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSiteStatusDetails: async (parameters) => {
-    const result = await siteStatusApi.axios.post(`/api/sslswg/policy-manage/site`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSiteStatusListInternal(parameters, retryCount - 1);
+    }
+    // 필요에 따라 여기서 에러 메시지 처리를 추가할 수 있습니다.
+    throw error;
+  }
+}
+
+async function getSiteStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
 
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertSiteStatusData: async (data) => {
-    try {
-      const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
-        run_type: 'add',
-        ...data,
-      });
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSiteStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function insertSiteStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    console.log(data);
+    const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
 
-      if (!result.data.errorYn) {
-        return '사이트 정책이 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
+    if (!result.data.errorYn) {
+      return '사이트 정책이 등록 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertSiteStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '사이트 정책 등록이 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
-
-  updateSiteStatusData: async (data) => {
-    try {
-      const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
-        run_type: 'put',
-        ...data,
-      });
+    return '사이트 정책 등록이 실패되었습니다.';
+  }
+}
+
+async function updateSiteStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
 
-      if (!result.data.errorYn) {
-        return '사이트 정책이 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
+    if (!result.data.errorYn) {
+      return '사이트 정책이 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateSiteStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '사이트 정책 수정이 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
-
-  deleteSiteStatusData: async (parameters) => {
-    try {
-      const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
-        run_type: 'del',
-        data: parameters,
-      });
+    return '사이트 정책 수정이 실패되었습니다.';
+  }
+}
+
+async function deleteSiteStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await siteStatusApi.axios.post('/api/sslswg/policy-manage/site', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
 
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '사이트 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '사이트 정책 삭제가 실패되었습니다.';
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '사이트 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteSiteStatusDataInternal(parameters, retryCount - 1);
     }
-  },
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '사이트 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const siteStatusApi = {
+  ...baseApi,
+
+  getSiteStatusList: getSiteStatusListInternal,
+
+  getSiteStatusDetails: getSiteStatusDetailsInternal,
+
+  insertSiteStatusData: insertSiteStatusDataInternal,
+
+  updateSiteStatusData: updateSiteStatusDataInternal,
+
+  deleteSiteStatusData: deleteSiteStatusDataInternal,
 };
 
 export default siteStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/srcIpGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/srcIpGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/srcIpGroupStatusApi.js	2025-03-12 13:30:03.135953800 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/srcIpGroupStatusApi.js	2025-03-11 11:11:54.955949600 +0900
@@ -1,104 +1,198 @@
 import baseApi from '@api/common/baseApi';
 
-const srcIpGroupStatusApi = {
-  ...baseApi,
-
-  getSrcIpGroupStatusList: async (parameters) => {
-    const result = await srcIpGroupStatusApi.axios.post('/api/sslswg/policy-manage/src-ip-group', {
-      run_type: 'get',
-      ...parameters,
-    });
+// srcIpGroupStatusApi 내부 함수들을 재시도 로직을 포함하여 정의합니다.
 
+async function getSrcIpGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSrcIpGroupStatusDetails: async (parameters) => {
-    const result = await srcIpGroupStatusApi.axios.post('/api/sslswg/policy-manage/src-ip-group', {
-      run_type: 'get',
-      id: parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSrcIpGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function getSrcIpGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'get',
+        id: parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getMappingListAllWithSrcIpGroupId: async (parameters) => {
-    const result = await srcIpGroupStatusApi.axios.post('/api/sslswg/policy-manage/src-ip-group', {
-      run_type: 'get',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSrcIpGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function getMappingListAllWithSrcIpGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'get',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertSrcIpGroupStatusData: async (data) => {
-    try {
-      const result = await srcIpGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/src-ip-group',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '출발지IP 그룹 정책이 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '출발지IP 그룹 정책 등록이 실패되었습니다.';
-    }
-  },
-
-  updateMappingListWithSrcIpGroupId: async (parameters) => {
-    const result = await srcIpGroupStatusApi.axios.post('/api/sslswg/policy-manage/src-ip-group', {
-      run_type: 'put',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getMappingListAllWithSrcIpGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function insertSrcIpGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
-      return result.data.data;
+      return '출발지IP 그룹 정책이 등록 되었습니다.';
     }
-  },
-
-  deleteSrcIpGroupStatusData: async (parameters) => {
-    try {
-      const result = await srcIpGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/src-ip-group',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '출발지IP 그룹 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertSrcIpGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '출발지IP 그룹 정책 삭제가 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
+    return '출발지IP 그룹 정책 등록이 실패되었습니다.';
+  }
+}
+
+async function updateMappingListWithSrcIpGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'put',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return result.data.data;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateMappingListWithSrcIpGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function deleteSrcIpGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/src-ip-group',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '출발지IP 그룹 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteSrcIpGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '출발지IP 그룹 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const srcIpGroupStatusApi = {
+  ...baseApi,
+
+  getSrcIpGroupStatusList: getSrcIpGroupStatusListInternal,
+
+  getSrcIpGroupStatusDetails: getSrcIpGroupStatusDetailsInternal,
+
+  getMappingListAllWithSrcIpGroupId: getMappingListAllWithSrcIpGroupIdInternal,
+
+  insertSrcIpGroupStatusData: insertSrcIpGroupStatusDataInternal,
+
+  updateMappingListWithSrcIpGroupId: updateMappingListWithSrcIpGroupIdInternal,
+
+  deleteSrcIpGroupStatusData: deleteSrcIpGroupStatusDataInternal,
 };
 
 export default srcIpGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/srcIpStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/srcIpStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/srcIpStatusApi.js	2025-03-12 13:30:03.136472300 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/srcIpStatusApi.js	2025-03-11 11:14:21.044414500 +0900
@@ -1,101 +1,151 @@
 import baseApi from '@api/common/baseApi';
 
-const srcIpStatusApi = {
-  ...baseApi,
-
-  getSrcIpStatusList: async (parameters) => {
+// srcIpStatus 목록 조회 (재시도 로직 포함)
+async function getSrcIpStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSrcIpStatusDetails: async (parameters) => {
-    const result = await srcIpStatusApi.axios.post(`/api/sslswg/policy-manage/src-ip`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      // 1초 대기 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSrcIpStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// srcIpStatus 상세 조회 (재시도 로직 포함)
+async function getSrcIpStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertSrcIpStatusData: async (data) => {
-    try {
-      const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '출발지IP 정책이 등록 되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSrcIpStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// srcIpStatus 등록 (재시도 로직 포함)
+async function insertSrcIpStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '출발지IP 정책이 등록 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertSrcIpStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
+      return finalErrorMessage;
+    }
+    return '출발지IP 정책 등록이 실패되었습니다.';
+  }
+}
+
+// srcIpStatus 수정 (재시도 로직 포함)
+async function updateSrcIpStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '출발지IP 정책이 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateSrcIpStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '출발지IP 정책 등록이 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
+    return '출발지IP 정책 수정이 실패되었습니다.';
+  }
+}
+
+// srcIpStatus 삭제 (재시도 로직 포함)
+async function deleteSrcIpStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '출발지IP 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteSrcIpStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '출발지IP 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const srcIpStatusApi = {
+  ...baseApi,
 
-  updateSrcIpStatusData: async (data) => {
-    try {
-      const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
-        run_type: 'put',
-        ...data,
-      });
+  getSrcIpStatusList: getSrcIpStatusListInternal,
 
-      if (!result.data.errorYn) {
-        return '출발지IP 정책이 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '출발지IP 정책 수정이 실패되었습니다.';
-    }
-  },
+  getSrcIpStatusDetails: getSrcIpStatusDetailsInternal,
 
-  deleteSrcIpStatusData: async (parameters) => {
-    try {
-      const result = await srcIpStatusApi.axios.post('/api/sslswg/policy-manage/src-ip', {
-        run_type: 'del',
-        data: parameters,
-      });
+  insertSrcIpStatusData: insertSrcIpStatusDataInternal,
 
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '출발지IP 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '출발지IP 정책 삭제가 실패되었습니다.';
-    }
-  },
+  updateSrcIpStatusData: updateSrcIpStatusDataInternal,
+
+  deleteSrcIpStatusData: deleteSrcIpStatusDataInternal,
 };
 
 export default srcIpStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi.js	2025-03-12 13:30:03.137499700 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi.js	2025-03-11 11:15:45.893701000 +0900
@@ -1,98 +1,197 @@
 import baseApi from '@api/common/baseApi';
 
-const timeGroupStatusApi = {
-  ...baseApi,
-
-  getTimeGroupStatusList: async (parameters) => {
-    const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
-      run_type: 'get',
-      ...parameters,
-    });
-
+// 스케줄 그룹 상태 목록 조회 (재시도 로직 포함)
+async function getTimeGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getTimeGroupStatusDetails: async (parameters) => {
-    const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
-      run_type: 'get',
-      id: parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      // 1초 후 재시도
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getTimeGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 스케줄 그룹 상태 상세 조회 (재시도 로직 포함)
+async function getTimeGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
+        run_type: 'get',
+        id: parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getMappingListAllWithTimeGroupId: async (parameters) => {
-    const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
-      run_type: 'get',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getTimeGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 스케줄 그룹 매핑 목록 조회 (재시도 로직 포함)
+async function getMappingListAllWithTimeGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
+        run_type: 'get',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertTimeGroupStatusData: async (data) => {
-    try {
-      const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getMappingListAllWithTimeGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 스케줄 그룹 상태 등록 (재시도 로직 포함)
+async function insertTimeGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
         run_type: 'add',
         ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '스케줄 그룹 정책이 등록 되었습니다.';
+        signal,
       }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '스케줄 그룹 정책 등록이 실패되었습니다.';
-    }
-  },
-
-  updateMappingListWithTimeGroupId: async (parameters) => {
-    const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
-      run_type: 'put',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+    );
+    if (!result.data.errorYn) {
+      return '스케줄 그룹 정책이 등록 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertTimeGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '스케줄 그룹 정책 등록이 실패되었습니다.';
+  }
+}
+
+// 스케줄 그룹 매핑 수정 (재시도 로직 포함)
+async function updateMappingListWithTimeGroupIdInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
+        run_type: 'put',
+        mode: 'mapping',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  deleteTimeGroupStatusData: async (parameters) => {
-    try {
-      const result = await timeGroupStatusApi.axios.post('/api/sslswg/policy-manage/time-group', {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateMappingListWithTimeGroupIdInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 스케줄 그룹 상태 삭제 (재시도 로직 포함)
+async function deleteTimeGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/time-group',
+      {
         run_type: 'del',
         data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '스케줄 그룹 정책이 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+        signal,
       }
-      return '스케줄 그룹 정책 삭제가 실패되었습니다.';
-    }
-  },
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '스케줄 그룹 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteTimeGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '스케줄 그룹 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const timeGroupStatusApi = {
+  ...baseApi,
+  getTimeGroupStatusList: getTimeGroupStatusListInternal,
+  getTimeGroupStatusDetails: getTimeGroupStatusDetailsInternal,
+  getMappingListAllWithTimeGroupId: getMappingListAllWithTimeGroupIdInternal,
+  insertTimeGroupStatusData: insertTimeGroupStatusDataInternal,
+  updateMappingListWithTimeGroupId: updateMappingListWithTimeGroupIdInternal,
+  deleteTimeGroupStatusData: deleteTimeGroupStatusDataInternal,
 };
 
 export default timeGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/timeStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailManage/timeStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailManage/timeStatusApi.js	2025-03-12 13:30:03.138012600 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailManage/timeStatusApi.js	2025-03-11 11:17:10.596469000 +0900
@@ -1,101 +1,140 @@
 import baseApi from '@api/common/baseApi';
 
-const timeStatusApi = {
-  ...baseApi,
-
-  getTimeStatusList: async (parameters) => {
+async function getTimeStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getTimeStatusDetails: async (parameters) => {
-    const result = await timeStatusApi.axios.post(`/api/sslswg/policy-manage/time`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getTimeStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+async function getTimeStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertTimeStatusData: async (data) => {
-    try {
-      const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '스케줄 정책이 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '스케줄 정책 등록이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getTimeStatusDetailsInternal(parameters, retryCount - 1);
     }
-  },
-
-  updateTimeStatusData: async (data) => {
-    try {
-      const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '스케줄 정책이 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '스케줄 정책 수정이 실패되었습니다.';
+    throw error;
+  }
+}
+
+async function insertTimeStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '스케줄 정책이 등록 되었습니다.';
     }
-  },
-
-  deleteTimeStatusData: async (parameters) => {
-    try {
-      const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '스케줄 정책이 삭제 되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertTimeStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+      return finalErrorMessage;
+    }
+    return '스케줄 정책 등록이 실패되었습니다.';
+  }
+}
+
+async function updateTimeStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '스케줄 정책이 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateTimeStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '스케줄 정책 삭제가 실패되었습니다.';
+      return finalErrorMessage;
+    }
+    return '스케줄 정책 수정이 실패되었습니다.';
+  }
+}
+
+async function deleteTimeStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await timeStatusApi.axios.post('/api/sslswg/policy-manage/time', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '스케줄 정책이 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteTimeStatusDataInternal(parameters, retryCount - 1);
     }
-  },
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '스케줄 정책 삭제가 실패되었습니다.';
+  }
+}
+
+const timeStatusApi = {
+  ...baseApi,
+  getTimeStatusList: getTimeStatusListInternal,
+  getTimeStatusDetails: getTimeStatusDetailsInternal,
+  insertTimeStatusData: insertTimeStatusDataInternal,
+  updateTimeStatusData: updateTimeStatusDataInternal,
+  deleteTimeStatusData: deleteTimeStatusDataInternal,
 };
 
 export default timeStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailStatusApi.js .\src\/api/hss/sslswg/policy/policyDetailStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyDetailStatusApi.js	2025-02-19 14:50:03.757808500 +0900
+++ .\src\/api/hss/sslswg/policy/policyDetailStatusApi.js	2025-03-11 11:19:25.788604300 +0900
@@ -1,116 +1,175 @@
 import baseApi from '@api/common/baseApi';
 
-const policyDetailStatusApi = {
-  ...baseApi,
-
-  getPolicyDetailStatusList: async (parameters) => {
+// 정책 상세 상태 목록 조회 (재시도 로직 포함)
+async function getPolicyDetailStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await policyDetailStatusApi.axios.post(
       '/api/sslswg/policy-manage/policy-detail',
       {
         run_type: 'get',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getPolicyDetailStatusDetails: async (parameters) => {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyDetailStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 상세 상태 상세 조회 (재시도 로직 포함)
+async function getPolicyDetailStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await policyDetailStatusApi.axios.post(
-      `/api/sslswg/policy-manage/policy-detail`,
+      '/api/sslswg/policy-manage/policy-detail',
       {
         run_type: 'get',
         id: parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertPolicyDetailStatusData: async (data) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslswg/policy-manage/policy-detail',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '정책 상세 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 상세 정보 등록이 실패되었습니다.';
-    }
-  },
-
-  updatePolicyDetailStatusData: async (data) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslswg/policy-manage/policy-detail',
-        {
-          run_type: 'put',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '정책 상세 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 상세 정보 수정이 실패되었습니다.';
-    }
-  },
-
-  deletePolicyDetailStatusData: async (parameters) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslswg/policy-manage/policy-detail',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '정책 상세 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyDetailStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 상세 상태 등록 (재시도 로직 포함)
+async function insertPolicyDetailStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-detail',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return '정책 상세 정보가 등록 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertPolicyDetailStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '정책 상세 정보 삭제가 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
+    return '정책 상세 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 정책 상세 상태 수정 (재시도 로직 포함)
+async function updatePolicyDetailStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-detail',
+      {
+        run_type: 'put',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return '정책 상세 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updatePolicyDetailStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '정책 상세 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 정책 상세 상태 삭제 (재시도 로직 포함)
+async function deletePolicyDetailStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-detail',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '정책 상세 정보가 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deletePolicyDetailStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '정책 상세 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const policyDetailStatusApi = {
+  ...baseApi,
+  getPolicyDetailStatusList: getPolicyDetailStatusListInternal,
+  getPolicyDetailStatusDetails: getPolicyDetailStatusDetailsInternal,
+  insertPolicyDetailStatusData: insertPolicyDetailStatusDataInternal,
+  updatePolicyDetailStatusData: updatePolicyDetailStatusDataInternal,
+  deletePolicyDetailStatusData: deletePolicyDetailStatusDataInternal,
 };
 
 export default policyDetailStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslswg/policy/policyGroupStatusApi.js .\src\/api/hss/sslswg/policy/policyGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslswg/policy/policyGroupStatusApi.js	2025-03-12 13:30:03.139038500 +0900
+++ .\src\/api/hss/sslswg/policy/policyGroupStatusApi.js	2025-03-11 11:20:07.017181900 +0900
@@ -1,104 +1,160 @@
 import baseApi from '@api/common/baseApi';
 
-const policyGroupStatusApi = {
-  ...baseApi,
-
-  getPolicyGroupStatusList: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post('/api/sslswg/policy-manage/policy-group', {
-      run_type: 'get',
-      ...parameters,
-    });
-
+// 정책 그룹 상태 목록 조회 (재시도 로직 포함)
+async function getPolicyGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-group',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getPolicyGroupStatusDetails: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post('/api/sslswg/policy-manage/policy-group', {
-      run_type: 'get',
-      id: parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 그룹 상태 상세 조회 (재시도 로직 포함)
+async function getPolicyGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-group',
+      {
+        run_type: 'get',
+        id: parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getMappingListAllWithPolicyGroupId: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post('/api/sslswg/policy-manage/policy-group', {
-      run_type: 'get',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 그룹 상태 등록 (재시도 로직 포함)
+async function insertPolicyGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-group',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
-      return result.data.data;
+      return `정책 그룹 정보가 등록 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
     }
-  },
-
-  insertPolicyGroupStatusData: async (data) => {
-    try {
-      const result = await policyGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/policy-group',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '정책 그룹이 등록 되었습니다.\n세그먼트를 재시작하시기 바랍니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 그룹 등록이 실패되었습니다.';
-    }
-  },
-
-  updateMappingListWithPolicyGroupId: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post('/api/sslswg/policy-manage/policy-group', {
-      run_type: 'put',
-      mode: 'mapping',
-      ...parameters,
-    });
-
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertPolicyGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '정책 그룹 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 정책 그룹 상태 수정 (재시도 로직 포함)
+async function updatePolicyGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-group',
+      {
+        run_type: 'put',
+        ...data,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
-      return result.data.data;
+      return `정책 그룹 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
     }
-  },
-
-  deletePolicyGroupStatusData: async (parameters) => {
-    try {
-      const result = await policyGroupStatusApi.axios.post(
-        '/api/sslswg/policy-manage/policy-group',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '정책 그룹이 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updatePolicyGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '정책 그룹 삭제가 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
+    return '정책 그룹 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 정책 그룹 상태 삭제 (재시도 로직 포함)
+async function deletePolicyGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslswg/policy-manage/policy-group',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return `정책 그룹 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deletePolicyGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '정책 그룹 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const policyGroupStatusApi = {
+  ...baseApi,
+  getPolicyGroupStatusList: getPolicyGroupStatusListInternal,
+  getPolicyGroupStatusDetails: getPolicyGroupStatusDetailsInternal,
+  insertPolicyGroupStatusData: insertPolicyGroupStatusDataInternal,
+  updatePolicyGroupStatusData: updatePolicyGroupStatusDataInternal,
+  deletePolicyGroupStatusData: deletePolicyGroupStatusDataInternal,
 };
 
 export default policyGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslva/policy/policyDetailStatusApi.js .\src\/api/hss/sslva/policy/policyDetailStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslva/policy/policyDetailStatusApi.js	2025-02-19 14:50:03.761808700 +0900
+++ .\src\/api/hss/sslva/policy/policyDetailStatusApi.js	2025-03-11 12:00:45.709420700 +0900
@@ -1,116 +1,175 @@
 import baseApi from '@api/common/baseApi';
 
-const policyDetailStatusApi = {
-  ...baseApi,
-
-  getPolicyDetailStatusList: async (parameters) => {
+// 정책 상세 상태 목록 조회 (재시도 로직 포함)
+async function getPolicyDetailStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await policyDetailStatusApi.axios.post(
       '/api/sslva/policy-manage/policy-detail',
       {
         run_type: 'get',
         ...parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getPolicyDetailStatusDetails: async (parameters) => {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyDetailStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 상세 상태 상세 조회 (재시도 로직 포함)
+async function getPolicyDetailStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await policyDetailStatusApi.axios.post(
-      `/api/sslva/policy-manage/policy-detail`,
+      '/api/sslva/policy-manage/policy-detail',
       {
         run_type: 'get',
         id: parameters,
-      },
+        signal,
+      }
     );
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertPolicyDetailStatusData: async (data) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-detail',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return '정책 상세 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 상세 정보 등록이 실패되었습니다.';
-    }
-  },
-
-  updatePolicyDetailStatusData: async (data) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-detail',
-        {
-          run_type: 'put',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return `정책 상세 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 상세 정보 수정이 실패되었습니다.';
-    }
-  },
-
-  deletePolicyDetailStatusData: async (parameters) => {
-    try {
-      const result = await policyDetailStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-detail',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return `정책 상세 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyDetailStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 상세 상태 등록 (재시도 로직 포함)
+async function insertPolicyDetailStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-detail',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return '정책 상세 정보가 등록 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertPolicyDetailStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '정책 상세 정보 삭제가 실패되었습니다.';
+      return finalErrorMessage;
     }
-  },
+    return '정책 상세 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 정책 상세 상태 수정 (재시도 로직 포함)
+async function updatePolicyDetailStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-detail',
+      {
+        run_type: 'put',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return `정책 상세 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updatePolicyDetailStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '정책 상세 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 정책 상세 상태 삭제 (재시도 로직 포함)
+async function deletePolicyDetailStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyDetailStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-detail',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return `정책 상세 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deletePolicyDetailStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '정책 상세 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const policyDetailStatusApi = {
+  ...baseApi,
+  getPolicyDetailStatusList: getPolicyDetailStatusListInternal,
+  getPolicyDetailStatusDetails: getPolicyDetailStatusDetailsInternal,
+  insertPolicyDetailStatusData: insertPolicyDetailStatusDataInternal,
+  updatePolicyDetailStatusData: updatePolicyDetailStatusDataInternal,
+  deletePolicyDetailStatusData: deletePolicyDetailStatusDataInternal,
 };
 
 export default policyDetailStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslva/policy/policyGroupStatusApi.js .\src\/api/hss/sslva/policy/policyGroupStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslva/policy/policyGroupStatusApi.js	2025-02-19 14:50:03.761808700 +0900
+++ .\src\/api/hss/sslva/policy/policyGroupStatusApi.js	2025-03-11 12:01:34.868071100 +0900
@@ -1,110 +1,175 @@
 import baseApi from '@api/common/baseApi';
 
-const policyGroupStatusApi = {
-  ...baseApi,
-
-  getPolicyGroupStatusList: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post('/api/sslva/policy-manage/policy-group', {
-      run_type: 'get',
-      ...parameters,
-    });
-
+// 정책 그룹 상태 목록 조회 (재시도 로직 포함)
+async function getPolicyGroupStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-group',
+      {
+        run_type: 'get',
+        ...parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getPolicyGroupStatusDetails: async (parameters) => {
-    const result = await policyGroupStatusApi.axios.post(`/api/sslva/policy-manage/policy-group`, {
-      run_type: 'get',
-      id: parameters,
-    });
-
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyGroupStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 그룹 상태 상세 조회 (재시도 로직 포함)
+async function getPolicyGroupStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-group',
+      {
+        run_type: 'get',
+        id: parameters,
+        signal,
+      }
+    );
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertPolicyGroupStatusData: async (data) => {
-    try {
-      const result = await policyGroupStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-group',
-        {
-          run_type: 'add',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return `정책 그룹 정보가 등록 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 그룹 정보 등록이 실패되었습니다.';
-    }
-  },
-
-  updatePolicyGroupStatusData: async (data) => {
-    try {
-      const result = await policyGroupStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-group',
-        {
-          run_type: 'put',
-          ...data,
-        },
-      );
-
-      if (!result.data.errorYn) {
-        return `정책 그룹 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '정책 그룹 정보 수정이 실패되었습니다.';
-    }
-  },
-
-  deletePolicyGroupStatusData: async (parameters) => {
-    try {
-      const result = await policyGroupStatusApi.axios.post(
-        '/api/sslva/policy-manage/policy-group',
-        {
-          run_type: 'del',
-          data: parameters,
-        },
-      );
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return `정책 그룹 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getPolicyGroupStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 정책 그룹 상태 등록 (재시도 로직 포함)
+async function insertPolicyGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-group',
+      {
+        run_type: 'add',
+        ...data,
+        signal,
       }
-      return '정책 그룹 정보 삭제가 실패되었습니다.';
+    );
+    if (!result.data.errorYn) {
+      return `정책 그룹 정보가 등록 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertPolicyGroupStatusDataInternal(data, retryCount - 1);
     }
-  },
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '정책 그룹 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 정책 그룹 상태 수정 (재시도 로직 포함)
+async function updatePolicyGroupStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-group',
+      {
+        run_type: 'put',
+        ...data,
+        signal,
+      }
+    );
+    if (!result.data.errorYn) {
+      return `정책 그룹 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updatePolicyGroupStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '정책 그룹 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 정책 그룹 상태 삭제 (재시도 로직 포함)
+async function deletePolicyGroupStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await policyGroupStatusApi.axios.post(
+      '/api/sslva/policy-manage/policy-group',
+      {
+        run_type: 'del',
+        data: parameters,
+        signal,
+      }
+    );
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return `정책 그룹 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deletePolicyGroupStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '정책 그룹 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const policyGroupStatusApi = {
+  ...baseApi,
+  getPolicyGroupStatusList: getPolicyGroupStatusListInternal,
+  getPolicyGroupStatusDetails: getPolicyGroupStatusDetailsInternal,
+  insertPolicyGroupStatusData: insertPolicyGroupStatusDataInternal,
+  updatePolicyGroupStatusData: updatePolicyGroupStatusDataInternal,
+  deletePolicyGroupStatusData: deletePolicyGroupStatusDataInternal,
 };
 
 export default policyGroupStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslva/policy/protocolStatusApi.js .\src\/api/hss/sslva/policy/protocolStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslva/policy/protocolStatusApi.js	2025-03-12 13:30:03.140064400 +0900
+++ .\src\/api/hss/sslva/policy/protocolStatusApi.js	2025-03-11 12:02:44.973164800 +0900
@@ -1,133 +1,145 @@
 import baseApi from '@api/common/baseApi';
 
-const protocolStatusApi = {
-  ...baseApi,
-
-  getProtocolStatusList: async (parameters) => {
+// 프로토콜 상태 목록 조회 (재시도 로직 포함)
+async function getProtocolStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getProtocolStatusDetails: async (parameters) => {
-    const result = await protocolStatusApi.axios.post(`/api/sslva/policy-manage/protocol`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getProtocolStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 프로토콜 상태 상세 조회 (재시도 로직 포함)
+async function getProtocolStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getProtocolObjectType: async (parameters) => {
-    // const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
-    //   run_type: 'get',
-    //   contentOnly: true,
-    //   uuids: {
-    //     ...parameters,
-    //   },
-    // });
-
-    // if (result.data.errorYn) {
-    //   return;
-    // }
-
-    // const dataList = result.data.data;
-    // const updateDataList = [...dataList];
-    // const idOnly = dataList.map((item) => item.id);
-
-    // return { updateDataList, idOnly };
-  },
-
-  getProtocolTypeList: async () => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getProtocolStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 프로토콜 상태 등록 (재시도 로직 포함)
+async function insertProtocolStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
-      run_type: 'get',
-      protocolType: true,
+      run_type: 'add',
+      ...data,
+      signal,
     });
     if (!result.data.errorYn) {
-      return result.data.data;
+      return '프로토콜 정보가 등록 되었습니다.';
     }
-  },
-
-  insertProtocolStatusData: async (data) => {
-    try {
-      const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '프로토콜 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '프로토콜 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertProtocolStatusDataInternal(data, retryCount - 1);
     }
-  },
-
-  updateProtocolStatusData: async (data) => {
-    // try {
-    //   const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
-    //     run_type: 'put',
-    //     ...data,
-    //   });
-
-    //   if (!result.data.errorYn) {
-    //     return '프로토콜 정보가 수정 되었습니다.';
-    //   }
-    // } catch (error) {
-    //   if (error.response && error.response.data.errorYn) {
-    //     return error.response.data.error.errorMessage;
-    //   }
-    //   return '프로토콜 정보 수정이 실패되었습니다.';
-    // }
-  },
-
-  deleteProtocolStatusData: async (parameters) => {
-    try {
-      const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return `프로토콜 정보가 삭제 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+      return finalErrorMessage;
+    }
+    return '프로토콜 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 프로토콜 상태 수정 (재시도 로직 포함)
+async function updateProtocolStatusDataInternal(data, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '프로토콜 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateProtocolStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '프로토콜 정보 삭제가 실패되었습니다.';
+      return finalErrorMessage;
+    }
+    return '프로토콜 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 프로토콜 상태 삭제 (재시도 로직 포함)
+async function deleteProtocolStatusDataInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await protocolStatusApi.axios.post('/api/sslva/policy-manage/protocol', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '프로토콜 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteProtocolStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '프로토콜 정보 삭제가 실패되었습니다.';
+  }
+}
 
-  getProtocolStatusContentList: async (parameters) => {
-    // const result = await protocolStatusApi.axios.post(`/api/sslva/policy-manage/protocol`, {
-    //   run_type: 'get',
-    //   contentOnly: true,
-    // });
-
-    // if (!result.data.errorYn) {
-    //   return result.data.data;
-    // }
-  },
+const protocolStatusApi = {
+  ...baseApi,
+  getProtocolStatusList: getProtocolStatusListInternal,
+  getProtocolStatusDetails: getProtocolStatusDetailsInternal,
+  insertProtocolStatusData: insertProtocolStatusDataInternal,
+  updateProtocolStatusData: updateProtocolStatusDataInternal,
+  deleteProtocolStatusData: deleteProtocolStatusDataInternal,
 };
 
 export default protocolStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslva/policy/segmentStatusApi.js .\src\/api/hss/sslva/policy/segmentStatusApi.js
--- ..\hss-frontend\src\/api/hss/sslva/policy/segmentStatusApi.js	2025-02-19 14:50:03.762808300 +0900
+++ .\src\/api/hss/sslva/policy/segmentStatusApi.js	2025-03-11 12:04:00.607168500 +0900
@@ -1,140 +1,223 @@
 import baseApi from '@api/common/baseApi';
 
-const segmentStatusApi = {
-  ...baseApi,
-
-  getSegmentStatusList: async (parameters) => {
+// 세그먼트 목록 조회 (재시도 로직 포함)
+async function getSegmentStatusListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSegmentStatusDetails: async (parameters) => {
-    const result = await segmentStatusApi.axios.post(`/api/sslva/policy-manage/segment`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSegmentStatusListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 세그먼트 상세 조회 (재시도 로직 포함)
+async function getSegmentStatusDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getSegmentStatusColumnList: async (parameter) => {
-    const result = await segmentStatusApi.axios.post(`/api/sslva/policy-manage/segment`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSegmentStatusDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 세그먼트 컬럼 목록 조회 (재시도 로직 포함)
+async function getSegmentStatusColumnListInternal(parameter, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
       run_type: 'get',
       column: parameter,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertSegmentStatusData: async (data) => {
-    try {
-      const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return `세그먼트 정보가 등록 되었습니다.\n세그먼트를 시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '세그먼트 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getSegmentStatusColumnListInternal(parameter, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 세그먼트 등록 (재시도 로직 포함)
+async function insertSegmentStatusDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return `세그먼트 정보가 등록 되었습니다.\n세그먼트를 시작하시기 바랍니다.`;
     }
-  },
-
-  updateSegmentStatusData: async (data) => {
-    try {
-      const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return `세그먼트 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '세그먼트 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertSegmentStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '세그먼트 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 세그먼트 수정 (재시도 로직 포함)
+async function updateSegmentStatusDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return `세그먼트 정보가 수정 되었습니다.\n세그먼트를 재시작하시기 바랍니다.`;
     }
-  },
-
-  updateSegmentStatus: async (id) => {
-    try {
-      const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
-        run_type: 'put',
-        status: true,
-        name: id,
-      });
-
-      if (!result.data.errorYn) {
-        return '세그먼트 상태 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '세그먼트 상태 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateSegmentStatusDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '세그먼트 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 세그먼트 상태 수정 (updateSegmentStatus) (재시도 로직 포함)
+async function updateSegmentStatusInternal(id, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
+      run_type: 'put',
+      status: true,
+      name: id,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '세그먼트 상태 정보가 수정 되었습니다.';
     }
-  },
-
-  deleteSegmentStatusData: async (parameters) => {
-    try {
-      const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '세그먼트 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '세그먼트 정보 삭제가 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateSegmentStatusInternal(id, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return '세그먼트 상태 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 세그먼트 삭제 (재시도 로직 포함)
+async function deleteSegmentStatusDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await segmentStatusApi.axios.post('/api/sslva/policy-manage/segment', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '세그먼트 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteSegmentStatusDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '세그먼트 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const segmentStatusApi = {
+  ...baseApi,
+  getSegmentStatusList: getSegmentStatusListInternal,
+  getSegmentStatusDetails: getSegmentStatusDetailsInternal,
+  getSegmentStatusColumnList: getSegmentStatusColumnListInternal,
+  insertSegmentStatusData: insertSegmentStatusDataInternal,
+  updateSegmentStatusData: updateSegmentStatusDataInternal,
+  updateSegmentStatus: updateSegmentStatusInternal,
+  deleteSegmentStatusData: deleteSegmentStatusDataInternal,
 };
 
 export default segmentStatusApi;
diff -urN ..\hss-frontend\src\/api/hss/sslvpn/userApi.js .\src\/api/hss/sslvpn/userApi.js
--- ..\hss-frontend\src\/api/hss/sslvpn/userApi.js	2025-02-19 14:50:03.763808500 +0900
+++ .\src\/api/hss/sslvpn/userApi.js	2025-03-11 12:05:15.636998100 +0900
@@ -1,92 +1,153 @@
 import baseApi from '@api/common/baseApi';
 
-const userApi = {
-  ...baseApi,
-
-  getUserList: async (parameters) => {
+// 사용자 목록 조회 (재시도 로직 포함)
+async function getUserListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await userApi.axios.post('/api/sslvpn/user', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getUserDetails: async (parameters) => {
-    const result = await userApi.axios.post(`/api/sslvpn/user`, {
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getUserListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// 사용자 상세 조회 (재시도 로직 포함)
+async function getUserDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await userApi.axios.post('/api/sslvpn/user', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertUserData: async (data) => {
-    try {
-      const result = await userApi.axios.post('/api/sslvpn/user', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '사용자 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return '사용자 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getUserDetailsInternal(parameters, retryCount - 1);
     }
-  },
-
-  updateUserData: async (data) => {
-    try {
-      const result = await userApi.axios.post('/api/sslvpn/user', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return '사용자 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return '사용자 정보 수정이 실패되었습니다.';
+    throw error;
+  }
+}
+
+// 사용자 등록 (재시도 로직 포함)
+async function insertUserDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await userApi.axios.post('/api/sslvpn/user', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '사용자 정보가 등록 되었습니다.';
     }
-  },
-
-  deleteUserData: async (parameters) => {
-    try {
-      const result = await userApi.axios.post('/api/sslvpn/user', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return '사용자 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertUserDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
       }
-      return '사용자 정보 삭제가 실패되었습니다.';
+      return finalErrorMessage;
+    }
+    return '사용자 정보 등록이 실패되었습니다.';
+  }
+}
+
+// 사용자 수정 (재시도 로직 포함)
+async function updateUserDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await userApi.axios.post('/api/sslvpn/user', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return '사용자 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateUserDataInternal(data, retryCount - 1);
     }
-  },
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '사용자 정보 수정이 실패되었습니다.';
+  }
+}
+
+// 사용자 삭제 (재시도 로직 포함)
+async function deleteUserDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await userApi.axios.post('/api/sslvpn/user', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return '사용자 정보가 삭제 되었습니다.';
+    }
+  } catch (error) {
+    if (
+      (error.name === 'CanceledError' || error.code === 'ERR_CANCELED') &&
+      retryCount > 0
+    ) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteUserDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return '사용자 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const userApi = {
+  ...baseApi,
+  getUserList: getUserListInternal,
+  getUserDetails: getUserDetailsInternal,
+  insertUserData: insertUserDataInternal,
+  updateUserData: updateUserDataInternal,
+  deleteUserData: deleteUserDataInternal,
 };
 
 export default userApi;
diff -urN ..\hss-frontend\src\/api/hss/sslvpn/zoneApi.js .\src\/api/hss/sslvpn/zoneApi.js
--- ..\hss-frontend\src\/api/hss/sslvpn/zoneApi.js	2025-02-19 14:50:03.764808400 +0900
+++ .\src\/api/hss/sslvpn/zoneApi.js	2025-03-11 16:09:53.172116100 +0900
@@ -1,142 +1,218 @@
 import baseApi from '@api/common/baseApi';
 
-const zoneApi = {
-  ...baseApi,
 
-  getZoneMakeInfo: async () => {
-    const result = await zoneApi.axios.post(`/api/sslvpn/zone`, {
+async function getZoneMakeInfoInternal(retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
       run_type: 'get',
       mkinfo: 'true',
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getZoneList: async (parameters) => {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getZoneListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// ZONE 목록 조회 (재시도 로직 포함)
+async function getZoneListInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
     const result = await zoneApi.axios.post('/api/sslvpn/zone', {
       run_type: 'get',
       ...parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getZoneDetails: async (parameters) => {
-    const result = await zoneApi.axios.post(`/api/sslvpn/zone`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getZoneListInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// ZONE 상세 조회 (재시도 로직 포함)
+async function getZoneDetailsInternal(parameters, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
       run_type: 'get',
       id: parameters,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  getZoneColumnList: async (parameter) => {
-    const result = await zoneApi.axios.post(`/api/sslvpn/zone`, {
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getZoneDetailsInternal(parameters, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// ZONE 컬럼 목록 조회 (재시도 로직 포함)
+async function getZoneColumnListInternal(parameter, retryCount = 3) {
+  const controller = new AbortController();
+  const signal = controller.signal;
+  try {
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
       run_type: 'get',
       column: parameter,
+      signal,
     });
-
     if (!result.data.errorYn) {
       return result.data.data;
     }
-  },
-
-  insertZoneData: async (data) => {
-    try {
-      const result = await zoneApi.axios.post('/api/sslvpn/zone', {
-        run_type: 'add',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return 'ZONE 정보가 등록 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return 'ZONE 정보 등록이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getZoneColumnListInternal(parameter, retryCount - 1);
+    }
+    throw error;
+  }
+}
+
+// ZONE 등록 (재시도 로직 포함)
+async function insertZoneDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
+      run_type: 'add',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return 'ZONE 정보가 등록 되었습니다.';
     }
-  },
-
-  updateZoneData: async (data) => {
-    try {
-      const result = await zoneApi.axios.post('/api/sslvpn/zone', {
-        run_type: 'put',
-        ...data,
-      });
-
-      if (!result.data.errorYn) {
-        return 'ZONE 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return 'ZONE 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return insertZoneDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return 'ZONE 정보 등록이 실패되었습니다.';
+  }
+}
+
+// ZONE 수정 (재시도 로직 포함)
+async function updateZoneDataInternal(data, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
+      run_type: 'put',
+      ...data,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return 'ZONE 정보가 수정 되었습니다.';
     }
-  },
-
-  updateZoneStatus: async (id) => {
-    try {
-      const result = await zoneApi.axios.post('/api/sslvpn/zone', {
-        run_type: 'put',
-        status: true,
-        name: id,
-      });
-
-      if (!result.data.errorYn) {
-        return 'ZONE 상태 정보가 수정 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        const errorMessage = error.response.data.error.errorMessage;
-        let finalErrorMessage = '';
-        if (typeof errorMessage === 'object') {
-          finalErrorMessage = Object.values(errorMessage)
-            .flat() // 배열의 배열을 평탄화
-            .shift(); // 배열의 첫 번째 요소
-        } else {
-          finalErrorMessage = errorMessage;
-        }
-        return finalErrorMessage;
-      }
-      return 'ZONE 상태 정보 수정이 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateZoneDataInternal(data, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return 'ZONE 정보 수정이 실패되었습니다.';
+  }
+}
+
+// ZONE 상태 수정 (재시도 로직 포함)
+async function updateZoneStatusInternal(id, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
+      run_type: 'put',
+      status: true,
+      name: id,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return 'ZONE 상태 정보가 수정 되었습니다.';
     }
-  },
-
-  deleteZoneData: async (parameters) => {
-    try {
-      const result = await zoneApi.axios.post('/api/sslvpn/zone', {
-        run_type: 'del',
-        data: parameters,
-      });
-
-      if (!result.data.errorYn && result.data.data.count > 0) {
-        return 'ZONE 정보가 삭제 되었습니다.';
-      }
-    } catch (error) {
-      if (error.response && error.response.data.errorYn) {
-        return error.response.data.error.errorMessage;
-      }
-      return 'ZONE 정보 삭제가 실패되었습니다.';
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateZoneStatusInternal(id, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return 'ZONE 상태 정보 수정이 실패되었습니다.';
+  }
+}
+
+// ZONE 삭제 (재시도 로직 포함)
+async function deleteZoneDataInternal(parameters, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
+      run_type: 'del',
+      data: parameters,
+      signal,
+    });
+    if (!result.data.errorYn && result.data.data.count > 0) {
+      return 'ZONE 정보가 삭제 되었습니다.';
     }
-  },
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return deleteZoneDataInternal(parameters, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      return error.response.data.error.errorMessage;
+    }
+    return 'ZONE 정보 삭제가 실패되었습니다.';
+  }
+}
+
+const zoneApi = {
+  ...baseApi,
+  getZoneMakeInfo : getZoneMakeInfoInternal,
+  getZoneList: getZoneListInternal,
+  getZoneDetails: getZoneDetailsInternal,
+  getZoneColumnList: getZoneColumnListInternal,
+  insertZoneData: insertZoneDataInternal,
+  updateZoneData: updateZoneDataInternal,
+  updateZoneStatus: updateZoneStatusInternal,
+  deleteZoneData: deleteZoneDataInternal,
 };
 
 export default zoneApi;
diff -urN ..\hss-frontend\src\/api/system/menuApi.js .\src\/api/system/menuApi.js
--- ..\hss-frontend\src\/api/system/menuApi.js	2024-10-18 16:27:14.012291100 +0900
+++ .\src\/api/system/menuApi.js	2025-03-06 17:43:06.745395300 +0900
@@ -1,46 +1,30 @@
 import baseApi from '@api/common/baseApi';
 
 const menuListCache = {};
+
 const menuApi = {
   ...baseApi,
 
-  getMenuList: ({ useYn, isMenu, isEdit = false, ...rest }) => {
+  getMenuList: async ({ useYn, isMenu, isEdit = false, signal, ...rest }) => {
     const key = JSON.stringify({ useYn, isMenu, ...rest });
-    const cached = menuListCache[`${key}`];
-    if (!cached || isEdit) {
-      menuListCache[`${key}`] = menuApi.axios.get('/api/system/menus', {
-        params: {
-          useYn,
-          isMenu,
-          ...rest,
-        },
-      });
-      return menuListCache[`${key}`];
-    }
-    return cached;
-  },
-  editMenuList: (menuList) => {
-    return menuApi.axios.put('/api/system/menus', menuList);
-  },
-  getUpperMenuList: () => {
-    return menuApi.axios.get('/api/system/menus/upper-menus');
-  },
+    const cached = menuListCache[key];
 
-  insertMenu: (parameters) => {
-    return menuApi.axios.post('/api/system/menus', parameters);
-  },
+    if (cached && !isEdit) {
+      return cached;
+    }
 
-  updateMenu: (parameters) => {
-    return menuApi.axios.put('/api/system/menus/config', parameters);
-  },
-  updateMenuDisplayOrder: (parameters) => {
-    return menuApi.axios.put('/api/system/menus/displayOrder', parameters);
-  },
+    try {
+      const response = await menuApi.axios.get('/api/system/menus', {
+        params: { useYn, isMenu, ...rest },
+        signal,
+      });
 
-  deleteMenu: (parameters) => {
-    return menuApi.axios.delete('/api/system/menus', {
-      data: parameters,
-    });
+      menuListCache[key] = response;
+      return response;
+    } catch (error) {
+      delete menuListCache[key]; // 요청 실패 시 캐시 삭제
+      throw error;
+    }
   },
 };
 
diff -urN ..\hss-frontend\src\/api/system/preferencesApi.js .\src\/api/system/preferencesApi.js
--- ..\hss-frontend\src\/api/system/preferencesApi.js	2024-10-18 16:27:14.013291400 +0900
+++ .\src\/api/system/preferencesApi.js	2025-03-08 16:23:06.159255300 +0900
@@ -16,7 +16,6 @@
   },
 
   updatePreferences: (parameters) => {
-    console.log(parameters);
     return preferencesApi.axios.put('/api/system/preferences', parameters);
   },
 };
diff -urN ..\hss-frontend\src\/components/@extended/Avatar.jsx .\src\/components/@extended/Avatar.jsx
--- ..\hss-frontend\src\/components/@extended/Avatar.jsx	2024-10-18 16:27:14.018285900 +0900
+++ .\src\/components/@extended/Avatar.jsx	2025-03-05 16:43:47.769705200 +0900
@@ -101,10 +101,9 @@
 // ==============================|| EXTENDED - AVATAR ||============================== //
 
 export default function Avatar({ children, color = 'primary', type, size = 'md', ...others }) {
-  const theme = useTheme();
 
   return (
-    <AvatarStyle theme={theme} color={color} type={type} size={size} {...others}>
+    <AvatarStyle color={color} type={type} size={size} {...others}>
       {children}
     </AvatarStyle>
   );
diff -urN ..\hss-frontend\src\/components/@extended/Breadcrumbs.jsx .\src\/components/@extended/Breadcrumbs.jsx
--- ..\hss-frontend\src\/components/@extended/Breadcrumbs.jsx	2024-10-18 16:27:14.018285900 +0900
+++ .\src\/components/@extended/Breadcrumbs.jsx	2025-03-07 14:52:11.675669800 +0900
@@ -1,6 +1,7 @@
 import PropTypes from 'prop-types';
-import { useEffect, useState } from 'react';
+import { useEffect, useState, useRef } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
+import { useRouter } from 'next/router';
 
 // material-ui
 import MuiBreadcrumbs from '@mui/material/Breadcrumbs';
@@ -13,10 +14,10 @@
 import { setSelectedCollapse } from '@modules/redux/reducers/menu';
 
 // assets
-import { ApartmentOutlined } from '@ant-design/icons';
-import useConfig from '@modules/hooks/useConfig';
 import FullscreenIcon from '@mui/icons-material/Fullscreen';
 import FullscreenExitIcon from '@mui/icons-material/FullscreenExit';
+import useConfig from '@modules/hooks/useConfig';
+
 // ==============================|| BREADCRUMBS ||============================== //
 
 const Breadcrumbs = ({
@@ -31,76 +32,76 @@
   ...others
 }) => {
   const theme = useTheme();
-  const [main, setMain] = useState([]);
-  const [item, setItem] = useState();
+  const router = useRouter();
   const dispatch = useDispatch();
-  const {
-    menuItem: { items },
-  } = useSelector((state) => state.menu);
-
-  const iconSX = {
-    marginRight: theme.spacing(0.75),
-    marginTop: `-${theme.spacing(0.25)}`,
-    width: '1rem',
-    height: '1rem',
-    color: theme.palette.secondary.main,
-  };
+  const isMountedRef = useRef(false);
+  const [main, setMain] = useState([]);
+  const [item, setItem] = useState(null);
 
-  let currentPath = document.location.pathname;
+  const { menuItem: { items } } = useSelector((state) => state.menu);
+  const { fullSizeFlag, onChangeFullSizeFlag } = useConfig();
 
-  // set active item state
-  const getCollapse = (menu, mainArr = []) => {
-    const urlList = menu.url.split('/').filter((url) => url);
-    const sameEl = menu.url.split('/').filter((url) => url && currentPath.split('/').includes(url));
+  const currentPath = router.pathname;
 
-    if (sameEl.length === urlList.length) mainArr.push(menu);
-    if (menu.children) {
-      menu.children.filter((child) => {
-        const urlList = child.url.split('/').filter((url) => url);
-        const sameEl = child.url
-          .split('/')
-          .filter((url) => url && currentPath.split('/').includes(url));
-
-        if (child.type && child.type === 'collapse') {
-          getCollapse(child, mainArr);
-        } else if (child.type && child.type === 'item' && child.breadcrumbs !== false) {
-          let urlMatch = false;
-          if (sameEl.length >= urlList.length - 1) {
-            let preUrl = '/';
-            for (let i = 0; i < urlList.length - 1; i++) {
-              preUrl += `${urlList[`${i}`]}/`;
+  const getCollapse = (menu, mainArr = []) => {
+    try {
+      const urlList = menu.url.split('/').filter((url) => url);
+      const sameEl = menu.url.split('/').filter((url) => url && currentPath.split('/').includes(url));
+
+      if (sameEl.length === urlList.length) mainArr.push(menu);
+
+      if (menu.children) {
+        menu.children.forEach((child) => {
+          const urlList = child.url.split('/').filter((url) => url);
+          const sameEl = child.url.split('/').filter((url) => url && currentPath.split('/').includes(url));
+
+          if (child.type === 'collapse') {
+            getCollapse(child, mainArr);
+          } else if (child.type === 'item' && child.breadcrumbs !== false) {
+            let urlMatch = false;
+            if (sameEl.length >= urlList.length - 1) {
+              let preUrl = '/';
+              for (let i = 0; i < urlList.length - 1; i++) {
+                preUrl += `${urlList[i]}/`;
+              }
+              let regexp = new RegExp(`^${preUrl}${child.subUrlRegex}$`, 'gi');
+              urlMatch = regexp.test(currentPath);
+            }
+            if (urlMatch) {
+              if (!mainArr.find((data) => data.menuCode === menu.menuCode)) mainArr.push(menu);
+              setItem(child);
             }
-            // eslint-disable-next-line security/detect-non-literal-regexp
-            let regexp = new RegExp(`^${preUrl}${child.subUrlRegex}$`, 'gi');
-            urlMatch = regexp.test(currentPath);
-          }
-          if (urlMatch) {
-            if (!mainArr.find((data) => data.menuCode === menu.menuCode)) mainArr.push(menu);
-            setItem(child);
           }
-        }
-        return false;
-      });
-    }
-    if (mainArr.length !== 0) {
-      setMain(mainArr);
-      dispatch(setSelectedCollapse({ selectedCollapse: mainArr[0].url }));
+        });
+      }
+
+      if (mainArr.length > 0) {
+        setMain(mainArr);
+        dispatch(setSelectedCollapse({ selectedCollapse: mainArr[0].url }));
+      }
+    } catch (error) {
+      console.error("Breadcrumbs 오류 발생:", error);
     }
   };
 
   useEffect(() => {
-    setMain(null);
+    isMountedRef.current = true;
+    setMain([]);
     setItem(null);
   }, [currentPath]);
 
   useEffect(() => {
-    items.map((menu) => {
-      getCollapse(menu);
-      return false;
-    });
+    if (!isMountedRef.current) return;
+    try {
+      if (Array.isArray(items)) {
+        items.forEach((menu) => getCollapse(menu));
+      }
+    } catch (error) {
+      console.error("useEffect 실행 중 오류 발생:", error);
+    }
   }, [currentPath, items]);
 
-  // item separator
+  // 아이콘 및 스타일 지정
   const SeparatorIcon = separator;
   const separatorIcon = separator ? (
     <SeparatorIcon style={{ fontSize: '0.75rem', marginTop: 2 }} />
@@ -108,108 +109,68 @@
     '/'
   );
 
-  let mainContent;
-  let itemContent;
-  let breadcrumbContent = <Typography />;
-  let itemTitle = '';
-  let ItemIcon = iconMap(item?.icon);
-
-  // collapse item
-  mainContent = main?.map((depth) => (
-    <Typography
-      key={depth.menuCode}
-      variant="h6"
-      sx={{ textDecoration: 'none' }}
-      color="textSecondary"
-    >
+  let mainContent = main.map((depth) => (
+    <Typography key={depth.menuCode} variant="h6" sx={{ textDecoration: 'none' }} color="textSecondary">
       {depth.label}
     </Typography>
   ));
 
-  const { fullSizeFlag, onChangeFullSizeFlag } = useConfig();
+  let itemTitle = item ? item.label : '';
+  let ItemIcon = item ? iconMap(item.icon) : null;
 
-  // items
-  if (item && item.type === 'item') {
-    itemTitle = item.label;
-
-    //ItemIcon = item.icon ? iconMap(item.icon) : ApartmentOutlined;
-    itemContent = (
-      <Typography variant="subtitle1" color="textPrimary">
-        <Stack direction="row" alignItems="center">
-          {itemTitle}
-        </Stack>
-      </Typography>
-    );
-
-    // main
-    breadcrumbContent = (
-      <MainCard
-        border={card}
-        sx={card === false ? { mb: 3, bgcolor: 'transparent', ...sx } : { mb: 3, ...sx }}
-        {...others}
-        content={card}
-        shadow="none"
-      >
-        <Grid
-          container
-          direction={rightAlign ? 'row' : 'column'}
-          justifyContent={rightAlign ? 'space-between' : 'flex-start'}
-          alignItems={rightAlign ? 'center' : 'flex-start'}
-          spacing={1}
-        >
-          {title && !titleBottom && (
-            <Grid item xs={6}>
-              <Stack spacing={1} direction="row">
-                {ItemIcon ? <ItemIcon /> : null}
-                <Typography variant="h2">{item.label}</Typography>
-              </Stack>
-            </Grid>
-          )}
-          <Grid xs={6} item container justifyContent="flex-end" alignItems="center">
-            <Grid item>
-              <Stack direction="row" spacing={2}>
-                <MuiBreadcrumbs
-                  aria-label="breadcrumb"
-                  maxItems={maxItems || 8}
-                  separator={separatorIcon}
-                >
-                  {mainContent}
-                  {itemContent}
-                </MuiBreadcrumbs>
-
-                <IconButton
-                  size="small"
-                  sx={{
-                    height: '20px',
-                    width: '20px',
-                  }}
-                  onClick={() => onChangeFullSizeFlag(!fullSizeFlag)}
-                >
-                  {fullSizeFlag ? (
-                    <FullscreenIcon fontSize="small" />
-                  ) : (
-                    <FullscreenExitIcon fontSize="small" />
-                  )}
-                </IconButton>
-              </Stack>
-            </Grid>
+  let itemContent = item && (
+    <Typography variant="subtitle1" color="textPrimary">
+      <Stack direction="row" alignItems="center">
+        {itemTitle}
+      </Stack>
+    </Typography>
+  );
+
+  return (
+    <MainCard
+      border={card}
+      sx={card === false ? { mb: 3, bgcolor: 'transparent', ...sx } : { mb: 3, ...sx }}
+      {...others}
+      content={card}
+      shadow="none"
+    >
+      <Grid container direction={rightAlign ? 'row' : 'column'} justifyContent={rightAlign ? 'space-between' : 'flex-start'} alignItems={rightAlign ? 'center' : 'flex-start'} spacing={1}>
+        {title && !titleBottom && (
+          <Grid item xs={6}>
+            <Stack spacing={1} direction="row">
+              {ItemIcon ? <ItemIcon /> : null}
+              <Typography variant="h2">{itemTitle}</Typography>
+            </Stack>
+          </Grid>
+        )}
+        <Grid xs={6} item container justifyContent="flex-end" alignItems="center">
+          <Grid item>
+            <Stack direction="row" spacing={2}>
+              <MuiBreadcrumbs aria-label="breadcrumb" maxItems={maxItems || 8} separator={separatorIcon}>
+                {mainContent}
+                {itemContent}
+              </MuiBreadcrumbs>
+
+              <IconButton
+                size="small"
+                sx={{ height: '20px', width: '20px' }}
+                onClick={() => onChangeFullSizeFlag(!fullSizeFlag)}
+              >
+                {fullSizeFlag ? <FullscreenIcon fontSize="small" /> : <FullscreenExitIcon fontSize="small" />}
+              </IconButton>
+            </Stack>
           </Grid>
         </Grid>
-        {card === false && divider !== false && <Divider sx={{ mt: 2 }} />}
-      </MainCard>
-    );
-  }
-
-  return breadcrumbContent;
+      </Grid>
+      {card === false && divider !== false && <Divider sx={{ mt: 2 }} />}
+    </MainCard>
+  );
 };
 
 Breadcrumbs.propTypes = {
   card: PropTypes.bool,
   divider: PropTypes.bool,
-  icon: PropTypes.bool,
-  icons: PropTypes.bool,
   maxItems: PropTypes.number,
-  navigation: PropTypes.object,
   rightAlign: PropTypes.bool,
   separator: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
   title: PropTypes.bool,
diff -urN ..\hss-frontend\src\/components/@extended/IconButton.jsx .\src\/components/@extended/IconButton.jsx
--- ..\hss-frontend\src\/components/@extended/IconButton.jsx	2024-10-18 16:27:14.020255400 +0900
+++ .\src\/components/@extended/IconButton.jsx	2025-03-05 17:03:24.502901700 +0900
@@ -1,9 +1,11 @@
+'use client';
+
 import PropTypes from 'prop-types';
 import { forwardRef } from 'react';
 
 // material-ui
 import MuiIconButton from '@mui/material/IconButton';
-import { styled, useTheme } from '@mui/material/styles';
+import { styled } from '@mui/material/styles';
 
 // project imports
 import getColors from '@modules/utils/getColors';
@@ -19,16 +21,9 @@
   const shadows = getShadow(theme, buttonShadow);
 
   const commonShadow = {
-    '&::after': {
-      // boxShadow: `0 0 6px 6px ${alpha(main, 0.9)}`,
-    },
-    '&:active::after': {
-      // boxShadow: `0 0 0 0 ${alpha(main, 0.9)}`,
-    },
-    '&:focus-visible': {
-      // outline: `2px solid ${dark}`,
-      // outlineOffset: 2,
-    },
+    '&::after': {},
+    '&:active::after': {},
+    '&:focus-visible': {},
   };
 
   switch (variant) {
@@ -141,22 +136,12 @@
 
 const IconButton = forwardRef(
   ({ variant = 'text', shape = 'square', children, color = 'primary', ...others }, ref) => {
-    const theme = useTheme();
-
     return (
-      <IconButtonStyle
-        ref={ref}
-        disableRipple
-        variant={variant}
-        shape={shape}
-        theme={theme}
-        color={color}
-        {...others}
-      >
+      <IconButtonStyle ref={ref} disableRipple variant={variant} shape={shape} color={color} {...others}>
         {children}
       </IconButtonStyle>
     );
-  },
+  }
 );
 
 IconButton.propTypes = {
diff -urN ..\hss-frontend\src\/components/hss/common/accountManage/account/index.jsx .\src\/components/hss/common/accountManage/account/index.jsx
--- ..\hss-frontend\src\/components/hss/common/accountManage/account/index.jsx	2025-02-19 14:50:03.767809300 +0900
+++ .\src\/components/hss/common/accountManage/account/index.jsx	2025-03-10 17:24:23.952846700 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect } from 'react';
+import { useCallback, useEffect, useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -55,8 +55,9 @@
 
   const getAccountList = async (param) => {
     const { totalElements, content } = await apiCall(accountApi.getAccountList, param);
-
-    dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    if (content) {
+      dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    }
   };
 
   const handleDeleteButtonClick = async () => {
@@ -94,18 +95,30 @@
     }
   }, []);
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
+
   useEffect(() => {
-    init();
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current) {
+      return;
+    }
 
+    init();
+    getAccountList(parameterData.parameters.current);
     return () => {
       source.cancel();
     };
-  }, []);
-
+  }, [size, page]);
+/*
   useEffect(() => {
     getAccountList(parameterData.parameters.current);
   }, [size, page]);
-
+*/
   return (
     <GridItem spacing={2} container direction="column">
       <AccountSearchForm />
diff -urN ..\hss-frontend\src\/components/hss/common/accountManage/accountGroup/index.jsx .\src\/components/hss/common/accountManage/accountGroup/index.jsx
--- ..\hss-frontend\src\/components/hss/common/accountManage/accountGroup/index.jsx	2025-02-19 14:50:03.771808200 +0900
+++ .\src\/components/hss/common/accountManage/accountGroup/index.jsx	2025-03-08 17:14:38.413285000 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect, useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -50,8 +50,9 @@
 
   const getAccountGroupList = async (param) => {
     const { totalElements, content } = await apiCall(accountGroupApi.getAccountGroupList, param);
-
-    dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    if (content) {
+      dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    }
   };
 
   const handleDeleteButtonClick = async () => {
@@ -77,19 +78,30 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current) {
+      return;
+    }
+
     init();
 
+    getAccountGroupList(parameterData.parameters.current);
     return () => {
       source.cancel();
     };
-  }, []);
-
+  }, [size, page]);
+/*
   useEffect(() => {
     getAccountGroupList(parameterData.parameters.current);
   }, [size, page]);
-
+*/
   return (
     <GridItem spacing={2} container direction="column">
       <AccountGroupSearchForm />
diff -urN ..\hss-frontend\src\/components/hss/common/dashboardManage/networkTrafficChart.js .\src\/components/hss/common/dashboardManage/networkTrafficChart.js
--- ..\hss-frontend\src\/components/hss/common/dashboardManage/networkTrafficChart.js	2025-02-19 14:50:03.772811900 +0900
+++ .\src\/components/hss/common/dashboardManage/networkTrafficChart.js	2025-03-07 11:58:52.859851300 +0900
@@ -7,62 +7,69 @@
 function NetworkTrafficChart() {
   const eventSource = useRef(null);
   const { data: session } = useSession();
-
+  
   const [chartData, setChartData] = useState([]);
   const [hasReceivedData, setHasReceivedData] = useState(false);
-
+  
   const onOpen = () => {};
   const onMessage = (event) => {
-    const { attribute } = JSON.parse(event);
-    const { server_info: serverInfo } = attribute;
-    const { data, labels } = serverInfo[0];
-
-    const timeIdx = labels.indexOf('time');
-    const receivedIdx = labels.indexOf('received');
-    const sentIdx = labels.indexOf('sent');
-
-    const receivedData = data.map((d) => ({
-      date: new Date(d[String(timeIdx)] * 1000).toISOString(),
-      received: d[String(receivedIdx)],
-      sent: d[String(sentIdx)],
-    }));
+    try {
+      const { attribute } = JSON.parse(event);
+      const { server_info: serverInfo } = attribute;
+      const { data, labels } = serverInfo[0];
+
+      const timeIdx = labels.indexOf('time');
+      const receivedIdx = labels.indexOf('received');
+      const sentIdx = labels.indexOf('sent');
+
+      const receivedData = data.map((d) => ({
+        date: new Date(d[String(timeIdx)] * 1000).toISOString(),
+        received: d[String(receivedIdx)],
+        sent: d[String(sentIdx)],
+      }));
 
-    setChartData(receivedData);
+      setChartData(receivedData);
 
-    if (!hasReceivedData) {
-      setHasReceivedData(true);
+      if (!hasReceivedData) {
+        setHasReceivedData(true);
+      }
+    } catch (error) {
+      console.error("### NetworkTrafficChart.js ### ERROR in onMessage:", error);
     }
   };
+
   const onError = (error) => {
-    if (error.status !== 200) {
-      //
-    }
+    console.error("### NetworkTrafficChart.js ### ERROR in onError:", error);
   };
 
   useEffect(() => {
+
     const oneWeekAgo = Math.floor(Date.now() / 1000) - 24 * 60 * 60 * 7;
     const oneWeekHourCount = 168;
-    eventSource.current = fetchSSEApi.connectToEventSource(
-      '/api/event/netdata?chart=system.net&after=' +
-        oneWeekAgo +
-        '&format=json&points=' +
-        oneWeekHourCount,
-      session?.user.hsssessionid,
-      session?.accessToken,
-      onOpen,
-      onMessage,
-      onError,
-    );
+
+    try {
+      eventSource.current = fetchSSEApi.connectToEventSource(
+        `/api/event/netdata?chart=system.net&after=${oneWeekAgo}&format=json&points=${oneWeekHourCount}`,
+        session?.user.hsssessionid,
+        session?.accessToken,
+        onOpen,
+        onMessage,
+        onError,
+      );
+    } catch (error) {
+      console.error("### NetworkTrafficChart.js ### ERROR connecting to SSE:", error);
+    }
 
     return () => {
-      if (eventSource.current !== null) {
+      if (eventSource.current) {
         fetchSSEApi.closeEventSource(eventSource.current);
+        eventSource.current = null;
       }
     };
   }, []);
 
   useEffect(() => {
-    if (hasReceivedData === true && eventSource.current !== null) {
+    if (hasReceivedData && eventSource.current) {
       fetchSSEApi.closeEventSource(eventSource.current);
       eventSource.current = null;
     }
@@ -93,7 +100,7 @@
       }}
     />
   ) : (
-    <LoadingButton loadingPosition="center" color='secondary' loading />
+    <LoadingButton loadingPosition="center" color="secondary" loading />
   );
 }
 
diff -urN ..\hss-frontend\src\/components/hss/common/dashboardManage/systemInfo.js .\src\/components/hss/common/dashboardManage/systemInfo.js
--- ..\hss-frontend\src\/components/hss/common/dashboardManage/systemInfo.js	2025-02-19 14:50:03.775808300 +0900
+++ .\src\/components/hss/common/dashboardManage/systemInfo.js	2025-03-07 12:45:35.791992700 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState, useRef } from 'react';
 import MainCard from '@components/mantis/MainCard';
 import GridItem from '@components/modules/grid/GridItem';
 import { Typography } from '@mui/material';
@@ -7,7 +7,7 @@
 
 function SystemInfo() {
   const { data: session } = useSession();
-
+  const hasFetched = useRef(false);
   const [systemInfo, setSystemInfo] = useState({
     cpu: 0,
     memory: 0,
diff -urN ..\hss-frontend\src\/components/hss/common/networkManage/interface/interfaceTable.jsx .\src\/components/hss/common/networkManage/interface/interfaceTable.jsx
--- ..\hss-frontend\src\/components/hss/common/networkManage/interface/interfaceTable.jsx	2025-02-19 14:50:03.777808600 +0900
+++ .\src\/components/hss/common/networkManage/interface/interfaceTable.jsx	2025-03-08 17:03:56.780601100 +0900
@@ -1,4 +1,4 @@
-import { useState } from 'react';
+import { useState,useMemo } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
 import { setDeleteList } from '@modules/redux/reducers/hss/common/interfaceModule';
@@ -16,16 +16,30 @@
   const [modalParams, setModalParams] = useState({ flag: '', id: '' });
   const [modalOpen, setModalOpen] = useState(false);
 
+  const makeColumns = () => {
+    if (!columns.length) {
+      return [];
+    }
+    return columns.map((column) => ({
+      ...column,
+      Cell: (props) => {
+        const original = props.row.original;
+        return reunderCodeTypeNameCell(props.value, original.name);
+      },
+    }));
+  };
+  
+/*
   const makeColumns = () =>
+  
     columns.map((column) => ({
       ...column,
       Cell: (props) => {
         const original = props.row.original;
-
         return reunderCodeTypeNameCell(props.value, original.name);
       },
     }));
-
+*/
   const handleUpdateColumnClick = (flag, id) => {
     setModalParams({ flag: flag, id: id });
     setModalOpen(true);
@@ -36,6 +50,7 @@
   };
 
   const reunderCodeTypeNameCell = (value, name) => {
+
     return (
       <Link
         sx={{
@@ -51,7 +66,7 @@
       </Link>
     );
   };
-
+  const customColumns = useMemo(() => makeColumns(), [columns]);
   return (
     <GridItem item>
       <HsReduxTable
@@ -69,7 +84,7 @@
           },
         }}
         name="interfaceModule"
-        customColumn={makeColumns()}
+        customColumn={customColumns}
         checkList={deleteList}
         onChangeChecked={handleChangeChecked}
       />
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/blackListGroupStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/blackListGroupStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/blackListGroupStatusSearchForm.jsx	2025-03-12 13:30:03.141614800 +0900
+++ .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/blackListGroupStatusSearchForm.jsx	2025-03-05 15:06:33.298921100 +0900
@@ -2,13 +2,7 @@
 import SearchInput from '@components/modules/input/SearchInput';
 import GridItem from '@components/modules/grid/GridItem';
 import LabelInput from '@components/modules/input/LabelInput';
-import {
-  setParameters,
-  setSearchOpenFlag,
-} from '@modules/redux/reducers/hss/sslswg/blackListGroupStatus';
-import { DownOutlined, UpOutlined } from '@ant-design/icons';
-import { IconButton } from '@mui/material';
-import Transitions from '@components/@extended/Transitions';
+import { setParameters } from '@modules/redux/reducers/hss/sslswg/blackListGroupStatus';
 
 function BlackListGroupStatusSearchForm() {
   const dispatch = useDispatch();
@@ -16,8 +10,6 @@
   const parameterData = useSelector((state) => state.blackListGroupStatus);
   const parameters = parameterData.parameters.current;
 
-  const searchOpenFlag = parameterData.searchOpenFlag;
-
   const handleChange = (event, validValue = null) => {
     let value = validValue === null ? event.target.value : validValue;
     if (event instanceof PointerEvent) {
@@ -27,15 +19,11 @@
     dispatch(setParameters({ [event.target.name]: value }));
   };
 
-  const handleClickSearchOpen = () => {
-    dispatch(setSearchOpenFlag(!searchOpenFlag));
-  };
-
   return (
     <SearchInput positionUnset>
       <GridItem
         container
-        divideColumn={3}
+        divideColumn={4}
         spacing={2}
         sx={{
           pr: 5,
@@ -50,6 +38,7 @@
           value={parameters.category}
           onChange={handleChange}
         />
+        <LabelInput label="내용" name="value" value={parameters.value} onChange={handleChange} />
         <LabelInput
           type="select"
           label="활성화 여부"
@@ -62,44 +51,6 @@
           onChange={handleChange}
         />
       </GridItem>
-
-      <IconButton
-        aria-label="delete"
-        size="small"
-        sx={{
-          position: 'absolute',
-          right: 10,
-          top: '30px',
-          '&:hover': {
-            bgcolor: 'transparent',
-          },
-        }}
-        onClick={handleClickSearchOpen}
-      >
-        {searchOpenFlag ? <UpOutlined fontSize="small" /> : <DownOutlined fontSize="small" />}
-      </IconButton>
-
-      <Transitions type="collapse" in={searchOpenFlag}>
-        <GridItem
-          container
-          divideColumn={3}
-          spacing={2}
-          sx={{
-            pr: 5,
-            pt: 2,
-            '& .text': { maxWidth: '110px', minWidth: '110px' },
-            '.inputBox': { maxWidth: '200px', minWidth: '200px' },
-          }}
-        >
-          <LabelInput
-            label="정책 내용"
-            name="value"
-            value={parameters.value}
-            onChange={handleChange}
-            placeholder="hanssak.co.kr"
-          />
-        </GridItem>
-      </Transitions>
     </SearchInput>
   );
 }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/index.jsx	2025-03-12 13:30:03.142652900 +0900
+++ .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListGroupStatus/index.jsx	2025-03-10 17:05:42.625429800 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -93,7 +93,18 @@
     setIsLoading(status);
   }, []);
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
+    
+    
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusSearchForm.jsx	2025-03-12 13:30:03.143170200 +0900
+++ .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusSearchForm.jsx	2025-03-05 15:06:33.300921100 +0900
@@ -34,7 +34,7 @@
         <LabelInput label="내용" name="value" value={parameters.value} onChange={handleChange} />
         <LabelInput
           type="select"
-          label="유형"
+          label="타입"
           name="type"
           value={parameters.type}
           list={[
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusTable.jsx .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusTable.jsx	2025-03-12 13:30:03.143687700 +0900
+++ .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/blackListStatusTable.jsx	2025-03-05 15:06:33.300921100 +0900
@@ -3,6 +3,7 @@
 import GridItem from '@components/modules/grid/GridItem';
 import { setCheckList } from '@modules/redux/reducers/hss/sslswg/blackListStatus';
 import { Link } from '@mui/material';
+// import BlackListStatusModal from '@components/modal/hss/sslswg/policy/blackListStatusModal';
 import HsReduxTable from '@components/modules/table/HsReduxTable';
 import BlackListReasonChoiceModal from '@components/modal/hss/sslswg/policy/blackListReasonChoiceModal';
 
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/index.jsx	2025-03-12 13:30:03.144203400 +0900
+++ .\src\/components/hss/sslswg/policy/policyDefaultManage/blackListStatus/index.jsx	2025-03-11 14:42:01.448299100 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -35,11 +35,14 @@
 
   const router = useRouter();
   const { id } = router.query;
-
+  /*
+  console.log("*ID s ********************");
+  console.log(id);
+  console.log("*ID e ********************");
+  */
   const parameterData = useSelector((state) => state.blackListStatus);
   const { size, page } = parameterData.parameters.current;
   const [isLoading, setIsLoading] = useState(false);
-  const [isInit, setIsInit] = useState(false);
 
   const [formData, setFormdata] = useState({
     name: '',
@@ -48,22 +51,20 @@
   });
 
   const init = async () => {
-    resetState();
-
+    console.log("*ID s ********************");
+    console.log(id);
+    console.log("*ID e ********************");
     const gridInfo = await HsLib.getGridInfo('BlackListStatusList', blackListStatusApi);
     const result = await apiCall(blackListGroupStatusApi.getBlackListGroupStatusDetails, id);
-
     unstable_batchedUpdates(() => {
       dispatch(setParameters({ id: id }));
       responseGridInfo(gridInfo);
-
       if (result) {
         setFormdata({
           name: result.name || '', // 값이 없으면 빈 문자열로 처리
           category: result.category || '',
           enabled: result.enabled ?? 1, // undefined일 경우 기본값 1
         });
-        setIsInit(true);
       }
     });
   };
@@ -79,15 +80,17 @@
   };
 
   const getBlackListStatusList = async (param) => {
-    if (!isInit) return;
     if (!param?.id || param.id === '') return;
 
+    console.log("*ID s ********************");
+    console.log(param.id);
+    console.log("*ID e ********************");
     getLoadingStatus(true);
     const { totalElements, content } = await apiCall(
       blackListStatusApi.getBlackListStatusList,
       param,
     );
-
+//    console.table(content);
     dispatch(setPageDataList({ pageDataList: content, totalElements }));
     getLoadingStatus(false);
   };
@@ -140,19 +143,31 @@
     });
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
-    init();
-  }, [id]);
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed.current) return;
 
-  useEffect(() => {
     return () => {
+      resetState();
       source.cancel();
     };
   }, []);
 
   useEffect(() => {
+    //if (!isSecondCallAllowed.current) return;
+    init();
+  }, [id]);
+
+  useEffect(() => {
+    //if (!isSecondCallAllowed.current) return;
     getBlackListStatusList(parameterData.parameters.current);
-  }, [isInit, size, page]);
+  }, [size, page]);
 
   return (
     <GridItem spacing={2} container direction="column">
@@ -180,7 +195,6 @@
               labelBackgroundFlag
             />
             <LabelInput
-              required
               label="카테고리"
               name="category"
               value={formData.category}
@@ -188,7 +202,6 @@
               labelBackgroundFlag
             />
             <LabelInput
-              required
               type="select"
               label="활성화 여부"
               name="enabled"
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/index.jsx	2025-03-12 13:30:03.144721400 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/index.jsx	2025-03-10 14:27:21.378577000 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -80,8 +80,17 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusSearchForm.jsx	2025-03-14 18:07:35.815738800 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusSearchForm.jsx	2025-03-05 15:06:33.303921300 +0900
@@ -38,9 +38,9 @@
           name="type"
           value={parameters.type || ''}
           list={[
-            { label: 'HEADER', value: 'regexpheader' },
-            { label: 'PAYLOAD', value: 'regexppayload' },
-            { label: 'URL', value: 'regexpurl' },
+            { label: 'HEADER', value: 'regexheader' },
+            { label: 'PAYLOAD', value: 'regexpayload' },
+            { label: 'URL', value: 'regexurl' },
           ]}
           onChange={handleChange}
         />
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusTable.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusTable.jsx	2025-03-14 18:07:35.816738700 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/patternGroupStatusTable.jsx	2025-03-05 15:06:33.303921300 +0900
@@ -31,9 +31,9 @@
             return <>{value === 1 ? '허용' : '차단'}</>;
           case 'type': {
             const typeMap = new Map([
-              ['regexpheader', 'HEADER'],
-              ['regexppayload', 'PAYLOAD'],
-              ['regexpurl', 'URL'],
+              ['regexheader', 'HEADER'],
+              ['regexpayload', 'PAYLOAD'],
+              ['regexurl', 'URL'],
             ]);
 
             return <>{typeMap.has(value) ? typeMap.get(value) : 'unknown'}</>;
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/update/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/update/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/update/index.jsx	2025-03-14 18:07:35.817738500 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternGroupStatus/update/index.jsx	2025-03-10 14:36:53.250005400 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -106,8 +106,17 @@
       dispatch(setDeleteList([]));
     });
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
   }, [id]);
 
@@ -141,7 +150,7 @@
           >
             <LabelInput
               required
-              label="그룹명"
+              label="정책명"
               name="name"
               value={formData.name}
               disabled
@@ -152,9 +161,9 @@
               label="유형"
               name="type"
               list={[
-                { label: 'HEADER', value: 'regexpheader' },
-                { label: 'PAYLOAD', value: 'regexppayload' },
-                { label: 'URL', value: 'regexpurl' },
+                { label: 'HEADER', value: 'regexheader' },
+                { label: 'PAYLOAD', value: 'regexpayload' },
+                { label: 'URL', value: 'regexurl' },
               ]}
               value={formData.type}
               disabled
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/index.jsx	2025-03-12 13:30:03.148428100 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/index.jsx	2025-03-10 14:27:13.834668200 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -78,7 +78,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusSearchForm.jsx	2025-03-14 18:07:35.818747200 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusSearchForm.jsx	2025-03-05 15:06:33.307921500 +0900
@@ -38,9 +38,9 @@
           name="type"
           value={parameters.type || ''}
           list={[
-            { label: 'HEADER', value: 'regexpheader' },
-            { label: 'PAYLOAD', value: 'regexppayload' },
-            { label: 'URL', value: 'regexpurl' },
+            { label: 'HEADER', value: 'regexheader' },
+            { label: 'PAYLOAD', value: 'regexpayload' },
+            { label: 'URL', value: 'regexurl' },
           ]}
           onChange={handleChange}
         />
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusTable.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusTable.jsx	2025-03-14 18:07:35.819738600 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/patternStatus/patternStatusTable.jsx	2025-03-05 15:06:33.307921500 +0900
@@ -30,9 +30,9 @@
             return <>{value === 1 ? '허용' : '차단'}</>;
           case 'type': {
             const typeMap = new Map([
-              ['regexpheader', 'HEADER'],
-              ['regexppayload', 'PAYLOAD'],
-              ['regexpurl', 'URL'],
+              ['regexheader', 'HEADER'],
+              ['regexpayload', 'PAYLOAD'],
+              ['regexurl', 'URL'],
             ]);
 
             return <>{typeMap.has(value) ? typeMap.get(value) : 'unknown'}</>;
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/index.jsx	2025-03-12 13:30:03.150491600 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/index.jsx	2025-03-10 14:27:05.088904400 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -81,7 +81,17 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusSearchForm.jsx	2025-03-12 13:30:03.151020600 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusSearchForm.jsx	2025-03-05 15:06:33.310958300 +0900
@@ -38,8 +38,8 @@
           name="type"
           value={parameters.type || ''}
           list={[
-            { label: '도메인', value: 'site' },
-            { label: 'URL', value: 'url' },
+            { label: '전체 도메인', value: 'site' },
+            { label: '특정 URL', value: 'url' },
           ]}
           onChange={handleChange}
         />
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusTable.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusTable.jsx	2025-03-12 13:30:03.152057000 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/siteGroupStatusTable.jsx	2025-03-05 15:06:33.310958300 +0900
@@ -30,7 +30,7 @@
           case 'action':
             return <>{value === 1 ? '허용' : '차단'}</>;
           case 'type':
-            return <>{value === 'site' ? '도메인' : 'URL'}</>;
+            return <>{value === 'site' ? '전체 도메인' : '특정 URL'}</>;
           default:
             return <>{value}</>;
         }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/update/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/update/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/update/index.jsx	2025-03-12 13:30:03.152574600 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteGroupStatus/update/index.jsx	2025-03-10 14:36:45.611995300 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -106,8 +106,17 @@
       dispatch(setDeleteList([]));
     });
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
   }, [id]);
 
@@ -141,7 +150,7 @@
           >
             <LabelInput
               required
-              label="그룹명"
+              label="정책명"
               name="name"
               value={formData.name}
               disabled
@@ -152,8 +161,8 @@
               label="유형"
               name="type"
               list={[
-                { label: '도메인', value: 'site' },
-                { label: 'URL', value: 'url' },
+                { label: '전체 도메인', value: 'site' },
+                { label: '특정 URL', value: 'url' },
               ]}
               value={formData.type}
               disabled
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/index.jsx	2025-03-12 13:30:03.154657300 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/index.jsx	2025-03-10 14:26:58.851163800 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -78,7 +78,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusSearchForm.jsx	2025-03-12 13:30:03.155174100 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusSearchForm.jsx	2025-03-05 15:06:33.313965200 +0900
@@ -38,8 +38,8 @@
           name="type"
           value={parameters.type || ''}
           list={[
-            { label: '도메인', value: 'site' },
-            { label: 'URL', value: 'url' },
+            { label: '전체 도메인', value: 'site' },
+            { label: '특정 URL', value: 'url' },
           ]}
           onChange={handleChange}
         />
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusTable.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusTable.jsx	2025-03-12 13:30:03.155690400 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/siteStatus/siteStatusTable.jsx	2025-03-05 15:06:33.314965100 +0900
@@ -29,7 +29,7 @@
           case 'action':
             return <>{value === 1 ? '허용' : '차단'}</>;
           case 'type':
-            return <>{value === 'site' ? '도메인' : 'URL'}</>;
+            return <>{value === 'site' ? '전체 도메인' : '특정 URL'}</>;
           default:
             return <>{value}</>;
         }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/index.jsx	2025-03-12 13:30:03.157472200 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/index.jsx	2025-03-10 14:26:51.853327800 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -81,7 +81,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/update/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/update/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/update/index.jsx	2025-03-12 13:30:03.160081500 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpGroupStatus/update/index.jsx	2025-03-10 14:36:38.635094900 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -106,8 +106,17 @@
       dispatch(setDeleteList([]));
     });
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
   }, [id]);
 
@@ -141,7 +150,7 @@
           >
             <LabelInput
               required
-              label="그룹명"
+              label="정책명"
               name="name"
               value={formData.name}
               disabled
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/srcIpStatus/index.jsx	2025-03-12 13:30:03.162763400 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/srcIpStatus/index.jsx	2025-03-10 14:26:46.706973600 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -78,7 +78,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/index.jsx	2025-03-12 13:30:03.166430300 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/index.jsx	2025-03-10 14:26:41.276994700 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -81,7 +81,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/timeGroupStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/timeGroupStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/timeGroupStatusSearchForm.jsx	2025-03-12 13:30:03.167971900 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/timeGroupStatusSearchForm.jsx	2025-03-05 15:06:33.323965500 +0900
@@ -23,7 +23,7 @@
     <SearchInput positionUnset>
       <GridItem
         container
-        divideColumn={1}
+        divideColumn={2}
         spacing={2}
         sx={{
           pr: 5,
@@ -32,6 +32,17 @@
         }}
       >
         <LabelInput label="그룹명" name="name" value={parameters.name} onChange={handleChange} />
+        <LabelInput
+          type="select"
+          label="처리 방식"
+          name="action"
+          value={parameters.action || ''}
+          list={[
+            { label: '차단', value: '0' },
+            { label: '허용', value: '1' },
+          ]}
+          onChange={handleChange}
+        />
       </GridItem>
     </SearchInput>
   );
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/update/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/update/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/update/index.jsx	2025-03-12 13:30:03.168999300 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/timeGroupStatus/update/index.jsx	2025-03-10 17:00:01.874209900 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -40,6 +40,7 @@
 
   const [formData, setFormdata] = useState({
     name: '',
+    action: '',
   });
 
   const init = async () => {
@@ -53,6 +54,7 @@
       if (result) {
         setFormdata({
           name: result.name,
+          action: result.action,
         });
       }
     });
@@ -102,12 +104,22 @@
       dispatch(setDeleteList([]));
     });
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     init();
   }, [id]);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;
     return () => {
       resetState();
       source.cancel();
@@ -115,6 +127,7 @@
   }, []);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;
     getTimeGroupUpdateStatusList(parameterData.parameters.current);
   }, [size, page]);
 
@@ -123,11 +136,11 @@
       {isLoading && <Loader isGuard />}
       <GridItem item>
         <Stack spacing={2}>
-          <Typography variant="title2">스케줄 그룹 정책 수정</Typography>
+          <Typography variant="title2">패턴 그룹 정책 수정</Typography>
           <GridItem
             item
             directionHorizon="end"
-            divideColumn={1}
+            divideColumn={2}
             borderFlag
             sx={{
               '& .text': { maxWidth: '180px !important', minWidth: '180px !important' },
@@ -137,12 +150,24 @@
           >
             <LabelInput
               required
-              label="그룹명"
+              label="정책명"
               name="name"
               value={formData.name}
               disabled
               labelBackgroundFlag
             />
+            <LabelInput
+              type="select"
+              label="처리 방식"
+              name="action"
+              list={[
+                { label: '차단', value: '0' },
+                { label: '허용', value: '1' },
+              ]}
+              value={formData.action}
+              disabled
+              labelBackgroundFlag
+            />
           </GridItem>
         </Stack>
       </GridItem>
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/index.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/index.jsx	2025-03-12 13:30:03.171145400 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/index.jsx	2025-03-10 14:26:35.804503800 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -78,7 +78,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/timeStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/timeStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/timeStatusSearchForm.jsx	2025-03-12 13:30:03.172688900 +0900
+++ .\src\/components/hss/sslswg/policy/policyDetailManage/timeStatus/timeStatusSearchForm.jsx	2025-03-05 15:06:33.327965600 +0900
@@ -47,7 +47,7 @@
     <SearchInput positionUnset>
       <GridItem
         container
-        divideColumn={1}
+        divideColumn={2}
         spacing={2}
         sx={{
           pr: 5,
@@ -56,6 +56,17 @@
         }}
       >
         <LabelInput label="정책명" name="name" value={parameters.name} onChange={handleChange} />
+        <LabelInput
+          type="select"
+          label="처리 방식"
+          name="action"
+          value={parameters.action || ''}
+          list={[
+            { label: '차단', value: '0' },
+            { label: '허용', value: '1' },
+          ]}
+          onChange={handleChange}
+        />
         {/* <LabelInput
           type="checkbox"
           label="적용 요일"
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/index.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/index.jsx	2025-03-12 13:30:03.175292300 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/index.jsx	2025-03-11 09:58:27.157970400 +0900
@@ -1,35 +1,34 @@
-import { useEffect } from 'react';
+import { useState, useEffect, useCallback,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
+
 import { AuthInstance } from '@modules/axios';
 import {
   setColumns,
+  setDeleteList,
   setListInfo,
-  setParameters,
   setPageDataList,
-  setDeleteList,
+  setParameters,
   setSegmentNameList,
-  setTimeNameList,
 } from '@modules/redux/reducers/hss/sslswg/policyGroupStatus';
 import useApi from '@modules/hooks/useApi';
 
-import segmentStatusApi from '@api/hss/sslva/policy/segmentStatusApi';
 import policyGroupStatusApi from '@api/hss/sslswg/policy/policyGroupStatusApi';
+import policyDetailStatusApi from '@api/hss/sslswg/policy/policyDetailStatusApi';
+import segmentStatusApi from '@api/hss/sslva/policy/segmentStatusApi';
+
 import PolicyGroupStatusSearchForm from './policyGroupStatusSearchForm';
 import PolicyGroupStatusActionButton from './policyGroupStatusActionButton';
 import PolicyGroupStatusTable from './policyGroupStatusTable';
 import HsLib from '@modules/common/HsLib';
-import timeStatusApi from '@api/hss/sslswg/policy/policyDetailManage/timeStatusApi';
-import timeGroupStatusApi from '@api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi';
 
 function PolicyGroupStatus() {
   const { instance, source } = AuthInstance();
 
   policyGroupStatusApi.axios = instance;
+  policyDetailStatusApi.axios = instance;
   segmentStatusApi.axios = instance;
-  timeStatusApi.axios = instance;
-  timeGroupStatusApi.axios = instance;
 
   const [apiCall, openModal] = useApi();
 
@@ -37,39 +36,14 @@
 
   const parameterData = useSelector((state) => state.swgPolicyGroupStatus);
   const { size, page } = parameterData.parameters.current;
+  const [policyDetailGroupList, setPolicyDetailGroupList] = useState([]);
+  const [policyDetailList, setPolicyDetailList] = useState([]);
 
   const init = async () => {
     const gridInfo = await HsLib.getGridInfo('SWGPolicyGroupStatusList', policyGroupStatusApi);
-    const segmentData = await apiCall(segmentStatusApi.getSegmentStatusColumnList, 'name');
-
-    const singleListResult = await apiCall(timeStatusApi.getTimeStatusList, { contentOnly: true });
-    const groupListResult = await apiCall(timeGroupStatusApi.getTimeGroupStatusList, {
-      contentOnly: true,
-    });
 
     unstable_batchedUpdates(() => {
       responseGridInfo(gridInfo);
-
-      if (Array.isArray(segmentData)) {
-        const list = segmentData.map((item) => ({
-          value: item,
-          label: item,
-        }));
-        dispatch(setSegmentNameList(list));
-      }
-      if (Array.isArray(singleListResult) || Array.isArray(groupListResult)) {
-        const singleList = (Array.isArray(singleListResult) ? singleListResult : []).map(
-          (item) => ({
-            value: item.id,
-            label: `${item.name}`,
-          }),
-        );
-        const groupList = (Array.isArray(groupListResult) ? groupListResult : []).map((item) => ({
-          value: item.id,
-          label: `${item.name} (G)`,
-        }));
-        dispatch(setTimeNameList([...groupList, ...singleList]));
-      }
     });
   };
 
@@ -92,6 +66,28 @@
     dispatch(setPageDataList({ pageDataList: content, totalElements }));
   };
 
+  const getDetailList = async () => {
+    const result = await apiCall(policyDetailStatusApi.getPolicyDetailStatusList, {
+      contentOnly: true,
+    });
+    if (result) {
+      const { policyGroupList, policyList } = result;
+      setPolicyDetailGroupList(policyGroupList);
+      setPolicyDetailList(policyList);
+    }
+  };
+
+  const getSegmentNameList = useCallback(async () => {
+    const data = await apiCall(segmentStatusApi.getSegmentStatusColumnList, 'name');
+    if (data) {
+      const list = data.map((item) => ({
+        value: item,
+        label: item,
+      }));
+      dispatch(setSegmentNameList(list));
+    }
+  }, []);
+
   const handleDeleteButtonClick = async () => {
     if (parameterData.deleteList.length !== 0) {
       const result = await apiCall(
@@ -115,9 +111,21 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
+    
+    
     init();
+    getDetailList();
+    getSegmentNameList();
 
     return () => {
       source.cancel();
@@ -125,6 +133,7 @@
   }, []);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;
     getPolicyGroupStatusList(parameterData.parameters.current);
   }, [size, page]);
 
@@ -134,8 +143,14 @@
       <PolicyGroupStatusActionButton
         onSearchButtonClick={getPolicyGroupStatusList}
         onDeleteButtonClick={handleDeleteButtonClick}
+        policyDetailGroupList={policyDetailGroupList}
+        policyDetailList={policyDetailList}
+      />
+      <PolicyGroupStatusTable
+        getPolicyGroupStatusList={getPolicyGroupStatusList}
+        policyDetailGroupList={policyDetailGroupList}
+        policyDetailList={policyDetailList}
       />
-      <PolicyGroupStatusTable getPolicyGroupStatusList={getPolicyGroupStatusList} />
     </GridItem>
   );
 }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusActionButton.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusActionButton.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusActionButton.jsx	2025-03-12 13:30:03.175805200 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusActionButton.jsx	2025-03-05 14:20:47.406442400 +0900
@@ -1,13 +1,18 @@
+import { useState } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
 import ButtonSet from '@components/modules/button/ButtonSet';
 import { Stack } from '@mui/material';
-import { useState } from 'react';
 import PolicyGroupStatusModal from '@components/modal/hss/sslswg/policy/policyGroupStatusModal';
 import { setParameters } from '@modules/redux/reducers/hss/sslswg/policyGroupStatus';
 
 function PolicyGroupStatusActionButton(props) {
-  const { onSearchButtonClick, onDeleteButtonClick } = props;
+  const {
+    onSearchButtonClick,
+    onDeleteButtonClick,
+    policyDetailGroupList = [],
+    policyDetailList = [],
+  } = props;
 
   const dispatch = useDispatch();
 
@@ -33,7 +38,6 @@
       <GridItem item directionHorizon="end">
         <Stack direction="row" alignItems="center" spacing={1.25}>
           <ButtonSet
-            type="custom"
             options={[
               {
                 label: '조회',
@@ -60,6 +64,8 @@
           setModalOpen={setModalOpen}
           modalParams={modalParams}
           getPolicyGroupStatusList={inquiryClickButton}
+          policyDetailGroupList={policyDetailGroupList}
+          policyDetailList={policyDetailList}
         />
       )}
     </>
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusSearchForm.jsx	2025-03-14 18:07:35.820738800 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusSearchForm.jsx	2025-03-05 14:20:47.406957100 +0900
@@ -2,41 +2,38 @@
 import SearchInput from '@components/modules/input/SearchInput';
 import GridItem from '@components/modules/grid/GridItem';
 import LabelInput from '@components/modules/input/LabelInput';
-import Transitions from '@components/@extended/Transitions';
-import {
-  setParameters,
-  setSearchOpenFlag,
-} from '@modules/redux/reducers/hss/sslswg/policyGroupStatus';
-import { IconButton } from '@mui/material';
-import { DownOutlined, UpOutlined } from '@ant-design/icons';
+import { setParameters } from '@modules/redux/reducers/hss/sslswg/policyGroupStatus';
+import { useState } from 'react';
 
 function PolicyGroupStatusSearchForm() {
   const dispatch = useDispatch();
 
   const parameterData = useSelector((state) => state.swgPolicyGroupStatus);
   const parameters = parameterData.parameters.current;
-  const { segmentNameList, timeNameList } = parameterData;
+  const segmentNameList = parameterData.segmentNameList;
 
-  const searchOpenFlag = parameterData.searchOpenFlag;
+  const [selectedSegmentName, setSelectedSegmentName] = useState(parameters.segmentName);
 
-  const handleClickSearchOpen = () => {
-    dispatch(setSearchOpenFlag(!searchOpenFlag));
-  };
-
-  const handleChange = (event, validValue = null) => {
-    let value = validValue === null ? event.target.value : validValue;
-    if (event instanceof PointerEvent) {
-      value = event.target.value;
+  const handleChange = (event) => {
+    const name = event.target.name;
+    const value = event.target.value;
+
+    switch (name) {
+      case 'segmentName':
+        setSelectedSegmentName(value);
+        break;
+      default:
+        break;
     }
 
-    dispatch(setParameters({ [event.target.name]: value }));
+    dispatch(setParameters({ [name]: value }));
   };
 
   return (
-    <SearchInput positionUnset>
+    <SearchInput>
       <GridItem
         container
-        divideColumn={3}
+        divideColumn={2}
         spacing={2}
         sx={{
           pr: 5,
@@ -47,77 +44,13 @@
         <LabelInput label="그룹명" name="name" value={parameters.name} onChange={handleChange} />
         <LabelInput
           type="select"
-          label="SSL VA [세그먼트]"
+          label="세그먼트명"
           name="segmentName"
-          value={parameters.segmentName}
-          list={segmentNameList || []}
-          onChange={handleChange}
-        />
-        <LabelInput
-          label="설명"
-          name="description"
-          value={parameters.description}
+          value={selectedSegmentName}
+          list={segmentNameList}
           onChange={handleChange}
         />
       </GridItem>
-
-      <IconButton
-        aria-label="delete"
-        size="small"
-        sx={{
-          position: 'absolute',
-          right: 10,
-          top: '30px',
-          '&:hover': {
-            bgcolor: 'transparent',
-          },
-        }}
-        onClick={handleClickSearchOpen}
-      >
-        {searchOpenFlag ? <UpOutlined fontSize="small" /> : <DownOutlined fontSize="small" />}
-      </IconButton>
-
-      <Transitions type="collapse" in={searchOpenFlag}>
-        <GridItem
-          container
-          divideColumn={3}
-          spacing={2}
-          sx={{
-            pr: 5,
-            pt: 2,
-            '& .text': { maxWidth: '130px', minWidth: '130px' },
-            '.inputBox': { maxWidth: '180px', minWidth: '180px' },
-          }}
-        >
-          <LabelInput
-            type="select"
-            label="스케줄 정책"
-            name="timeId"
-            value={parameters?.timeId || ''}
-            list={timeNameList || []}
-            onChange={handleChange}
-          />
-          <LabelInput
-            type="select"
-            label="블랙리스트 정책"
-            name="isBlackList"
-            value={parameters?.isBlackList || ''}
-            list={[{ label: '적용', value: '1' }]}
-            onChange={handleChange}
-          />
-          <LabelInput
-            type="select"
-            label="처리 방식"
-            name="action"
-            value={parameters?.action || ''}
-            list={[
-              { label: '차단', value: '0' },
-              { label: '허용', value: '1' },
-            ]}
-            onChange={handleChange}
-          />
-        </GridItem>
-      </Transitions>
     </SearchInput>
   );
 }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusTable.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusTable.jsx	2025-03-14 18:07:35.821738600 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/policyGroupStatusTable.jsx	2025-03-05 14:20:47.407472700 +0900
@@ -1,15 +1,20 @@
+import { useState } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
 import { setDeleteList } from '@modules/redux/reducers/hss/sslswg/policyGroupStatus';
 import { Link } from '@mui/material';
+import PolicyGroupStatusModal from '@components/modal/hss/sslswg/policy/policyGroupStatusModal';
 import HsReduxTable from '@components/modules/table/HsReduxTable';
-import { useRouter } from 'next/router';
 
-function PolicyGroupStatusTable() {
-  const { columns, deleteList, timeNameList } = useSelector((state) => state.swgPolicyGroupStatus);
+function PolicyGroupStatusTable(props) {
+  const { getPolicyGroupStatusList, policyDetailGroupList = [], policyDetailList = [] } = props;
+
+  const { columns, deleteList } = useSelector((state) => state.swgPolicyGroupStatus);
 
   const dispatch = useDispatch();
-  const router = useRouter();
+
+  const [modalParams, setModalParams] = useState({ flag: '', id: '' });
+  const [modalOpen, setModalOpen] = useState(false);
 
   const makeColumns = () =>
     columns.map((column) => ({
@@ -17,37 +22,15 @@
       Cell: (props) => {
         const original = props.row.original;
         const value = props.value;
-
-        switch (column.accessor) {
-          case 'name':
-            return reunderCodeTypeNameCell(value, original.id);
-          case 'timeId': {
-            const getLabelById = (id, timeNameList) => {
-              const foundItem = timeNameList?.find((item) => item.value === id);
-              return foundItem ? foundItem.label : '-';
-            };
-            const label = getLabelById(value, timeNameList);
-            return <>{label}</>;
-          }
-          case 'isBlackList':
-            return <>{value === 1 ? '적용' : '-'}</>;
-          case 'action':
-            return <>{value === 1 ? '허용' : '차단'}</>;
-          default:
-            return <>{value}</>;
-        }
+        // const key = column.accessor;
+        return reunderCodeTypeNameCell(value, original.id);
       },
     }));
 
-  const handleUpdateColumnClick = (id) => {
-    router.push({
-      pathname: `/hss/sslswgManage/policyGroupManage/update`,
-      query: {
-        id,
-      },
-    });
+  const handleUpdateColumnClick = (flag, id) => {
+    setModalParams({ flag: flag, id: id });
+    setModalOpen(true);
   };
-
   const handleChangeChecked = (value) => {
     dispatch(setDeleteList(value));
   };
@@ -61,7 +44,7 @@
           height: 1,
           width: 1,
         }}
-        onClick={() => handleUpdateColumnClick(id)}
+        onClick={() => handleUpdateColumnClick('update', id)}
       >
         {value}
       </Link>
@@ -78,10 +61,12 @@
           },
           '.CMM-rt-tableArea-reactRow': {
             cursor: 'pointer',
+            height: 'unset', // 높이 자동 조절!
           },
           '.CMM-rt-rowArea-tableCell div p': {
             fontSize: '13px',
             verticalAlign: 'middle',
+            lineHeight: '35px',
           },
         }}
         name="swgPolicyGroupStatus"
@@ -89,6 +74,16 @@
         checkList={deleteList}
         onChangeChecked={handleChangeChecked}
       />
+      {modalOpen && (
+        <PolicyGroupStatusModal
+          getPolicyGroupStatusList={getPolicyGroupStatusList}
+          alertOpen={modalOpen}
+          setModalOpen={setModalOpen}
+          modalParams={modalParams}
+          policyDetailGroupList={policyDetailGroupList}
+          policyDetailList={policyDetailList}
+        />
+      )}
     </GridItem>
   );
 }
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/index.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/update/index.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/index.jsx	2025-03-14 18:07:35.822738800 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/update/index.jsx	1970-01-01 09:00:00.000000000 +0900
@@ -1,219 +0,0 @@
-import { useCallback, useEffect, useState } from 'react';
-import { unstable_batchedUpdates } from 'react-dom';
-import { useDispatch, useSelector } from 'react-redux';
-import GridItem from '@components/modules/grid/GridItem';
-import { AuthInstance } from '@modules/axios';
-import {
-  setColumns,
-  setListInfo,
-  setParameters,
-  setPageDataList,
-  setDeleteList,
-} from '@modules/redux/reducers/hss/sslswg/policyGroupUpdateStatus';
-import useApi from '@modules/hooks/useApi';
-
-import policyGroupStatusApi from '@api/hss/sslswg/policy/policyGroupStatusApi';
-import PolicyGroupUpdateStatusSearchForm from './policyGroupUpdateStatusSearchForm';
-import PolicyGroupUpdateStatusActionButton from './policyGroupUpdateStatusActionButton';
-import PolicyGroupUpdateStatusTable from './policyGroupUpdateStatusTable';
-import HsLib from '@modules/common/HsLib';
-import { useRouter } from 'next/router';
-import Loader from '@components/mantis/Loader';
-import LabelInput from '@components/modules/input/LabelInput';
-import { Stack, Typography } from '@mui/material';
-
-function PolicyGroupUpdateStatus() {
-  const { instance, source } = AuthInstance();
-
-  policyGroupStatusApi.axios = instance;
-
-  const [apiCall] = useApi();
-
-  const dispatch = useDispatch();
-
-  const router = useRouter();
-  const { id } = router.query;
-
-  const parameterData = useSelector((state) => state.swgPolicyGroupUpdateStatus);
-  const { size, page } = parameterData.parameters.current;
-  const { segmentNameList, timeNameList } = useSelector((state) => state.swgPolicyGroupStatus);
-  const [isLoading, setIsLoading] = useState(false);
-  const [isInit, setIsInit] = useState(false);
-
-  const [formData, setFormdata] = useState({
-    name: '',
-    segmentName: '',
-    timeId: '',
-    isBlackList: '',
-    action: '',
-    description: '',
-  });
-
-  const init = async () => {
-    resetState();
-
-    const gridInfo = await HsLib.getGridInfo(
-      'SWGPolicyGroupUpdateStatusList',
-      policyGroupStatusApi,
-    );
-    const result = await apiCall(policyGroupStatusApi.getPolicyGroupStatusDetails, id);
-
-    unstable_batchedUpdates(() => {
-      dispatch(setParameters({ id: id }));
-      responseGridInfo(gridInfo);
-      if (result) {
-        setFormdata({
-          name: result.name ?? '',
-          segmentName: result.segmentName ?? '',
-          timeId: result.timeId ?? '',
-          isBlackList: result.isBlackList === 1 ? String(result.isBlackList) : '',
-          action: String(result.action ?? ''),
-          description: result.description ?? '',
-        });
-        setIsInit(true);
-      }
-    });
-  };
-
-  const responseGridInfo = (p_gridInfo) => {
-    dispatch(setColumns(p_gridInfo.columns));
-    dispatch(setListInfo(p_gridInfo.listInfo));
-    dispatch(
-      setParameters({
-        size: Number(p_gridInfo.listInfo.size),
-      }),
-    );
-  };
-
-  const getPolicyGroupUpdateStatusList = async (param = {}) => {
-    if (!isInit) return;
-    if (!param?.id || param.id === '') return;
-    getLoadingStatus(true);
-    const { totalElements, content } = await apiCall(
-      policyGroupStatusApi.getMappingListAllWithPolicyGroupId,
-      param,
-    );
-    dispatch(setPageDataList({ pageDataList: content, totalElements }));
-    getLoadingStatus(false);
-  };
-
-  const getLoadingStatus = useCallback((status) => {
-    setIsLoading(status);
-  }, []);
-
-  const resetState = () => {
-    unstable_batchedUpdates(() => {
-      dispatch(
-        setParameters({
-          id: '',
-          name: '',
-          type: '',
-          level: '',
-          size: 10,
-          page: 0,
-        }),
-      );
-      dispatch(setPageDataList({ pageDataList: [], totalElements: 0 }));
-      dispatch(setDeleteList([]));
-    });
-  };
-
-  useEffect(() => {
-    init();
-  }, [id]);
-
-  useEffect(() => {
-    return () => {
-      source.cancel();
-    };
-  }, []);
-
-  useEffect(() => {
-    getPolicyGroupUpdateStatusList(parameterData.parameters.current);
-  }, [isInit, size, page]);
-
-  return (
-    <GridItem spacing={2} container direction="column">
-      {isLoading && <Loader isGuard />}
-      <GridItem item>
-        <Stack spacing={2}>
-          <Typography variant="title2">정책 그룹 수정</Typography>
-          <GridItem
-            item
-            directionHorizon="end"
-            divideColumn={3}
-            borderFlag
-            sx={{
-              '& .text': { maxWidth: '150px', minWidth: '150px' },
-              '.inputBox': { maxWidth: '200px', minWidth: '200px' },
-              // mb: 2,
-            }}
-          >
-            <LabelInput
-              required
-              label="그룹명"
-              name="name"
-              value={formData?.name}
-              disabled
-              labelBackgroundFlag
-            />
-            <LabelInput
-              required
-              type="select"
-              label="SSL VA<br/>[세그먼트]"
-              name="segmentName"
-              value={formData?.segmentName}
-              list={segmentNameList || []}
-              labelSx={{ textAlign: 'right' }}
-              disabled
-              labelBackgroundFlag
-            />
-            <LabelInput
-              required
-              type="select"
-              label="처리 방식"
-              name="action"
-              value={formData?.action || ''}
-              list={[
-                { label: '차단', value: '0' },
-                { label: '허용', value: '1' },
-              ]}
-              disabled
-              labelBackgroundFlag
-            />
-            <LabelInput
-              type="select"
-              label="스케줄 정책"
-              name="timeId"
-              value={formData?.timeId || ''}
-              list={timeNameList ?? []}
-              disabled
-              labelBackgroundFlag
-            />
-            <LabelInput
-              type="select"
-              label="블랙리스트 정책"
-              name="isBlackList"
-              value={formData?.isBlackList || ''}
-              list={[{ label: '적용', value: '1' }]}
-              disabled
-              labelBackgroundFlag
-            />
-            <LabelInput
-              label="설명"
-              name="description"
-              value={formData?.description}
-              disabled
-              labelBackgroundFlag
-            />
-          </GridItem>
-        </Stack>
-      </GridItem>
-      <PolicyGroupUpdateStatusSearchForm />
-      <PolicyGroupUpdateStatusActionButton onSearchButtonClick={getPolicyGroupUpdateStatusList} />
-      <PolicyGroupUpdateStatusTable />
-    </GridItem>
-  );
-}
-
-export default PolicyGroupUpdateStatus;
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusActionButton.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusActionButton.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusActionButton.jsx	2025-03-12 13:30:03.178378600 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusActionButton.jsx	1970-01-01 09:00:00.000000000 +0900
@@ -1,95 +0,0 @@
-import { useDispatch, useSelector } from 'react-redux';
-import GridItem from '@components/modules/grid/GridItem';
-import ButtonSet from '@components/modules/button/ButtonSet';
-import { setParameters } from '@modules/redux/reducers/hss/sslswg/policyGroupUpdateStatus';
-import { useRouter } from 'next/router';
-import { useState } from 'react';
-import PolicyDetailUpdateStatusModal from '@components/modal/hss/sslswg/policy/policyDetailUpdateStatusModal';
-
-function PolicyGroupUpdateStatusActionButton(props) {
-  const { onSearchButtonClick } = props;
-
-  const dispatch = useDispatch();
-  const router = useRouter();
-
-  const parameterData = useSelector((state) => state.swgPolicyGroupUpdateStatus);
-  const parameters = parameterData.parameters.current;
-
-  const [modalOpen, setModalOpen] = useState(false);
-  const [modalParams, setModalParams] = useState({ flag: '', id: '', type: '' });
-
-  const inquiryClickButton = () => {
-    if (parameters.page === 0) {
-      onSearchButtonClick(parameters);
-    }
-    dispatch(setParameters({ page: 0 }));
-  };
-
-  const handleInsertButtonClick = (label) => {
-    setModalParams({ flag: 'insert', id: parameters.id, type: label });
-    setModalOpen(true);
-  };
-
-  return (
-    <>
-      <GridItem item directionHorizon="space-between">
-        <ButtonSet
-          type="custom"
-          options={[
-            {
-              label: '사이트 설정',
-              callBack: () => handleInsertButtonClick('site'),
-              variant: 'outlined',
-            },
-            {
-              label: '패턴 설정',
-              callBack: () => handleInsertButtonClick('pattern'),
-              variant: 'outlined',
-            },
-            {
-              label: '출발지IP 설정',
-              callBack: () => handleInsertButtonClick('srcip'),
-              variant: 'outlined',
-            },
-          ]}
-        />
-        <ButtonSet
-          type="custom"
-          options={[
-            {
-              label: '조회',
-              callBack: () => inquiryClickButton(),
-              // color: 'info',
-              variant: 'outlined',
-            },
-            // {
-            //   label: '설정',
-            //   callBack: handleInsertButtonClick,
-            //   variant: 'outlined',
-            // },
-            {
-              label: '취소',
-              callBack: () => {
-                router.push({
-                  pathname: '/hss/sslswgManage/policyGroupManage',
-                });
-              },
-              // color: 'error',
-              variant: 'outlined',
-            },
-          ]}
-        />
-      </GridItem>
-      {modalOpen && (
-        <PolicyDetailUpdateStatusModal
-          open={modalOpen}
-          close={setModalOpen}
-          modalParams={modalParams}
-          getStatusList={inquiryClickButton}
-        />
-      )}
-    </>
-  );
-}
-
-export default PolicyGroupUpdateStatusActionButton;
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusSearchForm.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusSearchForm.jsx	2025-03-12 13:30:03.178378600 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusSearchForm.jsx	1970-01-01 09:00:00.000000000 +0900
@@ -1,63 +0,0 @@
-import { useDispatch, useSelector } from 'react-redux';
-import SearchInput from '@components/modules/input/SearchInput';
-import GridItem from '@components/modules/grid/GridItem';
-import LabelInput from '@components/modules/input/LabelInput';
-import { setParameters } from '@modules/redux/reducers/hss/sslswg/policyGroupUpdateStatus';
-
-function PolicyGroupUpdateStatusSearchForm() {
-  const dispatch = useDispatch();
-
-  const parameterData = useSelector((state) => state.swgPolicyGroupUpdateStatus);
-  const parameters = parameterData.parameters.current;
-
-  const handleChange = (event, validValue = null) => {
-    let value = validValue === null ? event.target.value : validValue;
-    if (event instanceof PointerEvent) {
-      value = event.target.value;
-    }
-
-    dispatch(setParameters({ [event.target.name]: value }));
-  };
-
-  return (
-    <SearchInput positionUnset>
-      <GridItem
-        container
-        divideColumn={3}
-        spacing={2}
-        sx={{
-          pr: 5,
-          '& .text': { maxWidth: '180px', minWidth: '180px' },
-          '.inputBox': { maxWidth: '200px', minWidth: '200px' },
-        }}
-      >
-        <LabelInput label="정책명" name="name" value={parameters.name} onChange={handleChange} />
-        <LabelInput
-          type="select"
-          label="타입"
-          name="type"
-          list={[
-            { label: '사이트', value: 'site' },
-            { label: '패턴', value: 'pattern' },
-            { label: '출발지IP', value: 'srcip' },
-          ]}
-          value={parameters.type || ''}
-          onChange={handleChange}
-        />
-        <LabelInput
-          type="select"
-          label="정책 유형"
-          name="level"
-          value={parameters.level || ''}
-          list={[
-            { label: '개별', value: '1' },
-            { label: '그룹', value: '2' },
-          ]}
-          onChange={handleChange}
-        />
-      </GridItem>
-    </SearchInput>
-  );
-}
-
-export default PolicyGroupUpdateStatusSearchForm;
diff -urN ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusTable.jsx .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusTable.jsx	2025-03-14 18:07:35.823738700 +0900
+++ .\src\/components/hss/sslswg/policy/policyGroupStatus/update/policyGroupUpdateStatusTable.jsx	1970-01-01 09:00:00.000000000 +0900
@@ -1,71 +0,0 @@
-import { useDispatch, useSelector } from 'react-redux';
-import GridItem from '@components/modules/grid/GridItem';
-import { setDeleteList } from '@modules/redux/reducers/hss/sslswg/policyGroupUpdateStatus';
-import HsReduxTable from '@components/modules/table/HsReduxTable';
-
-function PolicyGroupUpdateStatusTable() {
-  const { columns, deleteList } = useSelector((state) => state.swgPolicyGroupUpdateStatus);
-
-  const dispatch = useDispatch();
-
-  const makeColumns = () =>
-    columns.map((column) => ({
-      ...column,
-      Cell: (props) => {
-        // const original = props.row.original;
-        const value = props.value;
-
-        switch (column.accessor) {
-          case 'level':
-            return <>{value === 1 ? '개별' : '그룹'}</>;
-          case 'type': {
-            const typeMap = new Map([
-              ['site', '사이트 > 도메인'],
-              ['url', '사이트 > URL'],
-              ['regexpheader', '패턴 > HEADER'],
-              ['regexppayload', '패턴 > PAYLOAD'],
-              ['regexpurl', '패턴 > URL'],
-              ['srcip', '출발지IP'],
-            ]);
-
-            return <>{typeMap.has(value) ? typeMap.get(value) : 'unknown'}</>;
-          }
-          case 'name':
-          default:
-            return <>{value}</>;
-        }
-      },
-    }));
-
-  const handleChangeChecked = (value) => {
-    dispatch(setDeleteList(value));
-  };
-
-  return (
-    <GridItem item>
-      <HsReduxTable
-        sx={{
-          '.CMM-rt-headerArea-tableHead, .CMM-rt-headerArea-tableHead tr th': {
-            height: '35px !important',
-            padding: '0',
-          },
-          '.CMM-rt-tableArea-reactRow': {
-            cursor: 'pointer',
-            height: 'unset', // 높이 자동 조절!
-          },
-          '.CMM-rt-rowArea-tableCell div p': {
-            fontSize: '13px',
-            verticalAlign: 'middle',
-            lineHeight: '35px',
-          },
-        }}
-        name="swgPolicyGroupUpdateStatus"
-        customColumn={makeColumns()}
-        checkList={deleteList}
-        onChangeChecked={handleChangeChecked}
-      />
-    </GridItem>
-  );
-}
-
-export default PolicyGroupUpdateStatusTable;
diff -urN ..\hss-frontend\src\/components/hss/sslva/log/index.jsx .\src\/components/hss/sslva/log/index.jsx
--- ..\hss-frontend\src\/components/hss/sslva/log/index.jsx	2025-02-26 09:51:57.280556500 +0900
+++ .\src\/components/hss/sslva/log/index.jsx	2025-03-11 15:16:29.107695900 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useCallback } from 'react';
+import { useEffect, useCallback,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -67,6 +67,14 @@
   }, []);
 
   const setDefaultLog = async () => {
+    // <span style="color: red;">현재 상태가 이미 기본 상태(빈 로그, totalElements 0)라면 dispatch하지 않음</span>
+    if (
+      Array.isArray(parameterData.pageDataList) &&
+      parameterData.pageDataList.length === 0 &&
+      Number(parameterData.totalElements) === 0
+    ) {
+      return;
+    }
     const log_list = [];
     const totalElements = 0;
     dispatch(setPageDataList({ pageDataList: log_list, totalElements }));
@@ -136,7 +144,16 @@
     }
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed.current) return;
+
     init();
     getSegmentNameList();
 
@@ -146,12 +163,13 @@
   }, []);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;
     if (parameters.segmentName !== '') {
       getLogList(parameterData.parameters.current);
     } else {
       setDefaultLog();
     }
-  }, [size, page]);
+  }, [size, page,parameters.segmentName]);
 
   return (
     <GridItem spacing={2} container direction="column">
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/index.jsx .\src\/components/hss/sslva/policy/policyDetailStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/index.jsx	2025-03-12 13:30:03.180522300 +0900
+++ .\src\/components/hss/sslva/policy/policyDetailStatus/index.jsx	2025-03-11 15:54:12.903278400 +0900
@@ -1,4 +1,4 @@
-import { useState, useEffect } from 'react';
+import { useState, useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -10,7 +10,6 @@
   setListInfo,
   setPageDataList,
   setParameters,
-  setProtocolTypeList,
 } from '@modules/redux/reducers/hss/sslva/policyDetailStatus';
 import useApi from '@modules/hooks/useApi';
 
@@ -39,29 +38,9 @@
   const init = async () => {
     const gridInfo = await HsLib.getGridInfo('PolicyDetailStatusList', policyDetailStatusApi);
 
-    if (gridInfo) {
-      const protocolList = await apiCall(protocolStatusApi.getProtocolStatusList, {
-        contentOnly: true,
-      });
-      const protocolTypeList = await apiCall(protocolStatusApi.getProtocolTypeList);
-      let formattedList = [];
-      if (Array.isArray(protocolTypeList)) {
-        formattedList = protocolTypeList.map(({ id, name }) => ({
-          value: id,
-          label: name.toUpperCase(),
-        }));
-      }
-
-      unstable_batchedUpdates(() => {
-        responseGridInfo(gridInfo);
-        if (protocolList) {
-          setProtocolList(protocolList);
-        }
-        if (formattedList.length > 0) {
-          dispatch(setProtocolTypeList(formattedList));
-        }
-      });
-    }
+    unstable_batchedUpdates(() => {
+      responseGridInfo(gridInfo);
+    });
   };
 
   const responseGridInfo = (p_gridInfo) => {
@@ -113,8 +92,16 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     init();
     getProtocolList();
 
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusSearchForm.jsx .\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusSearchForm.jsx	2025-03-12 13:30:03.181036800 +0900
+++ .\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusSearchForm.jsx	2025-03-05 14:20:47.411687000 +0900
@@ -9,7 +9,7 @@
 
   const parameterData = useSelector((state) => state.policyDetailStatus);
   const parameters = parameterData.parameters.current;
-  const protocolTypeList = parameterData.protocolTypeList;
+  const protocolNameList = useSelector((state) => state.protocolStatus.protocolList);
 
   const handleChange = (event, validValue = null) => {
     let value = validValue === null ? event.target.value : validValue;
@@ -36,9 +36,9 @@
         <LabelInput
           type="select"
           label="프로토콜"
-          name="protocolTypeId"
-          list={protocolTypeList}
-          value={parameters.protocolTypeId}
+          name="protocol"
+          list={protocolNameList}
+          value={parameters.protocol}
           onChange={handleChange}
         />
       </GridItem>
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusTable.jsx .\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusTable.jsx	2025-03-12 13:30:03.182069700 +0900
+++ .\src\/components/hss/sslva/policy/policyDetailStatus/policyDetailStatusTable.jsx	2025-03-05 14:20:47.412238800 +0900
@@ -10,9 +10,7 @@
 function PolicyDetailStatusTable(props) {
   const { getPolicyDetailStatusList, protocolList } = props;
 
-  const { columns, deleteList, protocolTypeList } = useSelector(
-    (state) => state.policyDetailStatus,
-  );
+  const { columns, deleteList } = useSelector((state) => state.policyDetailStatus);
 
   const dispatch = useDispatch();
 
@@ -28,21 +26,23 @@
         const value = props.value;
 
         switch (column.accessor) {
-          case 'name':
-            return reunderCodeTypeNameCell(value, original.id);
-          case 'protocolTypeId':
-            return <>{protocolTypeList.find((item) => item.value === value)?.label || 'Unknown'}</>;
+          case 'protocol':
+            return reunderCodeTypeNameCell(value.toUpperCase(), original.id);
           case 'passthrough':
           case 'verifyPeer':
           case 'validateProto':
           case 'denyOcsp':
           case 'userAuth':
           case 'linked':
-            return <>{props.value == 1 ? 'Y' : 'N'}</>;
+            return reunderCodeTypeNameCell(
+              props.value == 1 ? 'Y' : 'N',
+              original.name,
+              original.id,
+            );
           case 'protocolIdList':
             return <ListComponent data={value} list={protocolList} />;
           default:
-            return <>{value}</>;
+            return reunderCodeTypeNameCell(value, original.id);
         }
       },
     }));
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/policyGroupStatus/index.jsx .\src\/components/hss/sslva/policy/policyGroupStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/policyGroupStatus/index.jsx	2025-02-19 14:50:03.823809200 +0900
+++ .\src\/components/hss/sslva/policy/policyGroupStatus/index.jsx	2025-03-11 15:31:17.937724000 +0900
@@ -1,4 +1,4 @@
-import { useState, useEffect, useCallback } from 'react';
+import { useState, useEffect, useCallback, useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -108,8 +108,16 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     init();
     getDetailList();
     getSegmentNameList();
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/policyGroupStatus/policyGroupStatusTable.jsx .\src\/components/hss/sslva/policy/policyGroupStatus/policyGroupStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/policyGroupStatus/policyGroupStatusTable.jsx	2025-03-12 13:30:03.182582600 +0900
+++ .\src\/components/hss/sslva/policy/policyGroupStatus/policyGroupStatusTable.jsx	2025-03-05 14:20:47.413888000 +0900
@@ -26,12 +26,10 @@
         const value = props.value;
 
         switch (column.accessor) {
-          case 'name':
-            return reunderCodeTypeNameCell(value, original.id);
           case 'detailIdList':
             return <ListComponent data={value} list={detailList} />;
           default:
-            return <>{value}</>;
+            return reunderCodeTypeNameCell(value, original.id);
         }
       },
     }));
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/index.jsx .\src\/components/hss/sslva/policy/protocolStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/index.jsx	2025-03-12 13:30:03.183615900 +0900
+++ .\src\/components/hss/sslva/policy/protocolStatus/index.jsx	2025-03-11 15:54:07.834380400 +0900
@@ -1,4 +1,4 @@
-import { useEffect } from 'react';
+import { useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -10,7 +10,6 @@
   setListInfo,
   setPageDataList,
   setParameters,
-  setProtocolTypeList,
 } from '@modules/redux/reducers/hss/sslva/protocolStatus';
 import useApi from '@modules/hooks/useApi';
 
@@ -36,23 +35,9 @@
   const init = async () => {
     const gridInfo = await HsLib.getGridInfo('ProtocolStatusList', protocolStatusApi);
 
-    if (gridInfo) {
-      const protocolTypeList = await apiCall(protocolStatusApi.getProtocolTypeList);
-      let formattedList = [];
-      if (Array.isArray(protocolTypeList)) {
-        formattedList = protocolTypeList.map(({ id, name }) => ({
-          value: id,
-          label: name.toUpperCase(),
-        }));
-      }
-
-      unstable_batchedUpdates(() => {
-        responseGridInfo(gridInfo);
-        if (formattedList.length > 0) {
-          dispatch(setProtocolTypeList(formattedList));
-        }
-      });
-    }
+    unstable_batchedUpdates(() => {
+      responseGridInfo(gridInfo);
+    });
   };
 
   const responseGridInfo = (p_gridInfo) => {
@@ -97,8 +82,17 @@
       });
     }
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return; 
+
     init();
 
     return () => {
@@ -107,6 +101,7 @@
   }, []);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return; 
     getProtocolStatusList(parameterData.parameters.current);
   }, [size, page]);
 
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/protocolStatusSearchForm.jsx .\src\/components/hss/sslva/policy/protocolStatus/protocolStatusSearchForm.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/protocolStatusSearchForm.jsx	2025-03-12 13:30:03.184130000 +0900
+++ .\src\/components/hss/sslva/policy/protocolStatus/protocolStatusSearchForm.jsx	2025-03-05 14:20:47.415442000 +0900
@@ -9,7 +9,7 @@
 
   const parameterData = useSelector((state) => state.protocolStatus);
   const parameters = parameterData.parameters.current;
-  const protocolTypeList = parameterData.protocolTypeList;
+  const defaultProtocolList = useSelector((state) => state.protocolStatus.protocolList);
 
   const handleChange = (event, validValue = null) => {
     let value = validValue === null ? event.target.value : validValue;
@@ -36,9 +36,9 @@
         <LabelInput
           type="select"
           label="프로토콜"
-          name="protocolTypeId"
-          list={protocolTypeList}
-          value={parameters.protocolTypeId}
+          name="protocol"
+          list={defaultProtocolList}
+          value={parameters.protocol}
           onChange={handleChange}
         />
         <LabelInput
@@ -48,7 +48,6 @@
           inputProps={{ maxLength: 5 }}
           value={parameters.port}
           onChange={handleChange}
-          onlyNumber
         />
       </GridItem>
     </SearchInput>
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/protocolStatusTable.jsx .\src\/components/hss/sslva/policy/protocolStatus/protocolStatusTable.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/protocolStatus/protocolStatusTable.jsx	2025-03-12 13:30:03.185164100 +0900
+++ .\src\/components/hss/sslva/policy/protocolStatus/protocolStatusTable.jsx	2025-03-05 14:20:47.415956900 +0900
@@ -9,7 +9,7 @@
 function ProtocolStatusTable(props) {
   const { getProtocolStatusList } = props;
 
-  const { columns, deleteList, protocolTypeList } = useSelector((state) => state.protocolStatus);
+  const { columns, deleteList } = useSelector((state) => state.protocolStatus);
 
   const dispatch = useDispatch();
 
@@ -21,19 +21,12 @@
       ...column,
       Cell: (props) => {
         const original = props.row.original;
-        const value = props.value;
-
-        switch (column.accessor) {
-          case 'name':
-            return reunderCodeTypeNameCell(value, original.id);
-          case 'protocolTypeId': {
-            const protocolTypeLabel =
-              protocolTypeList.find((item) => item.value === value)?.label || 'Unknown';
-            return <>{protocolTypeLabel}</>;
-          }
-          default:
-            return <>{value}</>;
+        let value = props.value;
+        if (column.accessor === 'protocol') {
+          value = value.toUpperCase();
         }
+
+        return reunderCodeTypeNameCell(value, original.id);
       },
     }));
 
diff -urN ..\hss-frontend\src\/components/hss/sslva/policy/segmentStatus/index.jsx .\src\/components/hss/sslva/policy/segmentStatus/index.jsx
--- ..\hss-frontend\src\/components/hss/sslva/policy/segmentStatus/index.jsx	2025-02-19 14:50:03.828820700 +0900
+++ .\src\/components/hss/sslva/policy/segmentStatus/index.jsx	2025-03-11 15:31:00.970325100 +0900
@@ -1,4 +1,4 @@
-import { useState, useEffect, useCallback } from 'react';
+import { useState, useEffect, useCallback,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -112,7 +112,16 @@
     setIsLoading(param);
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     init();
 
     return () => {
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/Drawer/DrawerContent/Navigation/NavItem.jsx .\src\/components/layouts/MainLayout/Drawer/DrawerContent/Navigation/NavItem.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/Drawer/DrawerContent/Navigation/NavItem.jsx	2024-10-18 16:27:14.049692100 +0900
+++ .\src\/components/layouts/MainLayout/Drawer/DrawerContent/Navigation/NavItem.jsx	2025-03-08 16:33:21.764449200 +0900
@@ -1,5 +1,5 @@
 import PropTypes from 'prop-types';
-import { forwardRef, useEffect, useMemo, useState } from 'react';
+import { forwardRef, useEffect,useCallback, useMemo, useState } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 import { alpha } from '@mui/material/styles';
 
@@ -68,13 +68,26 @@
   if (item.target) {
     itemTarget = '_blank';
   }
+  const [anchorEl, setAnchorEl] = useState(null);
+
+
+  const handleClick = useCallback((event) => {
+    setAnchorEl(event?.currentTarget || null);
+    dispatch(selectedItem({ selectedItem: item }));
+  }, [dispatch, item]);
+
+  const handleClose = () => {
+    setAnchorEl(null);
+  };
 
   let listItemProps = useMemo(() => {
     return {
-      component: forwardRef(function listItemProps(props, ref) {
+      component: forwardRef(({ key, ...props }, ref) => { // ✅ key 분리
+        const href = item?.url ?? "#"; // ✅ undefined 방지 (기본값 제공)
+        
         return (
-          <NextLink href={item.url} passHref>
-            <Link
+          <NextLink href={href} passHref> {/* ✅ `href` 값이 항상 존재하게 보장 */}
+            <ListItemButton
               {...props}
               {...(!drawerOpen && { onMouseEnter: handleClick, onMouseLeave: handleClose })}
               onClick={handleClick}
@@ -85,7 +98,9 @@
         );
       }),
     };
-  }, [drawerOpen, anchorEl]);
+  }, [drawerOpen, item?.url]); // ✅ item.url 의존성 추가
+  
+  
   if (item?.external) {
     listItemProps = { component: 'a', href: item.url, target: itemTarget };
   }
@@ -98,12 +113,8 @@
   );
 
   let pathname = document.location.pathname;
-
-  const [anchorEl, setAnchorEl] = useState(null);
-
   const urlList = item.url.split('/').filter((url) => url);
   const sameEl = item.url.split('/').filter((url) => url && pathname.split('/').includes(url));
-
   let urlMatch = false;
   if (sameEl.length >= urlList.length - 1) {
     let preUrl = '/';
@@ -122,21 +133,13 @@
     if (urlMatch) {
       dispatch(activeItem({ openItem: [item.url] }));
     }
-
     // eslint-disable-next-line
   }, [pathname]);
 
-  const handleClick = (event) => {
-    setAnchorEl(event?.currentTarget);
-    dispatch(selectedItem({ selectedItem: item }));
-  };
-
-  const handleClose = () => {
-    setAnchorEl(null);
-  };
-
   useEffect(() => {
-    setAnchorEl(false);
+    if (anchorEl) {
+      setAnchorEl(null);
+    }
   }, [drawerOpen]);
 
   const openMini = Boolean(anchorEl);
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/Drawer/DrawerHeader/index.jsx .\src\/components/layouts/MainLayout/Drawer/DrawerHeader/index.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/Drawer/DrawerHeader/index.jsx	2025-02-26 09:51:57.281557100 +0900
+++ .\src\/components/layouts/MainLayout/Drawer/DrawerHeader/index.jsx	2025-03-05 16:57:59.534976700 +0900
@@ -1,10 +1,12 @@
+'use client'; // ✅ Next.js 15에서 클라이언트 컴포넌트로 선언해야 함
+
 import PropTypes from 'prop-types';
 import Image from 'next/image';
 import NextLink from 'next/link';
 import { useSession } from 'next-auth/react';
 
 // material-ui
-import { useTheme } from '@mui/material/styles';
+import { ButtonBase } from '@mui/material';
 
 // project import
 import DrawerHeaderStyled from './DrawerHeaderStyled';
@@ -12,26 +14,24 @@
 import largeBlackHanssak from '@public/images/logoColor.svg';
 import smallWhiteHanssak from '@public/images/minilogo.svg';
 import smallBlackHanssak from '@public/images/minLogoColor.svg';
-import { ButtonBase } from '@mui/material';
 import Search from '../../Header/HeaderContent/Search';
 import useConfig from '@modules/hooks/useConfig';
 
 // ==============================|| DRAWER HEADER ||============================== //
+
 const myLoader = ({ src }) => {
   return src; // 정적 경로 그대로 반환
 };
-const DrawerHeader = ({ open }) => {
-  const theme = useTheme();
-  const {
-    data: {
-      user: { firstPage },
-    },
-  } = useSession();
 
+const DrawerHeader = ({ open }) => {
+  const { data: session } = useSession();
   const { menuMode, mode } = useConfig();
+
+  const firstPage = session?.user?.firstPage || '/';
+
   return (
     <>
-      <DrawerHeaderStyled theme={theme} open={open}>
+      <DrawerHeaderStyled open={open}>
         <NextLink href={firstPage} passHref>
           <ButtonBase disableRipple>
             {open ? (
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/index.jsx .\src\/components/layouts/MainLayout/Header/HeaderContent/index.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/index.jsx	2025-02-19 14:50:03.839809700 +0900
+++ .\src\/components/layouts/MainLayout/Header/HeaderContent/index.jsx	2025-03-07 14:50:37.467616500 +0900
@@ -31,8 +31,10 @@
   } = useSelector((state) => state.menu);
 
   useEffect(() => {
-    if (!selectedTopMenu && topItems.length !== 0) {
-      dispatch(setSelectedTopMenu({ selectedTopMenu: topItems[0].menuId }));
+    if (Array.isArray(topItems)) {
+      if (!selectedTopMenu && topItems.length !== 0) {
+        dispatch(setSelectedTopMenu({ selectedTopMenu: topItems[0].menuId }));
+      }
     }
   }, [topItems, selectedTopMenu]);
   const handleTabChange = (_, newValue) => {
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/Search.jsx .\src\/components/layouts/MainLayout/Header/HeaderContent/Search.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/Search.jsx	2024-10-18 16:27:14.061696600 +0900
+++ .\src\/components/layouts/MainLayout/Header/HeaderContent/Search.jsx	2025-03-07 13:50:07.137718700 +0900
@@ -34,11 +34,15 @@
 
   // Tree Initial Data.
   useEffect(() => {
-    if (treeData.length !== 0 && treeOriginData.length === 0) setTreeOriginData(treeData);
+    if (treeData.length !== 0 && treeOriginData.length === 0){
+      setTreeOriginData(treeData);
+    } 
   }, [searchOptions.data]);
 
   useEffect(() => {
-    if (topMenu) setMenuArr(topMenu.children);
+    if (topMenu){
+      setMenuArr(topMenu.children);
+    } 
   }, [topMenu]);
 
   const filterList = (value, list) => {
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/Timer.jsx .\src\/components/layouts/MainLayout/Header/HeaderContent/Timer.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/Header/HeaderContent/Timer.jsx	2024-10-30 10:15:29.822848500 +0900
+++ .\src\/components/layouts/MainLayout/Header/HeaderContent/Timer.jsx	2025-03-07 09:38:13.534737400 +0900
@@ -6,32 +6,53 @@
 const Timer = () => {
   const [serverTime, setServerTime] = useState(dayjs('1979-07-08'));
   const eventSource = useRef(null);
+  const isMounted = useRef(false); // ✅ 컴포넌트 마운트 상태 체크
+  const isFirstRender = useRef(true); // ✅ StrictMode에서 첫 번째 실행 방지
   const { data: session } = useSession();
 
   const onOpen = () => {};
   const onMessage = (event) => {
-    const { attribute } = JSON.parse(event);
-    const { server_date: serverDate } = attribute;
-    setServerTime(dayjs(serverDate));
+    try {
+      const { attribute } = JSON.parse(event);
+      const { server_date: serverDate } = attribute;
+
+      if (isMounted.current) { // ✅ 마운트된 상태에서만 업데이트
+        setServerTime(dayjs(serverDate));
+      }
+    } catch (error) {
+      console.error("서버 시간 데이터 파싱 오류:", error);
+    }
   };
   const onError = (error) => {
-    if (error.status !== 200) {
-      // window.location.href = '/';
-    }
+    console.error("SSE 연결 오류:", error);
   };
 
   useEffect(() => {
-    eventSource.current = fetchSSEApi.connectToEventSource(
-      '/api/event/servertime',
-      session?.user.hsssessionid,
-      session?.accessToken,
-      onOpen,
-      onMessage,
-      onError,
-    );
+    if (isFirstRender.current) { 
+      isFirstRender.current = false; // ✅ 첫 번째 실행은 즉시 return (Strict Mode 대응)
+      return;
+    }
+
+    isMounted.current = true; // ✅ 마운트 상태 설정
+
+    try {
+      eventSource.current = fetchSSEApi.connectToEventSource(
+        '/api/event/servertime',
+        session?.user.hsssessionid,
+        session?.accessToken,
+        onOpen,
+        onMessage,
+        onError,
+      );
+    } catch (error) {
+      console.error("SSE 연결 중 오류 발생:", error);
+    }
 
     return () => {
-      fetchSSEApi.closeEventSource(eventSource.current);
+      isMounted.current = false; // ✅ 언마운트 상태로 변경
+      if (eventSource.current) {
+        fetchSSEApi.closeEventSource(eventSource.current);
+      }
     };
   }, []);
 
diff -urN ..\hss-frontend\src\/components/layouts/MainLayout/index.jsx .\src\/components/layouts/MainLayout/index.jsx
--- ..\hss-frontend\src\/components/layouts/MainLayout/index.jsx	2024-10-18 16:27:14.062692400 +0900
+++ .\src\/components/layouts/MainLayout/index.jsx	2025-03-08 16:23:21.376926000 +0900
@@ -1,5 +1,5 @@
 import PropTypes from 'prop-types';
-import { useEffect, useState } from 'react';
+import { useEffect, useState, useRef } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 
 // material-ui
@@ -24,7 +24,7 @@
   const theme = useTheme();
   const matchDownLG = useMediaQuery(theme.breakpoints.down('xl'));
   const dispatch = useDispatch();
-
+  const hasFetched = useRef(false);
   const { container, miniDrawer, fullSizeFlag } = useConfig();
 
   const menu = useSelector((state) => state.menu);
@@ -44,6 +44,8 @@
 
   // set media wise responsive drawer
   useEffect(() => {
+    if (hasFetched.current) return;
+    hasFetched.current = true;
     if (!miniDrawer) {
       setOpen(!matchDownLG);
       dispatch(openDrawer({ drawerOpen: !matchDownLG }));
@@ -51,10 +53,14 @@
   }, [matchDownLG]);
 
   useEffect(() => {
+    if (hasFetched.current) return;
+    hasFetched.current = true;
     if (open !== drawerOpen) setOpen(drawerOpen);
   }, [drawerOpen]);
 
   useEffect(() => {
+    if (hasFetched.current) return;
+    hasFetched.current = true;
     // 메뉴 설정 값 조회
     const getMenuConfig = async () => {
       const result = await apiCall(preferencesApi.getPreferences, {
diff -urN ..\hss-frontend\src\/components/mantis/tree/CollapseTreeList.jsx .\src\/components/mantis/tree/CollapseTreeList.jsx
--- ..\hss-frontend\src\/components/mantis/tree/CollapseTreeList.jsx	2024-10-18 16:27:14.077258200 +0900
+++ .\src\/components/mantis/tree/CollapseTreeList.jsx	2025-03-10 19:10:02.555490500 +0900
@@ -11,7 +11,8 @@
 // MUI
 import { Box, Button } from '@mui/material';
 import { RightOutlined, LeftOutlined } from '@ant-design/icons';
-import { SizeMe } from 'react-sizeme';
+import { Measure } from 'react-measure';
+//import { SizeMe } from 'react-sizeme';
 import { useTheme } from '@mui/material/styles';
 
 function CollapseTreeList({ children, menuData = [], defaultOpen = false, btnDisplay = false }) {
@@ -37,13 +38,12 @@
   const handleClose = () => {
     setContextMenu(null);
   };
-
+  const measureRef = useRef(null);
   return (
-    <SizeMe
-      monitorHeight
-      refreshRate={32}
-      render={({ size }) => (
+    <Measure bounds onResize={(contentRect) => setSize(contentRect.bounds)}>
+      {({ measureRef }) => (
         <Box
+          ref={measureRef}
           sx={{
             display: 'flex',
             height: '100%',
@@ -83,95 +83,7 @@
               contentSX={{ height: '100%' }}
               onContextMenu={handleContextMenu}
             >
-              {children || (
-                // 예시 트리 추후 제거.
-                <TreeList>
-                  <TreeListItem nodeId="한싹" label="한싹" sx={{ height: 'inherit' }}>
-                    <TreeListItem nodeId="1" label="ACES테스트 목록">
-                      <TreeListItem nodeId="1-1" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a1-1" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-2" label="이엔제이솔루션2">
-                        <TreeListItem nodeId="a1-2" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-3" label="이엔제이솔루션3">
-                        <TreeListItem nodeId="a1-3" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-4" label="이엔제이솔루션4">
-                        <TreeListItem nodeId="a1-4" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-5" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-5" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-6" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-6" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-7" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-7" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-8" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-8" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-9" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-9" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-10" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-10" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-11" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a1-1" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-12" label="이엔제이솔루션2">
-                        <TreeListItem nodeId="a1-2" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-13" label="이엔제이솔루션3">
-                        <TreeListItem nodeId="a1-3" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-14" label="이엔제이솔루션4">
-                        <TreeListItem nodeId="a1-4" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-15" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-5" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-16" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-6" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-17" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-7" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-18" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-8" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-19" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-9" label="1" />
-                      </TreeListItem>
-                      <TreeListItem nodeId="1-20" label="이엔제이솔루션5">
-                        <TreeListItem nodeId="a1-10" label="1" />
-                      </TreeListItem>
-                    </TreeListItem>
-                    <TreeListItem nodeId="2" label="ACES테스트 목록">
-                      <TreeListItem nodeId="2-1" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a2-1" label="1" />
-                      </TreeListItem>
-                    </TreeListItem>
-                    <TreeListItem nodeId="3" label="ACES테스트 목록">
-                      <TreeListItem nodeId="3-1" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a3-1" label="1" />
-                      </TreeListItem>
-                    </TreeListItem>
-                    <TreeListItem nodeId="4" label="ACES테스트 목록">
-                      <TreeListItem nodeId="4-1" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a4-1" label="1" />
-                      </TreeListItem>
-                    </TreeListItem>
-                    <TreeListItem nodeId="5" label="ACES테스트 목록">
-                      <TreeListItem nodeId="5-1" label="이엔제이솔루션1">
-                        <TreeListItem nodeId="a5-1" label="1" />
-                      </TreeListItem>
-                    </TreeListItem>
-                  </TreeListItem>
-                </TreeList>
-              )}
+              {children}
 
               {menuData.length !== 0 && (
                 <Menu
@@ -217,7 +129,7 @@
           ) : null}
         </Box>
       )}
-    />
+    </Measure>
   );
 }
 
diff -urN ..\hss-frontend\src\/components/modal/hss/common/accountManage/accountGroupModal.jsx .\src\/components/modal/hss/common/accountManage/accountGroupModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/common/accountManage/accountGroupModal.jsx	2025-02-19 14:50:03.843809000 +0900
+++ .\src\/components/modal/hss/common/accountManage/accountGroupModal.jsx	2025-03-08 17:27:06.892076500 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState,useRef } from 'react';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
 import GridItem from '@components/modules/grid/GridItem';
@@ -24,8 +24,19 @@
       descr: '',
     },
   });
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
 
   useEffect(() => {
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current) {
+      return;
+    }
+
     if (flag === 'update') {
       getDetails();
     }
diff -urN ..\hss-frontend\src\/components/modal/hss/common/accountManage/accountModal.jsx .\src\/components/modal/hss/common/accountManage/accountModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/common/accountManage/accountModal.jsx	2025-02-19 14:50:03.844809300 +0900
+++ .\src\/components/modal/hss/common/accountManage/accountModal.jsx	2025-03-08 17:29:52.376576800 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState,useRef } from 'react';
 import { useSelector } from 'react-redux';
 import { FormProvider, useForm } from 'react-hook-form';
 import { unstable_batchedUpdates } from 'react-dom';
@@ -41,8 +41,21 @@
       descr: '',
     },
   });
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
+
 
   useEffect(() => {
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current) {
+      return;
+    }
+
+
     if (flag === 'update') {
       getDetails();
     }
diff -urN ..\hss-frontend\src\/components/modal/hss/common/networkManage/interfaceModal.jsx .\src\/components/modal/hss/common/networkManage/interfaceModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/common/networkManage/interfaceModal.jsx	2025-02-19 14:50:03.853808900 +0900
+++ .\src\/components/modal/hss/common/networkManage/interfaceModal.jsx	2025-03-08 16:50:33.065648300 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState, useRef } from 'react';
 import { useSelector } from 'react-redux';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
@@ -13,11 +13,11 @@
   const { alertOpen, setModalOpen, modalParams, getInterfaceList } = props;
   const { flag, id } = modalParams;
   const { instance, source } = AuthInstance();
+  const isUnmounted = useRef(false); // ✅ 언마운트 여부 체크
 
   interfaceApi.axios = instance;
 
   const parameterData = useSelector((state) => state.interfaceModule);
-
   const typeList = parameterData.interfaceTypeList;
   const interfaceMemberList = parameterData.interfaceMemberList;
   const pageDataList = parameterData.pageDataList;
@@ -39,49 +39,68 @@
       gateway: '',
     },
   });
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
   useEffect(() => {
+
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current){
+      return;
+    } 
+
+    
     if (flag === 'update') {
       getInterface();
     }
 
     return () => {
-      source.cancel();
+      isUnmounted.current = true; // ✅ 언마운트 체크
+      if (source) {
+        source.cancel();
+      }
     };
   }, []);
 
+
+
   useEffect(() => {
+
+
     if (flag === 'update') {
-      if (methods.getValues().member !== '') {
-        if (methods.getValues().member === 'MNGT') {
-          setIsTextDisabled(false);
-        }
-        else {
-          setIsTextDisabled(true);
-        }
+      const memberValue = methods.getValues().member;
+      if (memberValue !== '') {
+        setIsTextDisabled(memberValue !== 'MNGT');
       }
 
-      if (methods.getValues().type == 'bridge') {
+      const typeValue = methods.getValues().type;
+      if (typeValue === 'bridge') {
         setIsTypeDisabled(true);
         setIsMemberDisabled(true);
-      }
-      else if (methods.getValues().type == 'ethernet') {
+      } else if (typeValue === 'ethernet') {
         setIsTypeDisabled(true);
       }
+
       setIsNameDisabled(true);
     }
   }, [methods.watch()]);
 
   const getInterface = async () => {
-    const result = await apiCall(interfaceApi.getInterfaceDetails, id);
-
-    for (const key in result) {
-      const value = result[`${key}`] ?? null;
-
-      if (value === null) {
-        methods.setValue(key, '');
-      } else {
-        methods.setValue(key, value);
+    try {
+      const result = await apiCall(interfaceApi.getInterfaceDetails, id);
+      
+      if (!isUnmounted.current) { // ✅ 언마운트된 경우 상태 업데이트 방지
+        for (const key in result) {
+          const value = result[key] ?? '';
+          methods.setValue(key, value);
+        }
+      }
+    } catch (error) {
+      if (!isUnmounted.current) {
+        console.error('인터페이스 데이터 불러오기 오류:', error);
       }
     }
   };
@@ -108,18 +127,21 @@
 
     if (mngt_check === 1) {
       result = "동일한 브릿지 인터페이스에서는 한개의 MNGT 인터페이스만 선택이 가능합니다.";
-    }
-    else {
-      if (flag === 'update') {
-        result = await apiCall(interfaceApi.updateInterfaceData, data);
-      } else {
-        result = await apiCall(interfaceApi.insertInterfaceData, data);
+    } else {
+      try {
+        if (flag === 'update') {
+          result = await apiCall(interfaceApi.updateInterfaceData, data);
+        } else {
+          result = await apiCall(interfaceApi.insertInterfaceData, data);
+        }
+      } catch (error) {
+        console.error('인터페이스 저장 중 오류:', error);
       }
     }
 
     setIsLoading(false);
 
-    if (result) {
+    if (!isUnmounted.current && result) {
       openModal({
         message: result,
         onConfirm: () => {
@@ -191,19 +213,19 @@
               name="ip" 
               labelBackgroundFlag 
               disabled={isTextDisabled}
-              />
+            />
             <LabelInput 
               label="서브넷 마스크" 
               name="subnet" 
               labelBackgroundFlag 
               disabled={isTextDisabled}
-              />
+            />
             <LabelInput 
               label="게이트웨이" 
               name="gateway" 
               labelBackgroundFlag 
               disabled={isTextDisabled}
-              />
+            />
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/patternGroupStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/patternGroupStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/patternGroupStatusModal.jsx	2025-03-14 18:07:35.825738800 +0900
+++ .\src\/components/modal/hss/sslswg/policy/patternGroupStatusModal.jsx	2025-03-05 15:06:33.328965800 +0900
@@ -21,7 +21,7 @@
     defaultValues: {
       name: '',
       action: '0',
-      type: 'regexpheader',
+      type: 'pattern',
     },
   });
 
@@ -100,9 +100,9 @@
               label="유형"
               name="type"
               list={[
-                { label: 'HEADER', value: 'regexpheader' },
-                { label: 'PAYLOAD', value: 'regexppayload' },
-                { label: 'URL', value: 'regexpurl' },
+                { label: 'HEADER', value: 'regexheader' },
+                { label: 'PAYLOAD', value: 'regexpayload' },
+                { label: 'URL', value: 'regexurl' },
               ]}
             />
             <LabelInput
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/patternStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/patternStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/patternStatusModal.jsx	2025-03-14 18:07:35.826738700 +0900
+++ .\src\/components/modal/hss/sslswg/policy/patternStatusModal.jsx	2025-03-05 15:06:33.329965600 +0900
@@ -7,7 +7,6 @@
 import { AuthInstance } from '@modules/axios';
 import patternStatusApi from '@api/hss/sslswg/policy/policyDetailManage/patternStatusApi';
 import Loader from '@components/mantis/Loader';
-import { Typography, Box } from '@mui/material';
 
 function PatternStatusModal(props) {
   const { alertOpen, setModalOpen, modalParams, getPatternStatusList } = props;
@@ -24,7 +23,7 @@
     defaultValues: {
       name: '',
       action: '0',
-      type: 'regexpheader',
+      type: 'regexheader',
       value: '',
     },
   });
@@ -134,9 +133,9 @@
               label="유형"
               name="type"
               list={[
-                { label: 'HEADER', value: 'regexpheader', disabled: isDisabled },
-                { label: 'PAYLOAD', value: 'regexppayload', disabled: isDisabled },
-                { label: 'URL', value: 'regexpurl', disabled: isDisabled },
+                { label: 'HEADER', value: 'regexheader', disabled: isDisabled },
+                { label: 'PAYLOAD', value: 'regexpayload', disabled: isDisabled },
+                { label: 'URL', value: 'regexurl', disabled: isDisabled },
               ]}
             />
             <LabelInput
@@ -162,56 +161,6 @@
               }}
               labelBackgroundFlag
             />
-            <Box colSpan={2} sx={{ p: 2, backgroundColor: '#FAFAFA' }}>
-              <Typography variant="body2" fontWeight="bold">
-                [유형] 정책을 적용할 대상의 범위를 선택하세요.
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 1, fontWeight: 'bold' }}>
-                HEADER:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - HTTP 요청 헤더의 특정 패턴에만 정책을 적용합니다.
-                <br />
-                - 사용자의 브라우저(User-Agent) 또는 특정 헤더 값이 포함된 요청을 확인할 수
-                있습니다.
-                <br />
-                예) User-Agent: .*MSIE → Internet Explorer 사용자 차단
-                <br />
-                Referer: .*facebook.com → Facebook에서 유입된 트래픽 차단
-                <br />
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                PAYLOAD:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 웹 페이지의 **본문(텍스트 내용)**에 특정 단어나 구문이 포함되었을 때만 정책을
-                적용합니다.
-                <br />
-                예) abc → `abc` 단어가 포함된 모든 페이지 차단
-                {/* < abc > → "abc" 단어가 포함된 모든 페이지 차단
-                  <test>,<secondtest> → "test"와 "secondtest"가 모두 포함된 페이지만 차단
-                  <this is a test phrase> → 특정 문장 "this is a test phrase"가 포함된 경우 차단 */}
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                URL:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - URL 또는 URL 패턴에만 정책을 적용합니다.
-                <br />
-                - 이미지, 동영상 등 특정 콘텐츠 유형을 포함한 URL을 차단할 수 있습니다.
-                <br />
-                예) (^|[\?+=&/])(.*\.google\..*/.*\?.*safe=off)([\?+=&/]|$) → 구글에서 안전
-                검색(SafeSearch)이 해제된 검색 차단
-                <br />
-                (images.google)+.*(\.jpg|\.wmv|\.mpg|\.mpeg|\.gif|\.mov) → Google 이미지 검색
-                결과에서 이미지, 영상 파일 차단
-                <br />
-                (google.com\/video) → Google 비디오 검색 차단
-              </Typography>
-            </Box>
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/policyDetailUpdateStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/policyDetailUpdateStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/policyDetailUpdateStatusModal.jsx	2025-03-14 18:07:35.827738700 +0900
+++ .\src\/components/modal/hss/sslswg/policy/policyDetailUpdateStatusModal.jsx	1970-01-01 09:00:00.000000000 +0900
@@ -1,376 +0,0 @@
-// libraries
-import { useState, useCallback, Fragment, useEffect, useMemo, useRef } from 'react';
-import {
-  Avatar,
-  Button,
-  Divider,
-  IconButton,
-  ListItem,
-  ListItemAvatar,
-  ListItemText,
-  OutlinedInput,
-  Stack,
-  usePagination,
-  Typography,
-  Chip,
-  List,
-} from '@mui/material';
-import { AddCircle, RemoveCircle, ChevronRight, ChevronLeft } from '@mui/icons-material';
-import { UserOutlined } from '@ant-design/icons';
-// components
-import Layout from '@components/layouts';
-import GridItem from '@components/modules/grid/GridItem';
-import ButtonSet from '@components/modules/button/ButtonSet';
-import PopUp from '@components/modules/common/PopUp';
-// functions
-import useApi from '@modules/hooks/useApi';
-import policyGroupStatusApi from '@api/hss/sslswg/policy/policyGroupStatusApi';
-import { unstable_batchedUpdates } from 'react-dom';
-
-function PolicyDetailUpdateStatusModal({ open, close, modalParams, getStatusList }) {
-  // api 호출 함수, openModal 함수
-  const [apiCall, openModal] = useApi();
-  // 선택한 정책 목록 상태값
-  const [selectedPolicyIdList, setSelectedPolicyIdList] = useState([]);
-  // 현재페이지 상태값
-  const size = 10;
-  const [count, setCount] = useState(10);
-  const [currentPage, setCurrentPage] = useState(1);
-  const [searchAll, setSearchAll] = useState('');
-  const [id, setId] = useState(null);
-  const [title, setTitle] = useState('');
-  const [type, setType] = useState('');
-  // 페이징 상태관리 hook
-  const { items } = usePagination({
-    count: count,
-    page: currentPage,
-  });
-  const [policyList, setPolicyList] = useState([]);
-  const initialSelectedPolicyIdListRef = useRef([]);
-
-  const updatePolicy = useCallback(async () => {
-    const isSameSelection = () => {
-      const initialSelectedPolicyIdList = initialSelectedPolicyIdListRef.current;
-      if (initialSelectedPolicyIdList.length !== selectedPolicyIdList.length) {
-        return false;
-      }
-      const initialSet = new Set(initialSelectedPolicyIdList);
-      const currentSet = new Set(selectedPolicyIdList);
-      return (
-        initialSet.size === currentSet.size && [...initialSet].every((id) => currentSet.has(id))
-      );
-    };
-
-    if (isSameSelection()) {
-      openModal({
-        message: '변경된 정책이 없습니다.',
-      });
-      return false;
-    }
-
-    const params = {
-      id: id,
-      type: type,
-      policyIdList: selectedPolicyIdList,
-    };
-
-    const result = await apiCall(policyGroupStatusApi.updateMappingListWithPolicyGroupId, params);
-    if (result) {
-      openModal({
-        message: `${result.count}건이 처리되었습니다.`,
-      });
-      getStatusList();
-      setSelectedPolicyIdList([]);
-    }
-
-    return true;
-  });
-
-  // 검색조건 입력 변경 이벤트
-  const handleOnChange = (event) => {
-    // 검색조건 변경
-    setSearchAll(event.target.value);
-  };
-  // 정책 삭제 버튼 클릭 이벤트
-  const handleDelete = (policy) => {
-    setSelectedPolicyIdList(
-      selectedPolicyIdList.includes(policy.id)
-        ? selectedPolicyIdList.filter((data) => data !== policy.id)
-        : [...selectedPolicyIdList, policy.id],
-    );
-  };
-
-  const getPolicyList = useCallback(async () => {
-    if (id && type) {
-      const params = {
-        id: id,
-        value: searchAll,
-        contentOnly: true,
-        type: type,
-      };
-
-      const result = await apiCall(policyGroupStatusApi.getMappingListAllWithPolicyGroupId, params);
-      if (result) {
-        const data = result.data ?? [];
-        const totalCount = Math.ceil(data.length / size);
-
-        const typeMapping = {
-          url: 'URL',
-          site: '도메인',
-          regexpheader: 'HEADER',
-          regexppayload: 'PAYLOAD',
-          regexpurl: 'URL',
-          srcip: '출발지IP',
-        };
-
-        const formattedData = data.map((item) => ({
-          ...item,
-          type: typeMapping[item.type] || item.type?.toUpperCase(), // 매핑되지 않은 값은 대문자로 변환
-        }));
-
-        unstable_batchedUpdates(() => {
-          setPolicyList(formattedData);
-          setCount(totalCount === 0 ? 1 : totalCount);
-          if (selectedPolicyIdList.length <= 0) {
-            const initiallySelectedIds = data
-              .filter((policy) => policy.inUsed === 1)
-              .map((policy) => policy.id);
-            setSelectedPolicyIdList(initiallySelectedIds);
-            initialSelectedPolicyIdListRef.current = initiallySelectedIds;
-          }
-        });
-      }
-    }
-  }, [apiCall, id, searchAll, size, currentPage, type]);
-
-  useEffect(() => {
-    const { id, type } = modalParams;
-    if (id && type) {
-      const titleMap = {
-        site: '사이트',
-        pattern: '패턴',
-        srcip: '출발지IP',
-      };
-
-      unstable_batchedUpdates(() => {
-        setId(id);
-        setType(type);
-        setTitle(titleMap[type?.trim()] ?? '기본');
-      });
-    }
-  }, [modalParams]);
-
-  const requestParams = useMemo(() => {
-    if (id && type) {
-      return { id, type, currentPage };
-    }
-    return null;
-  }, [id, type, currentPage]);
-
-  useEffect(() => {
-    if (requestParams) {
-      getPolicyList(requestParams);
-    }
-  }, [requestParams]);
-
-  // JSX
-  return (
-    <>
-      <PopUp
-        title={`${title} 정책 설정`}
-        alertOpen={open}
-        closeAlert={close}
-        fullWidth
-        maxWidth="md"
-        callBack={updatePolicy}
-      >
-        <Stack spacing={1}>
-          <GridItem container directionHorizon="space-between">
-            <GridItem item sx={{ width: '50%' }}>
-              <OutlinedInput
-                size="small"
-                name="searchAll"
-                type="search"
-                sx={{ ml: '15px', width: '80%' }}
-                value={searchAll}
-                onChange={handleOnChange}
-                placeholder="정책명 또는 그룹명"
-                onKeyDown={(e) => {
-                  if (e.key === 'Enter') {
-                    getPolicyList();
-                  }
-                }}
-              />
-              <Button
-                sx={{ ml: '10px', height: '30px' }}
-                variant="contained"
-                color="primary"
-                onClick={getPolicyList}
-              >
-                검색
-              </Button>
-            </GridItem>
-            <GridItem item>
-              <Stack direction="row">
-                <ButtonSet
-                  sx={{ height: '30px' }}
-                  options={[
-                    {
-                      label: '선택 초기화',
-                      color: 'secondary',
-                      variant: 'outlined',
-                      callBack: () => setSelectedPolicyIdList([]),
-                    },
-                    {
-                      label: '전체 선택',
-                      color: 'secondary',
-                      variant: 'contained',
-                      callBack: () => {
-                        setSelectedPolicyIdList(policyList.map((policy) => policy.id));
-                      },
-                    },
-                  ]}
-                />
-              </Stack>
-            </GridItem>
-          </GridItem>
-          <GridItem divideColumn={4} spacing={1}>
-            <GridItem item colSpan={2}>
-              <Typography variant="subtitle1" sx={{ ml: 1 }}>
-                {title} 정책 리스트
-              </Typography>
-              <List dense>
-                {policyList.length !== 0 ? (
-                  policyList
-                    .slice((currentPage - 1) * size, (currentPage - 1) * size + size)
-                    .map((policy) => (
-                      <Fragment key={policy.id}>
-                        <ListItem
-                          secondaryAction={
-                            <IconButton
-                              sx={{ '& svg': { width: '1.3rem' } }}
-                              edge="end"
-                              onClick={() => handleDelete(policy)}
-                            >
-                              {selectedPolicyIdList.includes(policy.id) ? (
-                                <RemoveCircle color="secondary" />
-                              ) : (
-                                <AddCircle color="primary" />
-                              )}
-                            </IconButton>
-                          }
-                        >
-                          <ListItemAvatar sx={{ minWidth: '40px' }}>
-                            <Avatar
-                              sx={{
-                                width: '25px',
-                                height: '25px',
-
-                                '& .anticon-policy > svg ': { width: '0.8em !important' },
-                              }}
-                            >
-                              <UserOutlined />
-                            </Avatar>
-                          </ListItemAvatar>
-                          <ListItemText
-                            primaryTypographyProps={{ variant: 'h6' }}
-                            primary={`${policy.name} / ${policy.type}${
-                              policy.level === 2 ? ' (G)' : ''
-                            }`}
-                          />
-                        </ListItem>
-                        <Divider />
-                      </Fragment>
-                    ))
-                ) : (
-                  <ListItem>
-                    <ListItemText
-                      primaryTypographyProps={{ variant: 'h6' }}
-                      primary="조건에 맞는 정책이 존재하지 않습니다."
-                    />
-                  </ListItem>
-                )}
-
-                <Stack direction="row" justifyContent="center" alignItems="center">
-                  {items.map(({ page, type, ...item }) => {
-                    if (type === 'next') {
-                      return (
-                        <IconButton
-                          key={type}
-                          onClick={() =>
-                            setCurrentPage(currentPage !== count ? currentPage + 1 : currentPage)
-                          }
-                        >
-                          <ChevronRight />
-                        </IconButton>
-                      );
-                    } else if (type === 'previous') {
-                      return (
-                        <IconButton
-                          key={type}
-                          onClick={() =>
-                            setCurrentPage(currentPage !== 1 ? currentPage - 1 : currentPage)
-                          }
-                        >
-                          <ChevronLeft />
-                        </IconButton>
-                      );
-                    } else if (type === 'page' && page === currentPage) {
-                      return (
-                        <Typography key={type} {...item}>
-                          {page} / {count}
-                        </Typography>
-                      );
-                    }
-                  })}
-                </Stack>
-              </List>
-            </GridItem>
-            <GridItem item colSpan={2} sx={{ height: '430px', overflow: 'auto' }}>
-              <GridItem direction="row" alignItems="center" sx={{ ml: 1 }}>
-                <GridItem direction="row" sx={{ mb: 1 }}>
-                  <Typography variant="subtitle1">{title} 정책 선택&nbsp;&nbsp;&nbsp;</Typography>
-                  <Typography color="primary">{selectedPolicyIdList.length}</Typography>
-                </GridItem>
-                <GridItem direction="row">
-                  <Stack
-                    direction="column"
-                    justifyContent="left"
-                    spacing={1}
-                    alignItems="flex-start"
-                  >
-                    {selectedPolicyIdList.map((selectedPolicy) => {
-                      const policy = policyList.find((policy) => policy.id === selectedPolicy);
-                      if (policy) {
-                        return (
-                          <Chip
-                            sx={{ '& .MuiChip-deleteIcon': { width: '0.7em' } }}
-                            key={policy.id}
-                            icon={<UserOutlined />}
-                            variant="contained"
-                            color="secondary"
-                            onDelete={() => handleDelete(policy)}
-                            label={`${policy.name} / ${policy.type}${
-                              policy.level === 2 ? ' (G)' : ''
-                            }`}
-                          />
-                        );
-                      }
-                    })}
-                  </Stack>
-                </GridItem>
-              </GridItem>
-            </GridItem>
-          </GridItem>
-        </Stack>
-      </PopUp>
-      {/* {console.log('정책선택 화면로딩... ')} */}
-    </>
-  );
-}
-
-PolicyDetailUpdateStatusModal.getLayout = function getLayout(page) {
-  return <Layout>{page}</Layout>;
-};
-
-export default PolicyDetailUpdateStatusModal;
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/policyGroupStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/policyGroupStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/policyGroupStatusModal.jsx	2025-03-14 18:07:35.829739200 +0900
+++ .\src\/components/modal/hss/sslswg/policy/policyGroupStatusModal.jsx	2025-03-05 15:06:33.330965400 +0900
@@ -1,47 +1,80 @@
 import { useEffect, useState } from 'react';
+import { useSelector } from 'react-redux';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
 import GridItem from '@components/modules/grid/GridItem';
 import LabelInput from '@components/modules/input/LabelInput';
+import MultipleSelect from '@components/modules/select/multipleSelect';
 import useApi from '@modules/hooks/useApi';
 import { AuthInstance } from '@modules/axios';
 import policyGroupStatusApi from '@api/hss/sslswg/policy/policyGroupStatusApi';
+import { Typography } from '@mui/material';
 import Loader from '@components/mantis/Loader';
-import { useSelector } from 'react-redux';
-import timeGroupStatusApi from '@api/hss/sslswg/policy/policyDetailManage/timeGroupStatusApi';
-import timeStatusApi from '@api/hss/sslswg/policy/policyDetailManage/timeStatusApi';
-import { Typography, Box } from '@mui/material';
 
 function PolicyGroupStatusModal(props) {
-  const { alertOpen, setModalOpen, modalParams, getPolicyGroupStatusList } = props;
+  const {
+    alertOpen,
+    setModalOpen,
+    modalParams,
+    getPolicyGroupStatusList,
+    policyDetailGroupList = [],
+    policyDetailList = [],
+  } = props;
   const { flag, id } = modalParams;
   const { instance, source } = AuthInstance();
-  const parameterData = useSelector((state) => state.swgPolicyGroupStatus);
-  const { segmentNameList, timeNameList } = parameterData;
 
   policyGroupStatusApi.axios = instance;
-  timeGroupStatusApi.axios = instance;
-  timeStatusApi.axios = instance;
 
   const [apiCall, openModal] = useApi();
-  const [isDisabled, setIsDisabled] = useState(false);
+
+  const { segmentNameList } = useSelector((state) => state.swgPolicyGroupStatus);
+
+  const [domainGroupValue, setDomainGroupValue] = useState([]);
+  const [selectedDomainGroupList, setSelectedDomainGroupList] = useState([]);
+  const [isChangedDomainGroupList, setIsChangedDomainGroupList] = useState(false);
+
+  const [urlGroupValue, setUrlGroupValue] = useState([]);
+  const [selectedUrlGroupList, setSelectedUrlGroupList] = useState([]);
+  const [isChangedUrlGroupList, setIsChangedUrlGroupList] = useState(false);
+
+  const [httpHeaderGroupValue, setHttpHeaderGroupValue] = useState([]);
+  const [selectedHttpHeaderGroupList, setSelectedHttpHeaderGroupList] = useState([]);
+  const [isChangedHttpHeaderGroupList, setIsChangedHttpHeaderGroupList] = useState(false);
+
+  const [srcipGroupValue, setSrcipGroupValue] = useState([]);
+  const [selectedSrcipGroupList, setSelectedSrcipGroupList] = useState([]);
+  const [isChangedSrcipGroupList, setIsChangedSrcipGroupList] = useState(false);
+
+  const [timeGroupValue, setTimeGroupValue] = useState([]);
+  const [selectedTimeGroupList, setSelectedTimeGroupList] = useState([]);
+  const [isChangedTimeGroupList, setIsChangedTimeGroupList] = useState(false);
+
+  const [payloadGroupValue, setPayloadGroupValue] = useState([]);
+  const [selectedPayloadGroupList, setSelectedPayloadGroupList] = useState([]);
+  const [isChangedPayloadGroupList, setIsChangedPayloadGroupList] = useState(false);
+
   const [isLoading, setIsLoading] = useState(false);
-  const [isBanned, setIsBanned] = useState(false);
+  const [isDisabled, setIsDisabled] = useState(false);
 
   const methods = useForm({
     defaultValues: {
       name: '',
       segmentName: '',
-      timeId: '',
-      isBlackList: '',
-      action: '0',
-      description: '',
     },
   });
 
+  const {
+    domainGroupList,
+    urlGroupList,
+    httpHeaderGroupList,
+    srcipGroupList,
+    timeGroupList,
+    payloadGroupList,
+  } = policyDetailGroupList;
+
   useEffect(() => {
     if (flag === 'update') {
-      getPolicyGroupStatusDetail();
+      getPolicyGroupStatusDetails();
       setIsDisabled(true);
     }
 
@@ -50,45 +83,69 @@
     };
   }, []);
 
-  const getPolicyGroupStatusDetail = async () => {
+  const getPolicyGroupStatusDetails = async () => {
     const result = await apiCall(policyGroupStatusApi.getPolicyGroupStatusDetails, id);
 
     for (const key in result) {
       const value = result[`${key}`] ?? null;
+
       if (value === null) {
         methods.setValue(key, '');
       } else {
-        methods.setValue(key, value);
+        if (key === 'banned') {
+          setDomainGroupValue(value?.sslswg_policy_domain_group_uuid ?? []);
+          setUrlGroupValue(value?.sslswg_policy_url_group_uuid ?? []);
+          setHttpHeaderGroupValue(value?.sslswg_policy_http_header_group_uuid ?? []);
+          setSrcipGroupValue(value?.sslswg_policy_srcip_group_uuid ?? []);
+          setTimeGroupValue(value?.sslswg_policy_time_group_uuid ?? []);
+          setPayloadGroupValue(value?.sslswg_policy_payload_group_uuid ?? []);
+        } else {
+          methods.setValue(key, value);
+        }
       }
     }
   };
 
   const saveButtonClick = async (data) => {
-    let result = '';
-
     setIsLoading(true);
+    const result = await apiCall(policyGroupStatusApi.insertPolicyGroupStatusData, data);
 
-    const { name, segmentName, timeId, isBlackList, action, description } = data;
-
-    const convertToBinary = (field) => (field && field.includes('1') ? '1' : '0');
-
-    console.log(timeId);
-
-    const newData = {
-      name: name,
-      segmentName: segmentName,
-      timeId: timeId,
-      isBlackList: isBanned ? convertToBinary(isBlackList) : '0',
-      action: action,
-      description: description,
-    };
-
-    if (flag === 'update') {
-      // result = await apiCall(policyGroupStatusApi.updatePolicyGroupStatusData, newData);
-    } else {
-      result = await apiCall(policyGroupStatusApi.insertPolicyGroupStatusData, newData);
-    }
+    // let newData = {
+    //   ...data,
+    //   banned: [],
+    //   exception: [],
+    // };
+
+    // if (flag === 'update') {
+    //   newData['banned'] = {
+    //     domainGroupIdList:
+    //       isChangedDomainGroupList === true ? selectedDomainGroupList : domainGroupValue,
+    //     urlGroupIdList: isChangedUrlGroupList === true ? selectedUrlGroupList : urlGroupValue,
+    //     httpHeaderGroupIdList:
+    //       isChangedHttpHeaderGroupList === true
+    //         ? selectedHttpHeaderGroupList
+    //         : httpHeaderGroupValue,
+    //     srcipGroupIdList:
+    //       isChangedSrcipGroupList === true ? selectedSrcipGroupList : srcipGroupValue,
+    //     timeGroupIdList: isChangedTimeGroupList ? selectedTimeGroupList : timeGroupValue,
+    //     payloadGroupIdList: isChangedPayloadGroupList
+    //       ? selectedPayloadGroupList
+    //       : payloadGroupValue,
+    //   };
+
+    //   result = await apiCall(policyGroupStatusApi.updatePolicyGroupStatusData, newData);
+    // } else {
+    //   newData['banned'] = {
+    //     domainGroupIdList: selectedDomainGroupList,
+    //     urlGroupIdList: selectedUrlGroupList,
+    //     httpHeaderGroupIdList: selectedHttpHeaderGroupList,
+    //     srcipGroupIdList: selectedSrcipGroupList,
+    //     timeGroupIdList: selectedTimeGroupList,
+    //     payloadGroupIdList: selectedPayloadGroupList,
+    //   };
 
+    //   result = await apiCall(policyGroupStatusApi.insertPolicyGroupStatusData, newData);
+    // }
     setIsLoading(false);
 
     if (result) {
@@ -102,13 +159,41 @@
     }
   };
 
-  useEffect(() => {
-    if (methods.getValues('action') === '0') {
-      setIsBanned(true);
-    } else {
-      setIsBanned(false);
-    }
-  }, [methods.watch('action')]);
+  const onDomainGroupValueChange = (selectList) => {
+    const selectDomainGroupList = selectList.map((data) => data.id);
+    setSelectedDomainGroupList(selectDomainGroupList);
+    setIsChangedDomainGroupList(true);
+  };
+
+  const onUrlGroupValueChange = (selectList) => {
+    const selectUrlGroupList = selectList.map((data) => data.id);
+    setSelectedUrlGroupList(selectUrlGroupList);
+    setIsChangedUrlGroupList(true);
+  };
+
+  const onHttpHeaderGroupValueChange = (selectList) => {
+    const selectHttpHeaderGroupList = selectList.map((data) => data.id);
+    setSelectedHttpHeaderGroupList(selectHttpHeaderGroupList);
+    setIsChangedHttpHeaderGroupList(true);
+  };
+
+  const onSrcipGroupValueChange = (selectList) => {
+    const selectSrcipGroupList = selectList.map((data) => data.id);
+    setSelectedSrcipGroupList(selectSrcipGroupList);
+    setIsChangedSrcipGroupList(true);
+  };
+
+  const onTimeGroupValueChange = (selectList) => {
+    const selectTimeGroupList = selectList.map((data) => data.id);
+    setSelectedTimeGroupList(selectTimeGroupList);
+    setIsChangedTimeGroupList(true);
+  };
+
+  const onPayloadGroupValueChange = (selectList) => {
+    const selectPayloadGroupList = selectList.map((data) => data.id);
+    setSelectedPayloadGroupList(selectPayloadGroupList);
+    setIsChangedPayloadGroupList(true);
+  };
 
   return (
     <PopUp
@@ -117,14 +202,13 @@
       alertOpen={alertOpen}
       closeAlert={setModalOpen}
       callBack={methods.handleSubmit(saveButtonClick)}
-      title={`정책 그룹 ${flag === 'insert' ? '작성' : '확인'}`}
+      title={`정책 그룹 ${flag === 'insert' ? '작성' : '수정'}`}
       confirmLabel="저장"
-      {...(flag === 'update' && { cancelLabel: '확인' })}
       disableConfirm={isDisabled}
     >
       {isLoading && <Loader isGuard />}
       <FormProvider {...methods}>
-        <form id="policyGroupStatusModal">
+        <form id="payloadStatusModal">
           <GridItem
             direction="row"
             divideColumn={2}
@@ -139,67 +223,16 @@
               required
               label="그룹명"
               name="name"
-              maxLength={255}
               disabled={isDisabled}
-              sx={{
-                '.inputBox': { width: '800px' },
-              }}
-              colSpan={2}
               labelBackgroundFlag
             />
             <LabelInput
               required
-              type="select"
-              label="SSL VA<br/>[세그먼트]"
+              label="세그먼트명"
               name="segmentName"
-              list={segmentNameList}
-              labelBackgroundFlag
-              labelSx={{ textAlign: 'right' }}
-            />
-            <LabelInput
-              required
-              type="radio"
-              label="처리 방식"
-              name="action"
-              list={[
-                { label: '차단', value: '0' },
-                { label: '허용', value: '1' },
-              ]}
-              labelBackgroundFlag
-            />
-            <LabelInput
-              type="select"
-              label="스케줄 정책"
-              name="timeId"
-              list={timeNameList}
-              labelBackgroundFlag
-            />
-            <LabelInput
-              type="checkbox"
-              label="블랙리스트 정책"
-              name="isBlackList"
-              list={[{ label: '적용', value: '1', disabled: !isBanned }]}
-              labelBackgroundFlag
-            />
-            <LabelInput
-              label="설명"
-              name="description"
-              maxLength={1024}
               disabled={isDisabled}
-              sx={{
-                '.inputBox': { width: '800px' },
-              }}
               labelBackgroundFlag
-              colSpan={2}
             />
-            <Box colSpan={2} sx={{ p: 2, backgroundColor: '#FAFAFA' }}>
-              <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
-                [블랙리스트 정책]
-              </Typography>
-              <Typography variant="body2">
-                - 블랙리스트 정책은 1개의 그룹만 적용할 수 있습니다.
-              </Typography>
-            </Box>
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/siteGroupStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/siteGroupStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/siteGroupStatusModal.jsx	2025-03-12 13:30:03.190866800 +0900
+++ .\src\/components/modal/hss/sslswg/policy/siteGroupStatusModal.jsx	2025-03-05 15:06:33.330965400 +0900
@@ -100,8 +100,8 @@
               label="유형"
               name="type"
               list={[
-                { label: '도메인', value: 'site' },
-                { label: 'URL', value: 'url' },
+                { label: '전체 도메인', value: 'site' },
+                { label: '특정 URL', value: 'url' },
               ]}
             />
             <LabelInput
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/siteStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/siteStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/siteStatusModal.jsx	2025-03-12 13:30:03.191380100 +0900
+++ .\src\/components/modal/hss/sslswg/policy/siteStatusModal.jsx	2025-03-05 15:06:33.331965600 +0900
@@ -7,7 +7,6 @@
 import { AuthInstance } from '@modules/axios';
 import siteStatusApi from '@api/hss/sslswg/policy/policyDetailManage/siteStatusApi';
 import Loader from '@components/mantis/Loader';
-import { Typography, Box } from '@mui/material';
 
 function SiteStatusModal(props) {
   const { alertOpen, setModalOpen, modalParams, getSiteStatusList } = props;
@@ -29,8 +28,6 @@
     },
   });
 
-  const type = methods.watch('type');
-
   useEffect(() => {
     if (flag === 'update') {
       getSiteStatusDetail();
@@ -136,8 +133,8 @@
               label="유형"
               name="type"
               list={[
-                { label: '도메인', value: 'site', disabled: isDisabled },
-                { label: 'URL', value: 'url', disabled: isDisabled },
+                { label: '전체 도메인', value: 'site', disabled: isDisabled },
+                { label: '특정 URL', value: 'url', disabled: isDisabled },
               ]}
             />
             <LabelInput
@@ -161,51 +158,8 @@
               sx={{
                 '.inputBox': { width: '800px' },
               }}
-              onlySite={type === 'site'}
-              onlyUrl={type === 'url'}
               labelBackgroundFlag
             />
-            <Box colSpan={2} sx={{ p: 2, backgroundColor: '#FAFAFA' }}>
-              <Typography variant="body2" fontWeight="bold">
-                [유형] 정책을 적용할 대상의 범위를 선택하세요.
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 1, fontWeight: 'bold' }}>
-                도메인:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 특정 도메인에 대해 정책을 적용합니다.
-                <br />
-                - 입력한 도메인의 모든 서브도메인에도 적용됩니다.
-                <br />
-                예) <code>hanssak.co.kr</code>을 입력하면 <code>www.hanssak.co.kr</code>,{' '}
-                <code>sub.hanssak.co.kr</code>도 포함됩니다.
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2, color: 'red' }}>
-                - 도메인만 입력하세요. (예: <code>hanssak.co.kr</code>)<br />
-                - `http://`, `https://`는 입력하지 마세요.
-                <br />
-                - 특정 경로(예: `/login`)는 입력할 수 없습니다.
-                <br />- IP 주소(예: `192.168.1.1`)는 사용하지 마세요.
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                URL:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 특정 URL에 대해 정책을 적용합니다.
-                <br />
-                - 입력한 URL이 정확히 일치하는 경우에만 차단됩니다.
-                <br />
-                예) <code>https://hanssak.co.kr/login</code>을 입력하면 <code>hanssak.co.kr</code>의
-                로그인 페이지에만 적용됩니다.
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2, color: 'red' }}>
-                - URL을 입력하세요. (예: <code>hanssak.co.kr/login</code>)<br />
-                - `http://`, `https://`는 입력하지 마세요.
-                <br />- IP 주소(예: `192.168.1.1`)는 사용하지 마세요.
-              </Typography>
-            </Box>
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/srcIpStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/srcIpStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/srcIpStatusModal.jsx	2025-03-12 13:30:03.193435100 +0900
+++ .\src\/components/modal/hss/sslswg/policy/srcIpStatusModal.jsx	2025-03-11 18:10:42.181930900 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState, useRef } from 'react';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
 import GridItem from '@components/modules/grid/GridItem';
@@ -8,7 +8,6 @@
 import { AuthInstance } from '@modules/axios';
 import srcIpStatusApi from '@api/hss/sslswg/policy/policyDetailManage/srcIpStatusApi';
 import Loader from '@components/mantis/Loader';
-import { Typography, Box } from '@mui/material';
 
 function SrcIpStatusModal(props) {
   const { alertOpen, setModalOpen, modalParams, getSrcIpStatusList } = props;
@@ -34,7 +33,15 @@
     },
   });
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed.current) return;
     if (flag === 'update') {
       getSrcIpStatusDetail();
       setIsDisabled(true);
@@ -125,6 +132,7 @@
   };
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;
     const inputType = methods.getValues('inputType');
     setIsRangeEnabled(inputType === 'range');
     setIsBlockEnabled(inputType === 'cidr');
@@ -139,7 +147,6 @@
       callBack={methods.handleSubmit(saveButtonClick)}
       title={`출발지IP ${flag === 'insert' ? '작성' : '확인'}`}
       confirmLabel="저장"
-      {...(flag === 'update' && { cancelLabel: '확인' })}
       disableConfirm={isDisabled}
     >
       {isLoading && <Loader isGuard />}
@@ -213,51 +220,6 @@
               colSpan={2}
               labelBackgroundFlag
             />
-            <Box colSpan={2} sx={{ p: 2, backgroundColor: '#FAFAFA' }}>
-              <Typography variant="body2" fontWeight="bold">
-                [입력 타입] 정책을 적용할 IP 범위를 선택하세요.
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 1, fontWeight: 'bold' }}>
-                단일:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 특정 IP 주소 한 개에 대해 정책을 적용합니다.
-                <br />
-                - 입력한 단일 IP에 대해 차단 또는 허용 정책을 설정할 수 있습니다.
-                <br />
-                예) 192.168.1.100
-                <br />
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                범위:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 연속된 IP 주소 범위에 대해 정책을 적용합니다.
-                <br />
-                - 시작 IP와 끝 IP를 입력하여 해당 범위에 속하는 모든 IP에 정책을 적용할 수 있습니다.
-                <br />
-                예) 192.168.1.10 - 192.168.1.50 → 192.168.1.10부터 192.168.1.50까지 모든 IP 적용
-                <br />
-                203.0.113.1 - 203.0.113.255 → 특정 공인 IP 대역 적용
-                <br />
-              </Typography>
-
-              <Typography variant="body2" sx={{ mt: 1, fontWeight: 'bold' }}>
-                CIDR:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - IP 주소 블록 전체에 대해 정책을 적용합니다. <br />
-                - CIDR 표기법을 사용하여 특정 네트워크 대역을 차단하거나 허용할 수 있습니다.
-                <br />
-                예) 192.168.1.0/24 → 192.168.1.1 ~ 192.168.1.255 포함
-                <br />
-                203.0.113.0/26 → 203.0.113.0 ~ 203.0.113.63 포함
-                {/* <br /> */}
-                {/* 10.0.0.0/8 → 10.0.0.0 ~ 10.255.255.255 포함 */}
-              </Typography>
-            </Box>
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/timeGroupStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/timeGroupStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/timeGroupStatusModal.jsx	2025-03-12 13:30:03.194092800 +0900
+++ .\src\/components/modal/hss/sslswg/policy/timeGroupStatusModal.jsx	2025-03-05 15:06:33.333965500 +0900
@@ -20,6 +20,7 @@
   const methods = useForm({
     defaultValues: {
       name: '',
+      action: '0',
     },
   });
 
@@ -34,10 +35,11 @@
 
     setIsLoading(true);
 
-    const { name } = data;
+    const { name, action } = data;
 
     const newData = {
       name: name,
+      action: action,
     };
 
     result = await apiCall(timeGroupStatusApi.insertTimeGroupStatusData, newData);
@@ -89,6 +91,17 @@
               }}
               labelBackgroundFlag
             />
+            <LabelInput
+              required
+              type="radio"
+              labelBackgroundFlag
+              label="처리 방식"
+              name="action"
+              list={[
+                { label: '차단', value: '0' },
+                { label: '허용', value: '1' },
+              ]}
+            />
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslswg/policy/timeStatusModal.jsx .\src\/components/modal/hss/sslswg/policy/timeStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslswg/policy/timeStatusModal.jsx	2025-03-12 13:30:03.195639600 +0900
+++ .\src\/components/modal/hss/sslswg/policy/timeStatusModal.jsx	2025-03-05 15:06:33.334965300 +0900
@@ -5,10 +5,10 @@
 import LabelInput from '@components/modules/input/LabelInput';
 import useApi from '@modules/hooks/useApi';
 import { AuthInstance } from '@modules/axios';
+import { Stack } from '@mui/material';
 import timeStatusApi from '@api/hss/sslswg/policy/policyDetailManage/timeStatusApi';
 import moment from 'moment';
 import Loader from '@components/mantis/Loader';
-import { Typography, Box } from '@mui/material';
 
 function TimeStatusModal(props) {
   const { alertOpen, setModalOpen, modalParams, getTimeStatusList } = props;
@@ -27,6 +27,7 @@
       startTime: '0000',
       endTime: '0000',
       days: [],
+      action: '0',
     },
   });
 
@@ -76,6 +77,8 @@
         if (key === 'days') {
           const restoredDays = convertDaysToArray(value);
           methods.setValue(key, restoredDays);
+        } else if (key === 'action') {
+          methods.setValue(key, String(value));
         } else {
           methods.setValue(key, value);
         }
@@ -126,6 +129,7 @@
 
     const newData = {
       name: data.name,
+      action: data.action,
       startTimeHour: data.startTimeHour ?? '00',
       startTimeMin: data.startTimeMin ?? '00',
       endTimeHour: data.endTimeHour ?? '00',
@@ -161,7 +165,6 @@
       callBack={methods.handleSubmit(saveButtonClick)}
       title={`스케줄 ${flag === 'insert' ? '작성' : '확인'}`}
       confirmLabel="저장"
-      {...(flag === 'update' && { cancelLabel: '확인' })}
       disableConfirm={isDisabled}
     >
       {isLoading && <Loader isGuard />}
@@ -198,6 +201,18 @@
             />
             <LabelInput
               required
+              type="radio"
+              labelBackgroundFlag
+              label="처리 방식"
+              name="action"
+              colSpan={2}
+              list={[
+                { label: '차단', value: '0', disabled: isDisabled },
+                { label: '허용', value: '1', disabled: isDisabled },
+              ]}
+            />
+            <LabelInput
+              required
               type="checkbox"
               label="적용 요일"
               name="days"
@@ -234,45 +249,6 @@
               inputFormat="HH:mm"
               disabled={isDisabled}
             />
-            <Box colSpan={2} sx={{ p: 2, backgroundColor: '#FAFAFA' }}>
-              <Typography variant="body2" fontWeight="bold">
-                적용할 요일과 시간을 설정하세요.
-              </Typography>
-
-              {/* 적용 요일 설명 */}
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                [적용 요일]
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 스케줄을 적용할 요일을 선택하세요.
-                <br />- 최소 <strong>1개 이상의 요일</strong>을 선택해야 합니다.
-                <br />
-                예) 월, 화, 수 → 월요일~수요일 동안 적용
-                <br />
-                금, 토 → 금요일과 토요일만 적용
-              </Typography>
-
-              {/* 시작 시간 & 종료 시간 설명 */}
-              <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold' }}>
-                시작 시간 & 종료 시간:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2 }}>
-                - 스케줄이 <strong>적용될 시간 범위</strong>를 설정하세요.
-                <br />
-                - 시작 시간은 종료 시간보다 앞서야 합니다.
-                <br />
-                예) <code>08:00 ~ 18:00</code> → 오전 8시부터 오후 6시까지 적용
-                <br />
-                <code>22:00 ~ 06:00</code> → 오후 10시부터 다음날 오전 6시까지 적용 (야간 적용 가능)
-              </Typography>
-              {/* <Typography variant="body2" sx={{ mt: 2, fontWeight: 'bold', color: 'red' }}>
-                ⚠️ 주의 사항:
-              </Typography>
-              <Typography variant="body2" sx={{ ml: 2, color: 'red' }}>
-                - 스케줄이 하루를 넘어갈 경우 (`22:00 ~ 06:00`) 시스템에서 자동으로 처리됩니다.
-                <br />- 적용 요일과 시간이 겹치는 정책이 있을 경우, 우선순위를 확인하세요.
-              </Typography> */}
-            </Box>
           </GridItem>
         </form>
       </FormProvider>
diff -urN ..\hss-frontend\src\/components/modal/hss/sslva/policy/policyDetailStatusModal.jsx .\src\/components/modal/hss/sslva/policy/policyDetailStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslva/policy/policyDetailStatusModal.jsx	2025-03-12 13:30:03.196152900 +0900
+++ .\src\/components/modal/hss/sslva/policy/policyDetailStatusModal.jsx	2025-03-05 14:20:47.478625900 +0900
@@ -18,7 +18,7 @@
 
   policyDetailStatusApi.axios = instance;
 
-  const protocolTypeList = useSelector((state) => state.policyDetailStatus.protocolTypeList);
+  const protocolNameList = useSelector((state) => state.protocolStatus.protocolList);
 
   const [apiCall, openModal] = useApi();
   const [protocolValue, setProtocolValue] = useState([]);
@@ -32,16 +32,16 @@
   const methods = useForm({
     defaultValues: {
       name: '',
-      protocolTypeId: '',
+      protocol: '',
       protocolIdList: [],
-      passthrough: [0],
-      verifyPeer: [0],
-      validateProto: [0],
-      denyOcsp: [0],
-      userAuth: [0],
-      linked: [0],
+      passthrough: ['0'],
+      verifyPeer: ['0'],
+      validateProto: ['0'],
+      denyOcsp: ['0'],
+      userAuth: ['0'],
+      linked: ['0'],
       userTimeout: 3600,
-      userAuthUrl: '',
+      userAuthUrl: 'https://auth.hanssak.co.kr',
     },
   });
 
@@ -57,22 +57,24 @@
 
   useEffect(() => {
     if (flag === 'update') {
-      if (methods.getValues().userAuth == 1) {
+      if (methods.getValues().userAuth == '1') {
         setUserAuthChecked(true);
       }
     }
   }, [methods.watch().userAuth]);
 
+  useEffect(() => {
+    const type = methods.getValues('protocol');
+
+    const newProtocolList = protocolList.filter((item) => {
+      return type === item.protocol; // 조건을 만족하는 항목만 유지
+    });
+
+    setProtocolToProtocolList(newProtocolList);
+  }, [methods.watch('protocol')]);
+
   const getPolicyDetailStatusDetail = async () => {
     const result = await apiCall(policyDetailStatusApi.getPolicyDetailStatusDetails, id);
-    const booleanKeys = [
-      'passthrough',
-      'verifyPeer',
-      'validateProto',
-      'denyOcsp',
-      'userAuth',
-      'linked',
-    ];
 
     for (const key in result) {
       const value = result[`${key}`] ?? null;
@@ -81,9 +83,8 @@
         methods.setValue(key, '');
       } else {
         if (key === 'protocolIdList') {
-          setProtocolValue(value);
-        } else if (booleanKeys.includes(key)) {
-          methods.setValue(key, [value]);
+          const pList = value ?? [];
+          setProtocolValue(pList);
         } else {
           methods.setValue(key, value);
         }
@@ -97,12 +98,12 @@
     setIsLoading(true);
 
     if (isUserAuthChecked === true) {
-      data.userAuth = [1];
+      data.userAuth = ['1'];
     } else {
-      data.userAuth = [0];
+      data.userAuth = ['0'];
     }
 
-    const convertToBinary = (field) => (field && field.includes(1) ? 1 : 0);
+    const convertToBinary = (field) => (field && field.includes('1') ? 1 : 0);
     data = {
       ...data,
       passthrough: convertToBinary(data.passthrough),
@@ -178,20 +179,13 @@
   };
 
   useEffect(() => {
-    const typeId = methods.getValues('protocolTypeId');
-
-    const newProtocolList = protocolList.filter((item) => item.protocolTypeId === typeId); // 조건을 만족하는 항목만 유지
-    setProtocolToProtocolList(newProtocolList);
-
-    const matchedType = protocolTypeList.find((item) => item.value === typeId);
-    const typeLabel = matchedType ? matchedType.label.toLowerCase() : '';
-
-    if (['smtps', 'https', 'pop3'].includes(typeLabel)) {
+    const protocol = methods.getValues('protocol');
+    if (protocol === 'smtps' || protocol === 'https' || protocol === 'pop3') {
       setIsDisabledProtocol(false);
     } else {
       setIsDisabledProtocol(true);
     }
-  }, [methods.watch('protocolTypeId')]);
+  }, [methods.watch('protocol')]);
 
   return (
     <PopUp
@@ -234,9 +228,9 @@
             <LabelInput
               required
               type="select"
-              list={protocolTypeList}
+              list={protocolNameList}
               label="프로토콜"
-              name="protocolTypeId"
+              name="protocol"
               disabledefault
               labelBackgroundFlag
             />
@@ -272,35 +266,35 @@
               type="checkbox"
               label="인증서 검증"
               name="verifyPeer"
-              list={[{ label: '사용', value: 1 }]}
+              list={[{ label: '사용', value: '1' }]}
               labelBackgroundFlag
             />
             <LabelInput
               type="checkbox"
               label="프로토콜 검증"
               name="validateProto"
-              list={[{ label: '사용', value: 1, disabled: isDisabledProtocol }]}
+              list={[{ label: '사용', value: '1', disabled: isDisabledProtocol }]}
               labelBackgroundFlag
             />
             <LabelInput
               type="checkbox"
               label="외부 연동"
               name="linked"
-              list={[{ label: '사용', value: 1 }]}
+              list={[{ label: '사용', value: '1' }]}
               labelBackgroundFlag
             />
             {/* <LabelInput
               type="checkbox"
               label="패스스루"
               name="passthrough"
-              list={[{ label: '사용', value: 1 }]}
+              list={[{ label: '사용', value: '1' }]}
               labelBackgroundFlag
             />
             <LabelInput
               type="checkbox"
               label="OCSP 거부"
               name="denyOcsp"
-              list={[{ label: '사용', value: 1 }]}
+              list={[{ label: '사용', value: '1' }]}
               labelBackgroundFlag
             />
             <LabelInput
@@ -312,7 +306,7 @@
                 {
                   checked: isUserAuthChecked,
                   label: '사용',
-                  value: 1,
+                  value: '1',
                 },
               ]}
               labelBackgroundFlag
diff -urN ..\hss-frontend\src\/components/modal/hss/sslva/policy/protocolStatusModal.jsx .\src\/components/modal/hss/sslva/policy/protocolStatusModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslva/policy/protocolStatusModal.jsx	2025-03-12 13:30:03.197183000 +0900
+++ .\src\/components/modal/hss/sslva/policy/protocolStatusModal.jsx	2025-03-05 14:20:47.479654000 +0900
@@ -16,7 +16,7 @@
 
   protocolStatusApi.axios = instance;
 
-  const protocolTypeList = useSelector((state) => state.protocolStatus.protocolTypeList);
+  const defaultProtocolList = useSelector((state) => state.protocolStatus.protocolList);
   const [protocolList, setProtocolList] = useState([]);
 
   const [apiCall, openModal] = useApi();
@@ -26,17 +26,17 @@
   const methods = useForm({
     defaultValues: {
       name: '',
-      protocolTypeId: '',
+      protocol: '',
       port: '',
     },
   });
 
   useEffect(() => {
-    setProtocolList(protocolTypeList);
-
     if (flag === 'update') {
       getProtocolStatusDetail();
       setIsDisabled(true);
+    } else {
+      setProtocolList(defaultProtocolList);
     }
   }, []);
 
@@ -49,6 +49,11 @@
       if (value === null) {
         methods.setValue(key, '');
       } else {
+        if (key === 'protocol') {
+          const protocolId = value;
+          const protocolName = value.toUpperCase();
+          setProtocolList([{ value: protocolId, label: protocolName }]);
+        }
         methods.setValue(key, value);
       }
     }
@@ -120,7 +125,7 @@
               required
               type="select"
               label="프로토콜"
-              name="protocolTypeId"
+              name="protocol"
               list={protocolList}
               disabled={isDisabled}
               labelBackgroundFlag
diff -urN ..\hss-frontend\src\/components/modal/hss/sslvpn/userModal.jsx .\src\/components/modal/hss/sslvpn/userModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslvpn/userModal.jsx	2025-02-19 14:50:03.864809100 +0900
+++ .\src\/components/modal/hss/sslvpn/userModal.jsx	2025-03-11 16:50:47.763804300 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState,useRef } from 'react';
 import { useSelector } from 'react-redux';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
@@ -60,7 +60,17 @@
     setIsAccountValueChange(true);
   };
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
     getGroupList();
     getAccountList();
 
diff -urN ..\hss-frontend\src\/components/modal/hss/sslvpn/zoneModal.jsx .\src\/components/modal/hss/sslvpn/zoneModal.jsx
--- ..\hss-frontend\src\/components/modal/hss/sslvpn/zoneModal.jsx	2025-02-19 14:50:03.864809100 +0900
+++ .\src\/components/modal/hss/sslvpn/zoneModal.jsx	2025-03-11 16:20:56.671094700 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState } from 'react';
+import { useEffect, useState,useRef } from 'react';
 // import { useSelector } from 'react-redux';
 import { FormProvider, useForm } from 'react-hook-form';
 import PopUp from '@components/modules/common/PopUp';
@@ -57,7 +57,17 @@
     }
   }, [methods.watch('vpn.config.port')]);
 
+
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     getMakeInfo();
     if (flag === 'update') {
       setIsDisabled(true);
@@ -539,7 +549,7 @@
               minValue={1}
               maxValue={65535}
               onlyNumber
-              placeholder="20001"
+              placeholder={String(vpnConfigPort)}
               labelBackgroundFlag
             />
 
@@ -788,7 +798,7 @@
             <LabelInput
               label="접속 포트"
               name="vpn.client_config.vpnconnectport"
-              placeholder={vpnConfigPort}
+              placeholder={String(vpnConfigPort)}
               labelBackgroundFlag
             />
           </GridItem>
diff -urN ..\hss-frontend\src\/components/modal/quick/QuickMenuItem.jsx .\src\/components/modal/quick/QuickMenuItem.jsx
--- ..\hss-frontend\src\/components/modal/quick/QuickMenuItem.jsx	2024-10-18 16:27:14.086298200 +0900
+++ .\src\/components/modal/quick/QuickMenuItem.jsx	2025-03-10 17:42:29.949378200 +0900
@@ -28,17 +28,17 @@
       ...draggableStyle,
     };
   };
-
+  const nodeRef = useRef(null);
   return (
     <>
       {item && (
-        <Draggable key={item.id} draggableId={item.id} index={index}>
+        <Draggable nodeRef={nodeRef} key={item.id} draggableId={item.id} index={index}>
           {(provided, snapshot) => {
             const usePortal = snapshot.isDragging;
 
             const child = (
               <div
-                ref={provided.innerRef}
+                ref={nodeRef}
                 {...provided.draggableProps}
                 {...provided.dragHandleProps}
                 style={getDragWrapper(
diff -urN ..\hss-frontend\src\/components/modal/streaming/policyModal.jsx .\src\/components/modal/streaming/policyModal.jsx
--- ..\hss-frontend\src\/components/modal/streaming/policyModal.jsx	2024-10-18 16:27:14.088978100 +0900
+++ .\src\/components/modal/streaming/policyModal.jsx	2025-03-08 16:19:47.985991100 +0900
@@ -142,7 +142,6 @@
   };
   // 목적지IP 클릭 이벤트
   const handleClickDestinationIP = (flag, item) => {
-    // console.log(item);
     setObjectModalParams({ flag: flag, id: item });
     setObjectModalOpen(true);
   };
diff -urN ..\hss-frontend\src\/components/modal/system/group/groupModal.jsx .\src\/components/modal/system/group/groupModal.jsx
--- ..\hss-frontend\src\/components/modal/system/group/groupModal.jsx	2024-10-18 16:27:14.092980500 +0900
+++ .\src\/components/modal/system/group/groupModal.jsx	2025-03-08 17:26:05.818299500 +0900
@@ -1,6 +1,6 @@
 // libraries
 import { FormProvider, useForm } from 'react-hook-form';
-import { useEffect, useState } from 'react';
+import { useEffect, useState,useRef } from 'react';
 // components
 import PopUp from '@components/modules/common/PopUp';
 import GridItem from '@components/modules/grid/GridItem';
@@ -36,8 +36,22 @@
       deleteYn: '',
     },
   });
+
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
+
   // Side effect Hook
   useEffect(() => {
+
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current) {
+      return;
+    }
+
     if (flag === 'update' && id) {
       const getGroupDetails = async () => {
         const result = await apiCall(groupApi.getGroupDetails, id);
@@ -61,6 +75,8 @@
       getGroupDetails();
     }
   }, []);
+
+  
   // 입력한 그룹정보 저장
   const insertGroup = async (data) => {
     const result = await apiCall(groupApi.insertGroup, data);
diff -urN ..\hss-frontend\src\/components/modal/system/menu/menuModal.jsx .\src\/components/modal/system/menu/menuModal.jsx
--- ..\hss-frontend\src\/components/modal/system/menu/menuModal.jsx	2024-10-18 16:27:14.092980500 +0900
+++ .\src\/components/modal/system/menu/menuModal.jsx	2025-03-07 14:26:41.324770000 +0900
@@ -138,7 +138,9 @@
           common: true,
           isEdit: true,
         });
+
         if (menuResult.status === 200) {
+
           dispatch(
             setMenuItem({
               topMenuItem: menuResult.data.menuList.map((menu) => ({
diff -urN ..\hss-frontend\src\/components/modal/system/menu/menuSettingModal.jsx .\src\/components/modal/system/menu/menuSettingModal.jsx
--- ..\hss-frontend\src\/components/modal/system/menu/menuSettingModal.jsx	2024-10-18 16:27:14.093980500 +0900
+++ .\src\/components/modal/system/menu/menuSettingModal.jsx	2025-03-08 16:19:25.341060600 +0900
@@ -14,6 +14,7 @@
 import useApi from '@modules/hooks/useApi';
 
 function MenuSettingModal({ alertOpen, setAlertOpen, getMenuList, listReset }) {
+
   // Axios 인트턴스(Http통신)
   const { instance, source } = AuthInstance();
   menuApi.axios = instance;
diff -urN ..\hss-frontend\src\/components/modules/button/LoadingButton.jsx .\src\/components/modules/button/LoadingButton.jsx
--- ..\hss-frontend\src\/components/modules/button/LoadingButton.jsx	2024-10-18 16:27:14.099984200 +0900
+++ .\src\/components/modules/button/LoadingButton.jsx	2025-03-05 16:40:17.280343000 +0900
@@ -1,8 +1,10 @@
+'use client'; // ✅ Ensures Next.js 15 client compatibility
+
 import PropTypes from 'prop-types';
 import { forwardRef } from 'react';
 
-// material-ui
-import MuiLoadingButton from '@mui/lab/LoadingButton';
+// Material-UI
+import { Button } from '@mui/material';
 import { alpha, styled, useTheme } from '@mui/material/styles';
 
 const getColors = (theme, color) => {
@@ -22,246 +24,77 @@
   }
 };
 
-const getShadow = (theme, shadow) => {
-  switch (shadow) {
-    case 'secondary':
-      return theme.customShadows.secondary;
-    case 'error':
-      return theme.customShadows.error;
-    case 'warning':
-      return theme.customShadows.warning;
-    case 'info':
-      return theme.customShadows.info;
-    case 'success':
-      return theme.customShadows.success;
-    case 'primaryButton':
-      return theme.customShadows.primaryButton;
-    case 'secondaryButton':
-      return theme.customShadows.secondaryButton;
-    case 'errorButton':
-      return theme.customShadows.errorButton;
-    case 'warningButton':
-      return theme.customShadows.warningButton;
-    case 'infoButton':
-      return theme.customShadows.infoButton;
-    case 'successButton':
-      return theme.customShadows.successButton;
-    default:
-      return theme.customShadows.primary;
-  }
-};
-
-// ==============================|| LOADING BUTTON - COLOR STYLE ||============================== //
+// ==============================|| STYLED - LOADING BUTTON ||============================== //
 
-function getColorStyle({ variant, theme, color, loadingPosition }) {
+const LoadingButtonStyle = styled(Button, {
+  shouldForwardProp: (prop) => prop !== 'shape' && prop !== 'variant',
+})(({ theme, variant, shape, color, loading, loadingPosition }) => {
   const colors = getColors(theme, color);
-  const { lighter, main, dark, contrastText } = colors;
+  const { main, dark, contrastText } = colors;
 
-  const buttonShadow = `${color}Button`;
-  const shadows = getShadow(theme, buttonShadow);
+  return {
+    position: 'relative',
+    '::after': {
+      content: '""',
+      display: 'block',
+      position: 'absolute',
+      left: 0,
+      top: 0,
+      width: '100%',
+      height: '100%',
+      borderRadius: shape === 'rounded' ? '50%' : 4,
+      opacity: 0,
+      transition: 'all 0.5s',
+    },
+    ':active::after': {
+      opacity: 1,
+      transition: '0s',
+    },
+
+    ...(variant === 'contained' && {
+      backgroundColor: main,
+      color: contrastText,
+      '&:hover': {
+        backgroundColor: dark,
+      },
+    }),
 
-  const loadingIndicator = {
-    '& .MuiLoadingButton-loadingIndicator': {
+    ...(variant === 'outlined' && {
+      border: `1px solid ${main}`,
       color: main,
-    },
-  };
-
-  const loadingColor = {
-    ...(loadingPosition &&
-      loadingPosition !== 'center' && {
-        color: main,
-      }),
-  };
-
-  const commonShadow = {
-    '&::after': {
-      boxShadow: `0 0 6px 6px ${alpha(main, 0.9)}`,
-    },
-    '&:active::after': {
-      boxShadow: `0 0 0 0 ${alpha(main, 0.9)}`,
-    },
-    '&:focus-visible': {
-      outline: `2px solid ${dark}`,
-      outlineOffset: 2,
-    },
-  };
-
-  switch (variant) {
-    case 'contained':
-      return {
-        backgroundColor: main,
-        ...(loadingPosition &&
-          loadingPosition !== 'center' && {
-            color: contrastText,
-          }),
-        '& .MuiLoadingButton-loadingIndicator': {
-          color: contrastText,
-        },
-        '&:hover': {
-          backgroundColor: dark,
-          color: contrastText,
-        },
-        ...commonShadow,
-      };
-    case 'light':
-      return {
-        backgroundColor: main,
-        ...(loadingPosition &&
-          loadingPosition !== 'center' && {
-            color: contrastText,
-          }),
-        '& .MuiLoadingButton-loadingIndicator': {
-          color: contrastText,
-        },
-        '&:hover': {
-          backgroundColor: dark,
-          color: contrastText,
-        },
-        ...commonShadow,
-      };
-    case 'shadow':
-      return {
-        boxShadow: shadows,
-        backgroundColor: main,
-        ...(loadingPosition &&
-          loadingPosition !== 'center' && {
-            color: contrastText,
-          }),
-        '& .MuiLoadingButton-loadingIndicator': {
-          color: contrastText,
-        },
-        '&:hover': {
-          boxShadow: 'none',
-          backgroundColor: dark,
-          color: contrastText,
-        },
-        ...commonShadow,
-      };
-    case 'outlined':
-      return {
-        backgroundColor: 'transparent',
-        borderColor: main,
-        ...loadingColor,
-        ...loadingIndicator,
-      };
-    case 'dashed':
-      return {
-        backgroundColor: lighter,
-        borderColor: main,
-        ...loadingColor,
-        ...loadingIndicator,
-        ...commonShadow,
-      };
-    case 'text':
-    default:
-      return {
-        color: main,
-        ...loadingIndicator,
-        ...commonShadow,
-      };
-  }
-}
-
-// ==============================|| STYLED - LOADING BUTTON ||============================== //
+    }),
 
-const LoadingButtonStyle = styled(MuiLoadingButton, {
-  shouldForwardProp: (prop) => prop !== 'shape' && prop !== 'variant',
-})(({ theme, variant, shape, color, loading, loadingPosition }) => ({
-  '::after': {
-    content: '""',
-    display: 'block',
-    position: 'absolute',
-    left: 0,
-    top: 0,
-    width: '100%',
-    height: '100%',
-    borderRadius: shape === 'rounded' ? '50%' : 4,
-    opacity: 0,
-    transition: 'all 0.5s',
-  },
-
-  ':active::after': {
-    position: 'absolute',
-    borderRadius: shape === 'rounded' ? '50%' : 4,
-    left: 0,
-    top: 0,
-    opacity: 1,
-    transition: '0s',
-  },
-  ...(variant === 'text' && {
-    ...getColorStyle({ variant, theme, color, loadingPosition }),
-    '&.MuiButton-sizeMedium': {
-      height: 36,
-    },
-    '&.MuiButton-sizeSmall': {
-      height: 30,
-    },
-    '&.MuiButton-sizeLarge': {
-      height: 44,
-    },
-  }),
-  ...(shape && {
-    minWidth: 0,
-    '&.MuiButton-sizeMedium': {
-      width: 36,
-      height: 36,
-    },
-    '&.MuiButton-sizeSmall': {
-      width: 30,
-      height: 30,
-    },
-    '&.MuiButton-sizeLarge': {
-      width: 44,
-      height: 44,
-    },
-    ...(shape === 'rounded' && {
-      borderRadius: '50%',
+    ...(variant === 'text' && {
+      color: main,
     }),
-  }),
 
-  ...(variant === 'outlined' && {
-    border: '1px solid',
-  }),
-  ...(variant === 'dashed' && {
-    border: '1px dashed',
-  }),
-  ...((variant === 'contained' || variant === 'shadow') &&
-    loading && {
+    ...(loading && {
       color: '#fff',
+      '& .MuiLoadingButton-loadingIndicator': {
+        color: contrastText,
+      },
     }),
-  ...(variant !== 'text' && {
-    ...getColorStyle({ variant, theme, color, loadingPosition }),
-  }),
-
-  '&.Mui-disabled': {
-    ...(variant !== 'text' && {
-      ...getColorStyle({ variant, theme, color, loadingPosition }),
+
+    ...(shape && {
+      minWidth: 0,
+      width: shape === 'rounded' ? 36 : 'auto',
+      height: shape === 'rounded' ? 36 : 'auto',
+      borderRadius: shape === 'rounded' ? '50%' : 4,
     }),
-  },
-}));
+  };
+});
 
 // ==============================|| EXTENDED - LOADING BUTTON ||============================== //
 
-const LoadingButton = forwardRef(
-  ({ variant = 'text', shape, children, color = 'primary', ...others }, ref) => {
-    const theme = useTheme();
-
-    return (
-      <LoadingButtonStyle
-        ref={ref}
-        variant={variant}
-        shape={shape}
-        theme={theme}
-        loadingPosition={others.loadingPosition}
-        loading={others.loading}
-        color={color}
-        {...others}
-      >
-        {children}
-      </LoadingButtonStyle>
-    );
-  },
-);
+const LoadingButton = forwardRef(({ variant = 'text', shape, children, color = 'primary', ...others }, ref) => {
+  const theme = useTheme(); // ✅ Correctly use MUI theme without passing as a prop
+
+  return (
+    <LoadingButtonStyle ref={ref} variant={variant} shape={shape} color={color} {...others}>
+      {children}
+    </LoadingButtonStyle>
+  );
+});
 
 LoadingButton.propTypes = {
   variant: PropTypes.string,
diff -urN ..\hss-frontend\src\/components/modules/common/Alert.jsx .\src\/components/modules/common/Alert.jsx
--- ..\hss-frontend\src\/components/modules/common/Alert.jsx	2024-10-18 16:27:14.100984400 +0900
+++ .\src\/components/modules/common/Alert.jsx	2025-03-11 09:21:41.834881400 +0900
@@ -1,4 +1,4 @@
-import { isValidElement } from 'react';
+import { isValidElement,useRef } from 'react';
 
 // Redux
 import { useDispatch, useSelector } from 'react-redux';
@@ -31,14 +31,15 @@
 
 // react-draggable
 function PaperComponent(props) {
+  const nodeRef = useRef(null);
   return (
-    <Draggable
+    <Draggable nodeRef={nodeRef}
       handle="#draggable-alert-dialog-title"
       cancel={'[class*="MuiDialogContent-root"]'}
       defaultPosition={{ x: 0, y: 0 }}
       bounds="parent"
     >
-      <Paper {...props} sx={{ transform: 'none' }} />
+      <Paper ref={nodeRef} {...props} sx={{ transform: 'none' }} />
     </Draggable>
   );
 }
diff -urN ..\hss-frontend\src\/components/modules/common/ConfirmAlert.jsx .\src\/components/modules/common/ConfirmAlert.jsx
--- ..\hss-frontend\src\/components/modules/common/ConfirmAlert.jsx	2024-10-18 16:27:14.101984200 +0900
+++ .\src\/components/modules/common/ConfirmAlert.jsx	2025-03-10 17:45:24.146026000 +0900
@@ -1,7 +1,10 @@
+'use client'; // ✅ Ensures compatibility with Next.js 15
+
+import { useRef } from 'react';
 import { useDispatch, useSelector } from 'react-redux';
 import { closeConfirmAlert, handleConfirmClick } from '@modules/redux/reducers/confirmAlert';
 
-import { useTheme } from '@mui/styles';
+import { useTheme } from '@mui/material/styles'; // ✅ Correct MUI v5 import
 import { CloseOutlined } from '@ant-design/icons';
 import InfoIcon from '@mui/icons-material/Info';
 import {
@@ -21,39 +24,34 @@
 import Draggable from 'react-draggable';
 import { isValidElement } from 'react';
 
-// react-draggable
-function PaperComponent(props) {
+
+// ✅ Ensure correct draggable Paper component
+const PaperComponent = (props) => {
+  const nodeRef = useRef(null);
   return (
-    <Draggable
-      handle="#draggable-confirm-dialog-title"
-      cancel={'[class*="MuiDialogContent-root"]'}
-      defaultPosition={{ x: 0, y: 0 }}
-      bounds="parent"
-    >
-      <Paper {...props} sx={{ transform: 'none' }} />
+    <Draggable nodeRef={nodeRef} handle="#draggable-confirm-dialog-title" cancel={'[class*="MuiDialogContent-root"]'}>
+      <Paper  ref={nodeRef} {...props} />
     </Draggable>
   );
-}
+};
 
+// ✅ Main ConfirmAlert Component
 const ConfirmAlert = () => {
   const dispatch = useDispatch();
-
   const confirmAlert = useSelector((state) => state.confirmAlert);
-
   const { open, message, close, confirmButtonText, target } = confirmAlert;
 
-  const theme = useTheme();
+  const theme = useTheme(); // ✅ Correct use of theme
   const fullScreen = useMediaQuery(theme.breakpoints.down('md'));
 
+  // ✅ Handle Close
   const handleClose = (event, reason) => {
-    if (!close && reason === 'backdropClick') {
-      return;
-    }
-
+    if (!close && reason === 'backdropClick') return;
     dispatch(closeConfirmAlert());
   };
 
-  const handleConfrim = () => {
+  // ✅ Handle Confirm Click
+  const handleConfirm = () => {
     dispatch(handleConfirmClick());
   };
 
@@ -66,11 +64,10 @@
       PaperComponent={PaperComponent}
       sx={{ zIndex: 2005 }}
       onKeyDown={(e) => {
-        if (e.key === 'Escape') {
-          handleClose();
-        }
+        if (e.key === 'Escape') handleClose();
       }}
     >
+      {/* ✅ Draggable Header */}
       <Grid
         container
         spacing={2}
@@ -96,6 +93,7 @@
         </Grid>
       </Grid>
 
+      {/* ✅ Dialog Content */}
       <DialogContent sx={{ whiteSpace: 'pre-line' }}>
         {isValidElement(message) ? (
           message
@@ -106,11 +104,12 @@
         )}
       </DialogContent>
 
+      {/* ✅ Dialog Actions */}
       <DialogActions>
         <Button
           type="submit"
           form={target}
-          onClick={handleConfrim}
+          onClick={handleConfirm} // ✅ Fixed typo
           autoFocus
           color="primary"
           variant="contained"
diff -urN ..\hss-frontend\src\/components/modules/common/CustomModal.jsx .\src\/components/modules/common/CustomModal.jsx
--- ..\hss-frontend\src\/components/modules/common/CustomModal.jsx	2024-10-18 16:27:14.101984200 +0900
+++ .\src\/components/modules/common/CustomModal.jsx	2025-03-10 17:45:55.443195000 +0900
@@ -1,6 +1,5 @@
 import { useDispatch, useSelector } from 'react-redux';
 import { closeCustomAlert, handleButtonsClick } from '@modules/redux/reducers/customAlert';
-
 import { useTheme } from '@mui/styles';
 import { CloseOutlined } from '@ant-design/icons';
 import InfoIcon from '@mui/icons-material/Info';
@@ -20,18 +19,22 @@
   Paper,
 } from '@mui/material';
 import Draggable from 'react-draggable';
-import { isValidElement } from 'react';
+import { isValidElement,useRef } from 'react';
+
+
 
 // react-draggable
 function PaperComponent(props) {
+  const nodeRef = useRef(null);
   return (
     <Draggable
+      nodeRef={nodeRef}
       handle="#draggable-custom-dialog-title"
       cancel={'[class*="MuiDialogContent-root"]'}
       defaultPosition={{ x: 0, y: 0 }}
       bounds="parent"
     >
-      <Paper {...props} sx={{ transform: 'none' }} />
+      <Paper ref={nodeRef} {...props} sx={{ transform: 'none' }} />
     </Draggable>
   );
 }
diff -urN ..\hss-frontend\src\/components/modules/common/PopUp.jsx .\src\/components/modules/common/PopUp.jsx
--- ..\hss-frontend\src\/components/modules/common/PopUp.jsx	2025-03-12 13:30:03.200261900 +0900
+++ .\src\/components/modules/common/PopUp.jsx	2025-03-10 17:39:42.499918500 +0900
@@ -26,16 +26,19 @@
 import { isEmpty } from 'lodash';
 import PropTypes from 'prop-types';
 
-// react-draggable
+import { useRef } from 'react';
+
 function PaperComponent(props) {
+  const nodeRef  = useRef(null);
   return (
     <Draggable
+      nodeRef={nodeRef}
       handle="#draggable-dialog-title"
       cancel={'[class*="MuiDialogContent-root"]'}
       defaultPosition={{ x: 0, y: 0 }}
       bounds="parent"
     >
-      <Paper {...props} sx={{ transform: 'none' }} />
+      <Paper ref={nodeRef} {...props} sx={{ transform: 'none' }} /> 
     </Draggable>
   );
 }
diff -urN ..\hss-frontend\src\/components/modules/input/LabelInput.jsx .\src\/components/modules/input/LabelInput.jsx
--- ..\hss-frontend\src\/components/modules/input/LabelInput.jsx	2025-03-12 13:30:03.201798200 +0900
+++ .\src\/components/modules/input/LabelInput.jsx	2025-03-11 18:56:19.886222000 +0900
@@ -41,8 +41,6 @@
  * @param {Number} minValue text input 입력 최소값 제한.
  * @param {Boolean} onlyNumber text input 숫자만 입력 가능하도록 제한.
  * @param {Boolean} onlyText text input 문자만 입력 가능하도록 제한.
- * @param {Boolean} onlySite text input 도메인 형식의 문자만 입력 가능하도록 제한.
- * @param {Boolean} onlyUrl text input URL 형식의 문자만 입력 가능하도록 제한.
  * @param {Boolean} disableAutoRules input validation 사용 여부.
  * @param {Boolean} typingCheck input validation 입력 제한 여부.
  * @param {Function} onHandleBlur 커스텀 onBlur이벤트 지정.
@@ -79,8 +77,6 @@
   minValue,
   onlyNumber = false,
   onlyText = false,
-  onlySite = false,
-  onlyUrl = false,
   disableAutoRules = false,
   typingCheck = false,
   onHandleBlur = null,
@@ -228,26 +224,6 @@
               return !regexp.test(value) || '문자만 입력가능합니다.';
             },
           };
-        // 도메인 형식의 입력만 허용
-        else if (onlySite) {
-          ruleOptions.validate = {
-            ...ruleOptions.validate,
-            onlySite: (value) => {
-              const regexp = /^[a-zA-Z.-]+$/;
-              return regexp.test(value) || '올바른 도메인 형식을 입력하세요. (예: hanssak.co.kr)';
-            },
-          };
-        }
-        // URL 형식의 입력만 허용
-        else if (onlyUrl) {
-          ruleOptions.validate = {
-            ...ruleOptions.validate,
-            onlyUrl: (value) => {
-              const regex = /^[a-zA-Z0-9.-]+\/[a-zA-Z0-9-_/]*$/;
-              return regex.test(value) || '올바른 URL 형식을 입력하세요. (예: hanssak.co.kr/login)';
-            },
-          };
-        }
       }
       // 필수 입력 지정
       if (required) {
@@ -788,18 +764,6 @@
    */
   onlyText: PropTypes.bool,
   /**
-   * text input 도메인 형식의 문자만 입력 가능하도록 제한.
-   * - typingCheck true 시, 입력을 제한.
-   * - typingCheck false 시, submit을 제한. **(Uncontrolled)**
-   */
-  onlySite: PropTypes.bool,
-  /**
-   * text input URL 형식의 문자만 입력 가능하도록 제한.
-   * - typingCheck true 시, 입력을 제한.
-   * - typingCheck false 시, submit을 제한. **(Uncontrolled)**
-   */
-  onlyUrl: PropTypes.bool,
-  /**
    * input validation 사용 여부.
    */
   disableAutoRules: PropTypes.bool,
diff -urN ..\hss-frontend\src\/components/modules/select/multipleSelect.jsx .\src\/components/modules/select/multipleSelect.jsx
--- ..\hss-frontend\src\/components/modules/select/multipleSelect.jsx	2024-10-18 16:27:14.115456400 +0900
+++ .\src\/components/modules/select/multipleSelect.jsx	2025-03-11 16:54:17.510252800 +0900
@@ -42,7 +42,7 @@
     setValue(newSelectedOptions);
 
     const selectedOptionsDetails = dataList.filter((option) =>
-      newSelectedOptions.includes(option.id),
+      newSelectedOptions.includes(option.id)
     );
     onValueChange(selectedOptionsDetails);
   };
@@ -56,25 +56,22 @@
           name={name}
           value={value}
           onChange={handleChange}
-          renderValue={(selected) =>
-            selected.map((data) => {
-              const item = dataList.find((option) => option.id === data);
-
-              return (
-                <>
-                  {item && (
-                    <span key={item.id} style={itemStyle}>
-                      {item.name}
-                    </span>
-                  )}
-                </>
-              );
-            })
-          }
+          renderValue={(selected) => (
+            <div>
+              {selected.map((data) => {
+                const item = dataList.find((option) => option.id === data);
+                return item ? (
+                  <span key={item.id} style={itemStyle}>
+                    {item.name}
+                  </span>
+                ) : null;
+              })}
+            </div>
+          )}
         >
           {dataList.map((option) => (
             <MenuItem key={option.id} value={option.id}>
-              <ListItemText key={option.id} primary={option.name} />
+              <ListItemText primary={option.name} />
             </MenuItem>
           ))}
         </Select>
diff -urN ..\hss-frontend\src\/components/modules/table/HsReactTable/index.jsx .\src\/components/modules/table/HsReactTable/index.jsx
--- ..\hss-frontend\src\/components/modules/table/HsReactTable/index.jsx	2024-10-18 16:27:14.119456200 +0900
+++ .\src\/components/modules/table/HsReactTable/index.jsx	2025-03-11 15:27:09.934774000 +0900
@@ -1,5 +1,12 @@
 import PropTypes from 'prop-types';
-import React, { forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
+import React, {
+  forwardRef,
+  useCallback,
+  useEffect,
+  useMemo,
+  useRef,
+  useState,
+} from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import ReactRow from '../ReactRow';
 import useConfig from '@modules/hooks/useConfig';
@@ -53,6 +60,7 @@
     prevProps.parameters.current.size === nextProps.parameters.current.size
   );
 };
+
 function Index({
   columns = [],
   data,
@@ -68,13 +76,11 @@
   const [toggleAll, setToggleAll] = useState(false);
   const dispatch = useDispatch();
   const pageIndex = parameters.current.page;
-
   const memoizedData = useMemo(() => {
     if (_.isEmpty(data)) return data;
     return [...data];
   }, [data]);
   const memoizedColumns = useMemo(() => columns, [columns]);
-
   const { update } = useAccess();
   const intl = useIntl();
   const theme = useTheme();
@@ -82,7 +88,7 @@
   const tableInfoRef = useRef(null);
 
   useEffect(() => {
-    checkList?.map((item) => {
+    checkList?.forEach((item) => {
       const index = data.findIndex((object) => object['id'] === item.id);
       toggleRowSelected(index, true);
     });
@@ -106,7 +112,6 @@
       });
     }
     ref.current = gridInfo.total;
-
     return () => {
       dispatch(resetGridCodeCache()); // 코드 캐싱 정보 초기화.
     };
@@ -160,28 +165,43 @@
         />
       );
     },
-    [rows, listInfo, theme, flatHeaders, toggleAll],
+    [rows, listInfo, theme, flatHeaders, toggleAll]
   );
-
+  /*
+    const HeaderContents = () => {
+      return headerGroups.map((headerGroup, i) => {
+        const headerGroupProps = headerGroup.getHeaderGroupProps();
+        const { key: headerGroupKey, ...restHeaderGroupProps } = headerGroupProps;
+        return (
+          <TableHead key={headerGroupKey || i} {...restHeaderGroupProps}>
+            <TableHeaders
+              headerGroup={headerGroup}
+              headerHeight={parameters.current?.headerHeight}
+              page={page}
+              onChangeChecked={onChangeChecked}
+              setToggleAll={setToggleAll}
+            />
+          </TableHead>
+        );
+      });
+    };
+  */
   const HeaderContents = () => {
-    return headerGroups.map((headerGroup, i) => {
-      return (
-        <TableHeaders
-          key={i}
-          headerGroup={headerGroup}
-          headerHeight={parameters.current?.headerHeight}
-          page={page}
-          onChangeChecked={onChangeChecked}
-          setToggleAll={setToggleAll}
-        />
-      );
-    });
+    return headerGroups.map((headerGroup, i) => (
+      <TableHeaders
+        key={i}
+        headerGroup={headerGroup}
+        headerHeight={parameters.current?.headerHeight}
+        page={page}
+        onChangeChecked={onChangeChecked}
+        setToggleAll={setToggleAll}
+      />
+    ));
   };
-
   let fixColumnWidth = 0;
   if (memoizedColumns.length > 0) {
-    memoizedColumns.forEach((data) => {
-      if (listInfo?.fitWidth === 'N' && data.sticky) fixColumnWidth += data.width;
+    memoizedColumns.forEach((col) => {
+      if (listInfo?.fitWidth === 'N' && col.sticky) fixColumnWidth += col.width;
     });
   }
 
@@ -192,21 +212,35 @@
         options: {
           scrollbars: {
             visibility: 'visible',
-            theme: theme.palette.mode === 'dark' ? 'os-theme-light' : 'os-theme-dark',
+            theme:
+              theme.palette.mode === 'dark' ? 'os-theme-light' : 'os-theme-dark',
           },
         },
       });
+      const isStrictMode = process.env.NODE_ENV === 'development';
+      const isFirstRender01 = useRef(true);
+      const isSecondCallAllowed01 = useRef(isStrictMode);
 
       useEffect(() => {
+        // 대상 DOM 요소(target)를 결정하고 존재하는지 확인
+        const target = listInfo?.fitHeight === 'Y' ? ref.current : scrollRef.current;
+        if (!target) return; // 대상이 없으면 초기화를 건너뜁니다.
+
+        if (isFirstRender01.current) {
+          isFirstRender01.current = false;
+          return;
+        }
+        if (!isSecondCallAllowed01.current) {
+          return;
+        }
         initialize({
-          target: listInfo?.fitHeight === 'Y' ? ref.current : scrollRef.current,
+          target,
           elements: {
-            viewport: listInfo?.fitHeight === 'Y' && ref.current,
+            viewport: listInfo?.fitHeight === 'Y' ? ref.current : undefined,
           },
         });
-
         return () => osInstance()?.destroy();
-      }, [initialize]);
+      }, [initialize, ref, scrollRef, listInfo?.fitHeight]);
 
       useEffect(() => {
         scrollRef.current = osInstance();
@@ -218,7 +252,7 @@
             ref.current = node;
           }
         },
-        [ref],
+        [ref]
       );
 
       return (
@@ -236,7 +270,7 @@
         </HsTableContainer>
       );
     }),
-    [theme, tableMode, listInfo],
+    [theme, tableMode, listInfo]
   );
 
   const TableTag = (props) => {
@@ -259,7 +293,7 @@
     );
   };
 
-  const Header = useCallback(
+  const HeaderComponent = useCallback(
     forwardRef(function RenderHeader(props, ref) {
       return (
         <TableHead
@@ -270,7 +304,7 @@
         />
       );
     }),
-    [],
+    []
   );
 
   const Row = ({ item, ...props }) => {
@@ -294,32 +328,27 @@
         ref={ref}
         className="body CMM-rt-tableArea-tableBody"
       >
-        {children.find((child) => child != null) ? (
+        {children.some((child) => child != null) ? (
           children
         ) : (
-          <TableRowNoData colSpan={flatHeaders.length} message={'데이터가 존재하지 않습니다.'} />
+          <TableRowNoData
+            colSpan={flatHeaders.length}
+            message={'데이터가 존재하지 않습니다.'}
+          />
         )}
       </TableBody>
     );
   };
 
-  const TableComponents = useCallback(
-    {
+  const TableComponents = useMemo(
+    () => ({
       Scroller,
       Table: TableTag,
-      TableHead: Header,
+      TableHead: HeaderComponent,
       TableRow: Row,
       TableBody: forwardRef(Body),
-    },
-    [
-      listInfo,
-      totalColumnsWidth,
-      theme,
-      intl,
-      flatHeaders,
-      toggleRowSelected,
-      toggleAllRowsSelected,
-    ],
+    }),
+    [listInfo, totalColumnsWidth, theme, intl, flatHeaders]
   );
 
   let maxPageSize = Math.ceil(gridInfo.total / size);
@@ -333,7 +362,6 @@
         flexDirection: listInfo?.fitHeight !== 'Y' && 'column',
       }}
     >
-      {/* 테이블 데이터가 없으면 각종 에러가 발생하므로 조건부 렌더링. */}
       {!_.isEmpty(listInfo) && (
         <>
           <TableVirtuoso
diff -urN ..\hss-frontend\src\/components/modules/table/HsReactTable/RowContent.jsx .\src\/components/modules/table/HsReactTable/RowContent.jsx
--- ..\hss-frontend\src\/components/modules/table/HsReactTable/RowContent.jsx	2024-10-18 16:27:14.118456200 +0900
+++ .\src\/components/modules/table/HsReactTable/RowContent.jsx	2025-03-10 21:00:22.310302000 +0900
@@ -1,5 +1,5 @@
 import { TableCell } from '@mui/material';
-import { SizeMe } from 'react-sizeme';
+// import { SizeMe } from 'react-sizeme'; // 제거됨
 import { DefaultCell } from '@components/modules/table/HsReactTable/DefaultCell';
 import EditableCell from '@components/modules/table/EditableCell';
 import { useTheme } from '@mui/material/styles';
@@ -20,7 +20,6 @@
   const handleClick = (event, originalInfo) => {
     if (event.target.checked !== undefined) {
       const selectedIndex = checkList.findIndex((item) => item.id === originalInfo.id);
-
       let newSelected = [];
       if (selectedIndex === -1) {
         newSelected = newSelected.concat(checkList, originalInfo);
@@ -34,14 +33,16 @@
           checkList.slice(selectedIndex + 1),
         );
       }
-
       onChangeChecked(newSelected);
     }
   };
 
   const onTableCellClick = (event, cell) => {
-    if (cell.column.id === 'row-selection-chk') handleClick(event, cell.row.original, row);
+    if (cell.column.id === 'row-selection-chk') {
+      handleClick(event, cell.row.original, row);
+    }
   };
+
   const tableCellStyle = (cell) => {
     return {
       '&[data-sticky-td]': {
@@ -54,7 +55,7 @@
       overflow: 'hidden',
       whiteSpace: 'nowrap',
       bgcolor:
-        'Y' === cell.row.original.fitWidth && cell.column.id === 'cellWidth'
+        cell.row.original.fitWidth === 'Y' && cell.column.id === 'cellWidth'
           ? theme.palette.mode === 'dark'
             ? '#1E1E1E'
             : '#F5F5F5'
@@ -64,7 +65,10 @@
             : '#F7F7F7'
           : 'inherit',
       height: itemHeight,
-      maxWidth: cell.column?.id === 'row-selection-chk' || cell.column?.id === 'no' ? '50px' : null,
+      maxWidth:
+        cell.column?.id === 'row-selection-chk' || cell.column?.id === 'no'
+          ? '50px'
+          : null,
       display: cell.column.defaultYn === 'N' && 'none',
       p: 'buttonProps' in cell.column && cell.column.attributeType === 'B' ? 0 : null,
     };
@@ -73,15 +77,18 @@
   return (
     <>
       {row.cells.map((cell, index) => {
+        // getCellProps()가 key를 포함한 props 객체를 반환할 수 있으므로 key를 분리합니다.
+        const cellProps = cell.getCellProps([{ className: cell.column.className }]);
+        const { key: cellKey, ...restCellProps } = cellProps;
         return (
           <TableCell
             className="CMM-rt-rowArea-tableCell"
-            key={index}
+            key={cellKey || index}
             align={
               cell.column.rowAlign || (cell.column.id === 'row-selection-chk' ? 'center' : 'left')
             }
             onClick={(event) => onTableCellClick(event, cell)}
-            {...cell.getCellProps([{ className: cell.column.className }])}
+            {...restCellProps}
             sx={() => tableCellStyle(cell)}
           >
             {cell.column.id === 'no' ? (
@@ -96,27 +103,22 @@
               tableEditable === 'N' ||
               (row.original?.addColumnFlag !== true && !update) ? (
               cell.render((param) => (
-                <SizeMe refreshMode="debounce" noPlaceholder key={index}>
-                  {({ size }) => {
-                    return (
-                      <div
-                        style={{
-                          height:
-                            'buttonProps' in cell.column && cell.column.attributeType === 'B'
-                              ? '100%'
-                              : null,
-                        }}
-                      >
-                        <DefaultCell
-                          className="CMM-rt-rowArea-tableCell-stack-defaultCell"
-                          props={param}
-                          theme={theme}
-                          tableCellWidth={size.width}
-                        />
-                      </div>
-                    );
+                <div
+                  style={{
+                    height:
+                      'buttonProps' in cell.column && cell.column.attributeType === 'B'
+                        ? '100%'
+                        : undefined,
                   }}
-                </SizeMe>
+                >
+                  <DefaultCell
+                    className="CMM-rt-rowArea-tableCell-stack-defaultCell"
+                    props={param}
+                    theme={theme}
+                    // react-sizeme 대신 cell.column.width 또는 기본값 사용
+                    tableCellWidth={cell.column.width || 'auto'}
+                  />
+                </div>
               ))
             ) : (
               cell.render(EditableCell)
diff -urN ..\hss-frontend\src\/components/modules/table/HsReactTable/TableHeader.jsx .\src\/components/modules/table/HsReactTable/TableHeader.jsx
--- ..\hss-frontend\src\/components/modules/table/HsReactTable/TableHeader.jsx	2024-10-18 16:27:14.118456200 +0900
+++ .\src\/components/modules/table/HsReactTable/TableHeader.jsx	2025-03-12 16:37:22.287498600 +0900
@@ -2,16 +2,19 @@
 import { useTheme } from '@mui/material/styles';
 import { useIntl } from 'react-intl';
 import IndeterminateCheckbox from '../IndeterminateCheckbox';
-
 export const TableHeader = ({ column, headerHeight, handleSelectAllClick }) => {
   const theme = useTheme();
   const intl = useIntl();
 
+  const headerProps = column.getHeaderProps([{ className: column.className }]);
+  const { key, ...restProps } = headerProps; // ✅ key를 분리해서 직접 전달
+
   return (
     <TableCell
+      key={key} // ✅ key를 직접 전달
+      {...restProps} // ✅ key를 제외한 나머지 props만 전달
       className="CMM-rt-headerArea-tableRow-tableCell"
       align={column.headerAlign || 'left'}
-      {...column.getHeaderProps([{ className: column.className }])}
       sx={{
         whiteSpace: 'nowrap',
         py: 1,
@@ -36,10 +39,7 @@
         justifyContent="center"
         alignItems="center"
       >
-        <Typography
-          component={'div'}
-          className="CMM-rt-headerArea-tableRow-tableCell-stack-typography"
-        >
+        <Typography component={'div'} className="CMM-rt-headerArea-tableRow-tableCell-stack-typography">
           {column.id === 'row-selection-chk'
             ? column.render(({ getToggleAllPageRowsSelectedProps }) => (
                 <IndeterminateCheckbox indeterminate {...getToggleAllPageRowsSelectedProps()} />
diff -urN ..\hss-frontend\src\/components/modules/table/HsReactTable/TableHeaders.jsx .\src\/components/modules/table/HsReactTable/TableHeaders.jsx
--- ..\hss-frontend\src\/components/modules/table/HsReactTable/TableHeaders.jsx	2024-10-18 16:27:14.118456200 +0900
+++ .\src\/components/modules/table/HsReactTable/TableHeaders.jsx	2025-03-07 17:51:38.177156400 +0900
@@ -1,7 +1,6 @@
 import { TableRow } from '@mui/material';
 import { useTheme } from '@mui/material/styles';
 import { TableHeader } from '@components/modules/table/HsReactTable/TableHeader';
-
 export const TableHeaders = ({
   headerGroup,
   headerHeight,
@@ -22,10 +21,15 @@
     onChangeChecked([]);
   };
 
+  // ✅ key를 분리해서 직접 전달
+  const headerGroupProps = headerGroup.getHeaderGroupProps();
+  const { key, ...restProps } = headerGroupProps;
+
   return (
     <TableRow
+      key={key} // ✅ key를 직접 전달
       className="CMM-rt-headerArea-tableRow"
-      {...headerGroup.getHeaderGroupProps()}
+      {...restProps} // ✅ key를 제외한 나머지 props만 전달
       sx={{
         '& [data-sticky-td]': {
           backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : '#f5f5f5',
diff -urN ..\hss-frontend\src\/components/modules/table/HsReduxTable/index.jsx .\src\/components/modules/table/HsReduxTable/index.jsx
--- ..\hss-frontend\src\/components/modules/table/HsReduxTable/index.jsx	2024-10-18 16:27:14.119456200 +0900
+++ .\src\/components/modules/table/HsReduxTable/index.jsx	2025-03-08 16:19:11.901177100 +0900
@@ -5,7 +5,6 @@
   const { columns, pageDataList, parameters, listInfo, totalElements } = useSelector(
     (state) => state[`${name}`],
   );
-
   const dispatch = useDispatch();
 
   return (
diff -urN ..\hss-frontend\src\/components/modules/table/MiniTable/index.jsx .\src\/components/modules/table/MiniTable/index.jsx
--- ..\hss-frontend\src\/components/modules/table/MiniTable/index.jsx	2024-10-18 16:27:14.122376600 +0900
+++ .\src\/components/modules/table/MiniTable/index.jsx	2025-03-05 16:42:48.602690600 +0900
@@ -1,3 +1,7 @@
+
+// TypeError: Cannot assign to read only property 'theme' 에러 발생 코드 RAINROOT
+'use client';
+
 import { useState, useEffect } from 'react';
 import {
   Table,
@@ -185,7 +189,6 @@
                   return (
                     <TableCell
                       colSpan={column?.colSpan || 1}
-                      theme={theme}
                       key={column.id}
                       sx={{
                         ...headerCellStyle(theme),
@@ -218,7 +221,6 @@
                     return (
                       <TableCell
                         key={subColumn.id}
-                        theme={theme}
                         sx={{
                           ...headerCellStyle(theme),
                           ...sx.subHeadCell,
@@ -239,7 +241,7 @@
                   borderTop: '1px solid',
                   borderRight: '1px solid',
                   '&:last-of-type': { borderRight: 'none' },
-                  borderColor: `${theme.palette.grey[300]}`,
+                  borderColor: theme.palette.grey[300],
                   borderBottom: 'none',
                   ...sx.body,
                 },
diff -urN ..\hss-frontend\src\/components/modules/table/ReactRow.jsx .\src\/components/modules/table/ReactRow.jsx
--- ..\hss-frontend\src\/components/modules/table/ReactRow.jsx	2024-10-18 16:27:14.122376600 +0900
+++ .\src\/components/modules/table/ReactRow.jsx	2025-03-11 14:19:28.240229900 +0900
@@ -1,14 +1,19 @@
 import { TableRow } from '@mui/material';
 
 const ReactRow = ({ row, children, theme, id, ...rest }) => {
+  // row.getRowProps()에서 key와 style 분리
+  const rowProps = row.getRowProps ? row.getRowProps() : {};
+  const { key: rowKey, style, ...otherRowProps } = rowProps;
+  const finalKey = rowKey || `fallback-key-${new Date().getTime()}`;
+
   return (
     <TableRow
+      key={finalKey}
       className="CMM-rt-tableArea-reactRow-tableRow"
       {...rest}
-      {...row.getRowProps()}
+      {...otherRowProps}
       sx={{
         bgcolor: row.isSelected ? theme.palette.primary.lighter : 'inherit',
-
         '&.MuiTableRow-root:hover': {
           '& .MuiTableCell-root': {
             backgroundColor: theme.palette.mode === 'dark' ? '#1e1e1e' : '#f5f5f5',
@@ -24,9 +29,10 @@
               ? theme.palette.primary.lighter
               : theme.palette.common.white,
         },
-        height: id !== 'PermissionForm' && (rest?.height ? rest?.height : 40),
-        // height: id !== 'PermissionForm' && '40px',
-        ...{ ...row.getRowProps().style, ...(rest?.style && rest?.style) },
+        height: id !== 'PermissionForm' && (rest?.height ? rest.height : 40),
+        // style 병합
+        ...style,
+        ...(rest?.style || {}),
       }}
     >
       {children}
diff -urN ..\hss-frontend\src\/components/modules/table/ReactTable.jsx .\src\/components/modules/table/ReactTable.jsx
--- ..\hss-frontend\src\/components/modules/table/ReactTable.jsx	2024-10-18 16:27:14.123376700 +0900
+++ .\src\/components/modules/table/ReactTable.jsx	2025-03-10 20:38:56.436979100 +0900
@@ -1,5 +1,12 @@
 import PropTypes from 'prop-types';
-import React, { useRef, useEffect, useState, useMemo, useCallback, forwardRef } from 'react';
+import React, {
+  useRef,
+  useEffect,
+  useState,
+  useMemo,
+  useCallback,
+  forwardRef
+} from 'react';
 import NextLink from 'next/link';
 import { unstable_batchedUpdates } from 'react-dom';
 
@@ -58,11 +65,12 @@
 import { useIntl } from 'react-intl';
 import reactStyled from 'styled-components';
 import { TableVirtuoso } from 'react-virtuoso';
-import { SizeMe } from 'react-sizeme';
+// react-sizeme 제거
+// import { SizeMe } from 'react-sizeme';
 import _ from 'lodash';
 import IndeterminateCheckbox from './IndeterminateCheckbox';
+
 const Styles = reactStyled.div`
-  
   .table {
     &.sticky {
       overflow: scroll;
@@ -88,6 +96,7 @@
   },
 }));
 
+// DefaultCell: 기존 컴포넌트 그대로 사용 (tableCellWidth prop을 받음)
 const DefaultCell = ({ props, theme, tableCellWidth }) => {
   const textRef = useRef();
   const linkRef = useRef();
@@ -97,27 +106,17 @@
   const [toolTipOpen, setToolTipOpen] = useState(false);
 
   const { value: initialValue, column, cell, row } = props;
-
   const collapseIcon = row.isExpanded ? <DownOutlined /> : <RightOutlined />;
-
   let initValue = initialValue;
-  // Date
   if (column.cellType === 'D')
     initValue = HsLib.reactRegisterDateRender(row, '$1-$2-$3', false, column.id);
-  // Date ~ Date
   if (column.cellType === 'G') initValue = HsLib.reactRegisterDateRender(row, '$1-$2-$3', true);
-  // DateTime
   if (column.cellType === 'A')
     initValue = HsLib.changeDateFormat(initialValue, '$1-$2-$3 $4:$5:$6');
-  // Date hh:mm
   if (column.cellType === 'B') initValue = HsLib.changeDateFormat(initialValue, '$1-$2-$3 $4:$5');
-  // hh:mm
   if (column.cellType === 'H') initValue = HsLib.changeDateFormat(initialValue, '$4:$5');
-  // hh:mm:ss
   if (column.cellType === 'S') initValue = HsLib.changeDateFormat(initialValue, '$4:$5:$6');
-  // YYYY-MM
   if (column.cellType === 'O') initValue = HsLib.changeDateFormat(initialValue, '$1-$2');
-  // Number(,)
   if (column.cellType === 'I') {
     if (typeof initialValue === 'string' && Number(initialValue)) {
       initValue = Number(initialValue).toLocaleString().toString();
@@ -125,27 +124,21 @@
       initValue = initialValue?.toLocaleString();
     }
   }
-  // Combo
   if (column.cellType === 'C') {
     initValue = column.valueOptions.find((option) => {
       if (option.value === initValue?.toString()) return option;
     })?.label;
   }
 
-  // HyperLink - 하이퍼링크 타입.
   if (column.attributeType === 'H') {
     const trimString = column.attribute.replaceAll(' ', '');
-    // 내부 parameter만 배열을 가질 수 있음.
-    const splitAtrribute = trimString.replaceAll(/\[.*?\]/g, ''); // Attribute 값 내의 대괄호 내용을 제외한 문자열.
-    // eslint-disable-next-line
-    const arratAttribute = trimString.replaceAll(/[^\[\]]*(?=(?:[^\]]*\[[^\[]*\])*[^\[\]]*$)/g, ''); // 대괄호 내용.
-
+    const splitAtrribute = trimString.replaceAll(/\[.*?\]/g, '');
+    const arratAttribute = trimString.replaceAll(/[^\[\]]*(?=(?:[^\]]*\[[^\[]*\])*[^\[\]]*$)/g, '');
     const attribute = splitAtrribute
       .replaceAll(' ', '')
       .split(',')
       .map((item) => {
         const props = item.split(':');
-
         if (props[0] === 'parameter') {
           const array = arratAttribute
             .replace('[', '')
@@ -154,19 +147,15 @@
             .map((item) => `"${item}"`);
           return `"${props[0]}" : [${array}]`;
         }
-
         return `"${props[0]}":"${props[1]}"`;
       });
-
     const object = JSON.parse(`{${attribute.join(',')}}`);
     const param = object.parameter;
-
     let query = { flag: object.flag };
     if (param) {
       for (let i = 0; i < param.length; i++) {
         query[param[`${i}`]] = row.original[param[`${i}`]];
       }
-
       return (
         <NextLink
           className="CMM-rt-defaultCell-hType-nextLink"
@@ -229,10 +218,8 @@
     }
   }
 
-  // Cell - Cell 재정의 타입.
   if (column.attributeType === 'C') {
     const renderCell = cell.render('Cell');
-
     return (
       <BootstrapTooltip
         className="CMM-rt-defaultCell-cType-bootstrapTooltip"
@@ -240,7 +227,6 @@
         placement="top-start"
         open={toolTipOpen}
         onMouseEnter={() => {
-          // 말줄임표가 있을때만 툴팁이보이게
           if (tableCellWidth > 0) {
             setToolTipOpen(cellRef?.current?.children[0]?.scrollWidth > tableCellWidth);
           } else {
@@ -292,7 +278,6 @@
     );
   }
 
-  // Button - 버튼 콜백 타입.
   if (column.attributeType === 'B') {
     return (
       <BootstrapTooltip
@@ -374,7 +359,6 @@
       placement="top"
       open={toolTipOpen}
       onMouseOver={() => {
-        // 말줄임표가 있을때만 툴팁이보이게
         if (tableCellWidth > 0) {
           setToolTipOpen(textRef.current.clientWidth > tableCellWidth - 17);
         } else {
@@ -394,7 +378,6 @@
             tableCellWidth > 0 && tableCellWidth > column.width
               ? tableCellWidth - 16
               : column.width - 16,
-          // maxWidth: column.width - 16,
           whiteSpace: 'nowrap',
           overflow: 'hidden',
           textOverflow: 'ellipsis',
@@ -438,35 +421,7 @@
 
 /**
  * React Table 정의
- *
- * @param {Array} columns Column 객체 목록.
- * @param {Array} hiddenColumns 숨김 컬럼 목록 (accessor 사용.)
- * @param {Array} data Data 객체 목록.
- * @param {Function} setData data 상태 변경 함수.
- * @param {Boolean} disabledFooter Footer 표시 여부.
- * @param {Boolean} checkList Row 체크 시 Row 정보를 담을 목록 상태 값.
- * @param {Function} onChangeChecked checkList 상태 변경 함수.
- * @param {String} id 테이블 아이디.
- * @param {Object} gridInfo 테이블 관련 정보 객체.
- * @param {Function} setGridInfo 테이블 관련 정보 객체 업데이트 함수.
- * @param {Object} parameters 리스트 페이지에서 전달받은 파라미터 Ref 변수.
- * @param {Function} setParameters parameters 변경 함수.
- * @param {Function} setUpdateData 수정 목록 상태 값 변경 함수.
- * @param {String} listFuncName 목록 호출 시 사용하는 함수명.
- * @param {Function} searchParameters 목록 호출 시 추가 파라미터 지정 함수.
- * @param {Object} columnCollapse Collapse Row 정보 상태 값.
- * @param {Function} setColumnCollapse columnCollapse 상태 값 변경 함수.
- * @param {Object} rowState Row 상태 값에 할당하고자 하는 객체.
- * @param {Boolean} totalPage 페이징 요소 중 전체 데이터 수 표시 여부.
- * @param {Boolean} pageSelectNum 페이징 요소 중 페이지당 건 수 표시 여부.
- * @param {Boolean} pageInputNum 페이징 요소 중 전체 페이지 중 페이지 수 표시 여부.
- * @param {Boolean} miniPaging 미니 페이징 사용 여부.
- * @param {Function} rowSelectHandler Row Select 이벤트 핸들러.
- * @param {Boolean} disableHeaderCheckbox 전체선택 체크박스 사용 여부.
- * @param {Array} groupBy 그룹 테이블 기준 컬럼 accessor 목록.
- * @param {Array} sortList 정렬 컬록 accessor 목록.
- *
- *
+ * (생략된 propTypes 등은 기존과 동일)
  */
 function ReactTable({
   columns,
@@ -499,48 +454,28 @@
   ...rest
 }) {
   const listInfo = gridInfo.listInfo;
-
   const [toggleAll, setToggleAll] = useState(false);
-
   const [sortColumnInformation, setSortColumnInformation] = useState('');
-
-  // const [tableHeight, setTableHeight] = useState(0);
-
-  // 현재 페이지.
   const [pageIndex, setPageIndex] = useState(0);
-
-  // 컬럼 정렬 초기 정보 SET.
-  useEffect(() => {
-    if (parameters.current && parameters.current?.sort) {
-      setSortColumnInformation(parameters.current.sort);
-    }
-  }, [parameters.current?.sort]);
-
-  // api 호출 함수, openModal 함수.
   const [apiCall] = useApi();
-
   const memoizedData = useMemo(() => {
     if (_.isEmpty(data)) return data;
     const inputData = [...data];
-
     if (columnCollapse && columnCollapse.isOpen && columnCollapse.index != null) {
       inputData.splice(columnCollapse.index, 0, { ...columnCollapse, isExpandCell: true });
     }
-
     return inputData;
   }, [data, columnCollapse?.isOpen, columnCollapse?.index]);
   const memoizedColumns = useMemo(() => columns, [columns]);
-
   const { update } = useAccess();
   const intl = useIntl();
   const scrollRef = useRef(null);
   const theme = useTheme();
   const { tableMode } = useConfig();
-  // 테이블 너비 구하기위함
   const tableInfoRef = useRef(null);
 
   useEffect(() => {
-    checkList?.map((item) => {
+    checkList?.forEach((item) => {
       const index = data.findIndex((object) => object['id'] === item.id);
       toggleRowSelected(index, true);
     });
@@ -551,48 +486,28 @@
   }, [checkList]);
 
   const updateMyData = (row, columnId, value) => {
-    // setSkipPageReset(true);
-
-    // 2024.02.28 - 체크박스 선택 시 변경 중 데이터 손실 오류 보완
-    // if (row.original.status === 'I') {
     setData((prevData) => {
-      const tempData = prevData;
+      const tempData = [...prevData];
       const index = tempData.findIndex((prevRow) => prevRow.id === row.original.id);
-      tempData[`${index}`] = {
-        ...prevData[`${index}`],
+      tempData[index] = {
+        ...tempData[index],
         [columnId]: value,
-        status: prevData[`${index}`].status === 'I' ? 'I' : 'U',
+        status: tempData[index].status === 'I' ? 'I' : 'U',
       };
       return tempData;
     });
-    // }
-    // 2024.02.28 - 체크박스 선택 시 변경 중 데이터 손실 오류 보완
-
     setUpdateData((prevData) => {
-      const tempData = prevData;
+      const tempData = [...prevData];
       const index = tempData.findIndex((prevRow) => prevRow.id === row.original.id);
-      tempData[`${index}`] = {
-        ...prevData[`${index}`],
+      tempData[index] = {
+        ...tempData[index],
         [columnId]: value,
-        status: prevData[`${index}`]?.status === 'I' ? 'I' : 'U',
+        status: tempData[index]?.status === 'I' ? 'I' : 'U',
       };
       return tempData;
     });
   };
 
-  /**
-   * useTable: 필수, columns & data
-   * getTableProps: 필수, Table에 사용되는 모든 Props 정상 동작을 위해 사용
-   * getTableBodyProps: 필수, TableBody에 사용되는 모든 Props 정상 동작을 위해 사용
-   * headerGroups: 컬럼 목록
-   * rows: 행 목록
-   * prepareRow: 필수, 렌더링 딜레이 적용
-   * page: 현재 페이지의 행 목록
-   * setPageSize: page의 행 수를 변경 (setSize 할당.)
-   * gotoPage: 페이지 인덱스 변경
-   * state: 테이블 상태값. (pageSize: 페이지 행의 수(size 할당.))
-   * setHiddenColumns: 숨김 컬럼 설정 함수.
-   * */
   const {
     getTableProps,
     getTableBodyProps,
@@ -644,7 +559,6 @@
     }
   }, [parameters.current?.size]);
 
-  // Check box 전체 선택 이벤트.
   const handleSelectAllClick = (event) => {
     if (event.target.checked) {
       const newSelected = page.map((row) => row.original);
@@ -656,18 +570,14 @@
     onChangeChecked([]);
   };
 
-  // Row 별 Check box 선택 이벤트.
   const handleClick = (event, originalInfo, rowInfo) => {
     if (event.target.checked !== undefined) {
       const selectedIndex = checkList.findIndex((item) => item.id === originalInfo.id);
-      const row = data.filter((object) => {
-        return object['id'] === originalInfo.id;
-      });
+      const row = data.filter((object) => object['id'] === originalInfo.id);
 
       if (rowInfo.isSelected && listInfo.tableEditable === 'Y') {
         setUpdateData((prevUpdateData) => {
           const rowData = data.find((rowData) => rowData.id === originalInfo.id);
-
           return prevUpdateData.map((updateData) => {
             if (updateData.id === originalInfo.id) {
               return { ...rowData };
@@ -678,11 +588,7 @@
 
       if (row[0].status === 'I') {
         const newArray = [...data];
-
-        newArray.splice(
-          newArray.findIndex((prev) => row[0].id === prev.id),
-          1,
-        );
+        newArray.splice(newArray.findIndex((prev) => row[0].id === prev.id), 1);
         toggleRowSelected(originalInfo.id, false);
         setData(newArray);
         if (listInfo.tableEditable === 'Y') setUpdateData(newArray);
@@ -697,22 +603,17 @@
         } else if (selectedIndex > 0) {
           newSelected = newSelected.concat(
             checkList.slice(0, selectedIndex),
-            checkList.slice(selectedIndex + 1),
+            checkList.slice(selectedIndex + 1)
           );
         }
-
         onChangeChecked(newSelected);
-
-        //>> 2024.02.28 - 체크박스 선택 시 변경 중 데이터 손실 오류 보완
         let tempData = [...data];
         setData(tempData);
-        //<< 2024.02.28 - 체크박스 선택 시 변경 중 데이터 손실 오류 보완
       }
     }
   };
 
   let fixColumnWidth = 0;
-  // 컬럼 정렬 핸들러.
   const handleSortData = async ({ sortDirection, id }) => {
     const direction = sortDirection === undefined ? '' : sortDirection ? 'desc' : 'asc';
     const sort = `${id},${direction}`;
@@ -721,7 +622,6 @@
       ...params,
       sort,
     });
-
     if (result && result.status === 200) {
       setSortColumnInformation(sort);
       setParameters({ ...parameters.current, sort });
@@ -729,12 +629,11 @@
     }
   };
 
-  // react-virtuoso Table Row 내의 각 Cell 정의.
+  // RowContents: react-virtuoso Table Row 내의 각 Cell 정의.
   const RowContents = useCallback(
     (_, row) => {
       prepareRow(row);
       const { original } = row;
-
       if (original?.isExpandCell)
         return (
           <TableCell
@@ -747,116 +646,98 @@
             </Box>
           </TableCell>
         );
-
       return (
         <>
-          {row.cells.map((cell, index) => {
-            return (
-              <TableCell
-                className="CMM-rt-rowArea-tableCell"
-                key={index}
-                align={
-                  cell.column.rowAlign ||
-                  (cell.column.id === 'row-selection-chk' ? 'center' : 'left')
+          {row.cells.map((cell, index) => (
+            <TableCell
+              className="CMM-rt-rowArea-tableCell"
+              key={index}
+              align={
+                cell.column.rowAlign ||
+                (cell.column.id === 'row-selection-chk' ? 'center' : 'left')
+              }
+              onClick={(event) => {
+                if (cell.column.id === 'row-selection-chk')
+                  handleClick(event, cell.row.original, row);
+                else {
+                  rest?.onClick && rest?.onClick(event, cell, row);
                 }
-                onClick={(event) => {
-                  if (cell.column.id === 'row-selection-chk')
-                    handleClick(event, cell.row.original, row);
-                  else {
-                    rest?.onClick && rest?.onClick(event, cell, row);
-                  }
-                }}
-                {...cell.getCellProps([{ className: cell.column.className }])}
-                // 리스트 컬럼 전용
-                sx={{
-                  '&[data-sticky-td]': {
-                    backgroundColor: row.isSelected
-                      ? theme.palette.mode === 'dark'
-                        ? '#45495b'
-                        : '#e9edff'
-                      : theme.palette.grey[0],
-                  },
-                  overflow: 'hidden',
-                  whiteSpace: 'nowrap',
-                  bgcolor:
-                    !groupBy.length &&
-                    'Y' === cell.row.original.fitWidth &&
-                    cell.column.id === 'cellWidth'
-                      ? theme.palette.mode === 'dark'
-                        ? '#1E1E1E'
-                        : '#F5F5F5'
-                      : !groupBy.length && cell.row.original.boardTopYn === 'Y'
-                      ? theme.palette.mode === 'dark'
-                        ? '#1E1E1E'
-                        : '#F7F7F7'
-                      : 'inherit',
-                  height: parameters.current?.itemHeight,
-                  maxWidth:
-                    cell.column?.id === 'row-selection-chk' || cell.column?.id === 'no'
-                      ? '50px'
-                      : null,
-                  display: cell.column.defaultYn === 'N' && 'none',
-                  p: 'buttonProps' in cell.column && cell.column.attributeType === 'B' ? 0 : null,
-                }}
-              >
-                {cell.column.id === 'no' ? (
-                  row.index + 1 + size * pageIndex
-                ) : cell.column.id === 'row-selection-chk' ? (
-                  <IndeterminateCheckbox sx={{ p: 0 }} {...row.getToggleRowSelectedProps()} />
-                ) : !(
-                    (checkList.find((item) => item.id === row.original.id) ||
-                      row.original?.addColumnFlag === true) &&
-                    !toggleAll
-                  ) ||
-                  listInfo.tableEditable === 'N' ||
-                  // cell.column.defaultYn === 'Y' ||
-                  (row.original?.addColumnFlag !== true && !update) ? (
-                  cell.render((param) => (
-                    <SizeMe refreshMode="debounce" noPlaceholder key={index}>
-                      {({ size }) => {
-                        return (
-                          <div
-                            style={{
-                              height:
-                                'buttonProps' in cell.column && cell.column.attributeType === 'B'
-                                  ? '100%'
-                                  : null,
-                            }}
-                          >
-                            {cell.isPlaceholder ||
-                            (cell.column.isAggregateGroup && // 그룹 테이블 Aggregate 함수를 이용한 렌더링 시 사용, column에 isAggregateGroup 주입 필요.
-                              cell.row.depth > 0) ? null : cell.isAggregated ? (
-                              cell.render('Aggregated')
-                            ) : (
-                              <DefaultCell
-                                className="CMM-rt-rowArea-tableCell-stack-defaultCell"
-                                props={param}
-                                theme={theme}
-                                tableCellWidth={size.width}
-                              />
-                            )}
-                          </div>
-                        );
-                      }}
-                    </SizeMe>
-                  ))
-                ) : (
-                  cell.render(EditableCell)
-                )}
-              </TableCell>
-            );
-          })}
+              }}
+              {...cell.getCellProps([{ className: cell.column.className }])}
+              sx={{
+                '&[data-sticky-td]': {
+                  backgroundColor: row.isSelected
+                    ? theme.palette.mode === 'dark'
+                      ? '#45495b'
+                      : '#e9edff'
+                    : theme.palette.grey[0],
+                },
+                overflow: 'hidden',
+                whiteSpace: 'nowrap',
+                bgcolor:
+                  !groupBy.length &&
+                  row.original.fitWidth === 'Y' &&
+                  cell.column.id === 'cellWidth'
+                    ? theme.palette.mode === 'dark'
+                      ? '#1E1E1E'
+                      : '#F5F5F5'
+                    : !groupBy.length && row.original.boardTopYn === 'Y'
+                    ? theme.palette.mode === 'dark'
+                      ? '#1E1E1E'
+                      : '#F7F7F7'
+                    : 'inherit',
+                height: parameters.current?.itemHeight,
+                maxWidth:
+                  cell.column?.id === 'row-selection-chk' || cell.column?.id === 'no'
+                    ? '50px'
+                    : null,
+                display: cell.column.defaultYn === 'N' && 'none',
+                p: 'buttonProps' in cell.column && cell.column.attributeType === 'B' ? 0 : null,
+              }}
+            >
+              {cell.column.id === 'no' ? (
+                row.index + 1 + size * pageIndex
+              ) : cell.column.id === 'row-selection-chk' ? (
+                <IndeterminateCheckbox sx={{ p: 0 }} {...row.getToggleRowSelectedProps()} />
+              ) : !(
+                  (checkList.find((item) => item.id === row.original.id) ||
+                    row.original?.addColumnFlag === true) &&
+                  !toggleAll
+                ) ||
+                listInfo.tableEditable === 'N' ||
+                (row.original?.addColumnFlag !== true && !update) ? (
+                cell.render((param) => (
+                  <div
+                    style={{
+                      height:
+                        'buttonProps' in cell.column && cell.column.attributeType === 'B'
+                          ? '100%'
+                          : null,
+                    }}
+                  >
+                    <DefaultCell
+                      className="CMM-rt-rowArea-tableCell-stack-defaultCell"
+                      props={param}
+                      theme={theme}
+                      // react-sizeme 대신 cell.column.width를 사용 (없으면 'auto')
+                      tableCellWidth={cell.column.width || 'auto'}
+                    />
+                  </div>
+                ))
+              ) : (
+                cell.render(EditableCell)
+              )}
+            </TableCell>
+          ))}
         </>
       );
     },
-    [rows, listInfo, theme, flatHeaders, toggleAll],
+    [rows, listInfo, theme, flatHeaders, toggleAll]
   );
 
   const sortEventHandler = (column) => {
     if (parameters.current?.sort && column?.id !== 'row-selection-chk' && column?.id !== 'no') {
       let direction;
-      // false: 오름차순, true: 내림차순, undefined 정렬 x
-      // 내부 정렬기능을 사용하지 않아 값이 밀리는 현상 해결을 위해 직접 조정.
       if (column.isSortedDesc === false) {
         direction = true;
       } else if (column.isSortedDesc === true) {
@@ -869,200 +750,162 @@
     }
   };
 
-  // react-virtuoso Table Header 정의.
   const HeaderContents = () => {
     useEffect(() => {
       if (parameters.current && parameters.current?.sort) {
         if (_.isString(parameters.current.sort)) {
           const sortString = parameters.current.sort.split(',');
-          setSortBy([
-            { id: sortString[0], desc: sortString[1].toLowerCase() === 'asc' ? false : true },
-          ]);
+          setSortBy([{ id: sortString[0], desc: sortString[1].toLowerCase() === 'asc' ? false : true }]);
         }
       }
     }, [parameters?.sort]);
-
-    return headerGroups.map((headerGroup, i) => {
-      return (
-        <TableRow
-          className="CMM-rt-headerArea-tableRow"
-          key={i}
-          {...headerGroup.getHeaderGroupProps()}
-          sx={{
-            '& [data-sticky-td]': {
-              backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : '#f5f5f5',
-              fontSize: '14px',
-              fontWeight: '500',
-            },
-          }}
-          height={parameters.current?.headerHeight}
-        >
-          {headerGroup.headers.map((column, index) => {
-            const isSort =
-              column?.id !== 'row-selection-chk' &&
-              column?.id !== 'no' &&
-              (sortList === 'all' || sortList.includes(column.id));
-            return (
-              <TableCell
-                className="CMM-rt-headerArea-tableRow-tableCell"
-                key={index}
-                align={column.headerAlign || 'left'}
-                onClick={(event) => {
-                  if (!disableHeaderCheckbox && column?.id === 'row-selection-chk')
-                    handleSelectAllClick(event);
-                }}
-                {...column.getHeaderProps([{ className: column.className }])}
-                sx={{
-                  whiteSpace: 'nowrap',
-                  py: 1,
-                  height: parameters.current?.headerHeight ? parameters.current?.headerHeight : 40,
-                  maxHeight: parameters.current?.headerHeight
-                    ? parameters.current?.headerHeight
-                    : 40,
-                  borderBottom: '1px solid #d4d8e1 !important',
-                  borderTop: '1px solid #d4d8e1 !important',
-                  backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : '#FAFAFA',
-                  fontSize: '14px',
-                  fontWeight: '500',
-                  maxWidth:
-                    column?.id === 'row-selection-chk' || column?.id === 'no' ? '50px' : null,
-                  display: column.defaultYn === 'N' && 'none',
-                }}
+    return headerGroups.map((headerGroup, i) => (
+      <TableRow
+        className="CMM-rt-headerArea-tableRow"
+        key={i}
+        {...headerGroup.getHeaderGroupProps()}
+        sx={{
+          '& [data-sticky-td]': {
+            backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : '#f5f5f5',
+            fontSize: '14px',
+            fontWeight: '500',
+          },
+        }}
+        height={parameters.current?.headerHeight}
+      >
+        {headerGroup.headers.map((column, index) => {
+          const isSort =
+            column?.id !== 'row-selection-chk' &&
+            column?.id !== 'no' &&
+            (sortList === 'all' || sortList.includes(column.id));
+          return (
+            <TableCell
+              className="CMM-rt-headerArea-tableRow-tableCell"
+              key={index}
+              align={column.headerAlign || 'left'}
+              onClick={(event) => {
+                if (!disableHeaderCheckbox && column?.id === 'row-selection-chk')
+                  handleSelectAllClick(event);
+              }}
+              {...column.getHeaderProps([{ className: column.className }])}
+              sx={{
+                whiteSpace: 'nowrap',
+                py: 1,
+                height: parameters.current?.headerHeight ? parameters.current?.headerHeight : 40,
+                maxHeight: parameters.current?.headerHeight ? parameters.current?.headerHeight : 40,
+                borderBottom: '1px solid #d4d8e1 !important',
+                borderTop: '1px solid #d4d8e1 !important',
+                backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : '#FAFAFA',
+                fontSize: '14px',
+                fontWeight: '500',
+                maxWidth: column?.id === 'row-selection-chk' || column?.id === 'no' ? '50px' : null,
+                display: column.defaultYn === 'N' && 'none',
+              }}
+            >
+              <Stack
+                className="CMM-rt-headerArea-tableRow-tableCell-stack"
+                direction="row"
+                sx={{ height: '100%' }}
+                justifyContent="center"
+                alignItems="center"
               >
-                <Stack
-                  className="CMM-rt-headerArea-tableRow-tableCell-stack"
-                  direction="row"
-                  sx={{ height: '100%' }}
-                  justifyContent="center"
-                  alignItems="center"
-                >
-                  {disableHeaderCheckbox &&
-                  column?.id === 'row-selection-chk' ? null : column?.id === 'row-selection-chk' ? (
-                    column.render(({ getToggleAllPageRowsSelectedProps }) => (
-                      <IndeterminateCheckbox
-                        indeterminate
-                        {...getToggleAllPageRowsSelectedProps()}
-                      />
-                    ))
-                  ) : (
-                    <Typography
-                      className="CMM-rt-headerArea-tableRow-tableCell-stack-typography"
-                      onClick={() => isSort && sortEventHandler(column)}
-                      sx={{ cursor: isSort && 'pointer' }}
-                    >
-                      {column.id === 'row-selection-chk'
-                        ? column.render(({ getToggleAllPageRowsSelectedProps }) => (
-                            <IndeterminateCheckbox
-                              indeterminate
-                              {...getToggleAllPageRowsSelectedProps()}
-                            />
-                          ))
-                        : intl.messages[column.render('Header')]
-                        ? intl.messages[column.render('Header')]
-                        : column.render('Header')}
-                    </Typography>
-                  )}
-                  {parameters.current?.sort?.split(',')[0] &&
-                  isSort &&
-                  column.isSortedDesc === false ? (
-                    <CaretUpOutlined
-                      className="CMM-rt-headerArea-tableRow-tableCell-stack-stack-caretDownOutlined"
-                      style={{
-                        color: theme.palette.success.main,
-                      }}
-                      onClick={() => sortEventHandler(column)}
-                    />
-                  ) : column.isSortedDesc === true ? (
-                    <CaretDownOutlined
-                      className="CMM-rt-headerArea-tableRow-tableCell-stack-stack-caretDownOutlined"
-                      style={{
-                        color: theme.palette.success.main,
-                      }}
-                      onClick={() => sortEventHandler(column)}
-                    />
-                  ) : null}
-                  {'N' === listInfo?.fitWidth && (
-                    <Box
-                      className="CMM-rt-headerArea-tableRow-tableCell-stack-box"
-                      {...column.getResizerProps()}
-                      sx={{ position: 'absolute', right: -6, opacity: 0, zIndex: 1 }}
-                    >
-                      <MinusOutlined className="CMM-rt-headerArea-tableRow-tableCell-stack-box-minusOutlined" />
-                    </Box>
-                  )}
-                </Stack>
-              </TableCell>
-            );
-          })}
-        </TableRow>
-      );
-    });
+                {disableHeaderCheckbox && column?.id === 'row-selection-chk' ? null : column?.id === 'row-selection-chk' ? (
+                  column.render(({ getToggleAllPageRowsSelectedProps }) => (
+                    <IndeterminateCheckbox indeterminate {...getToggleAllPageRowsSelectedProps()} />
+                  ))
+                ) : (
+                  <Typography
+                    className="CMM-rt-headerArea-tableRow-tableCell-stack-typography"
+                    onClick={() => isSort && sortEventHandler(column)}
+                    sx={{ cursor: isSort && 'pointer' }}
+                  >
+                    {column.id === 'row-selection-chk'
+                      ? column.render(({ getToggleAllPageRowsSelectedProps }) => (
+                          <IndeterminateCheckbox indeterminate {...getToggleAllPageRowsSelectedProps()} />
+                        ))
+                      : intl.messages[column.render('Header')]
+                      ? intl.messages[column.render('Header')]
+                      : column.render('Header')}
+                  </Typography>
+                )}
+                {parameters.current?.sort?.split(',')[0] &&
+                isSort &&
+                column.isSortedDesc === false ? (
+                  <CaretUpOutlined
+                    className="CMM-rt-headerArea-tableRow-tableCell-stack-stack-caretDownOutlined"
+                    style={{ color: theme.palette.success.main }}
+                    onClick={() => sortEventHandler(column)}
+                  />
+                ) : column.isSortedDesc === true ? (
+                  <CaretDownOutlined
+                    className="CMM-rt-headerArea-tableRow-tableCell-stack-stack-caretDownOutlined"
+                    style={{ color: theme.palette.success.main }}
+                    onClick={() => sortEventHandler(column)}
+                  />
+                ) : null}
+                {'N' === listInfo?.fitWidth && (
+                  <Box
+                    className="CMM-rt-headerArea-tableRow-tableCell-stack-box"
+                    {...column.getResizerProps()}
+                    sx={{ position: 'absolute', right: -6, opacity: 0, zIndex: 1 }}
+                  >
+                    <MinusOutlined className="CMM-rt-headerArea-tableRow-tableCell-stack-box-minusOutlined" />
+                  </Box>
+                )}
+              </Stack>
+            </TableCell>
+          );
+        })}
+      </TableRow>
+    ));
   };
 
   memoizedColumns.forEach((data) => {
     if (listInfo?.fitWidth === 'N' && data.sticky) fixColumnWidth += data.width;
   });
 
-  // React-virtuoso + OverlayScrollbars 테이블을 감싸는 컴포넌트.
   const Scroller = useCallback(
     forwardRef(function RenderScroller({ children, ...props }, ref) {
       const [initialize, osInstance] = useOverlayScrollbars({
-        // overlayscrollbars 초기화.
         options: {
           scrollbars: {
-            // autoHide: 'move',
             visibility: 'visible',
             theme: theme.palette.mode === 'dark' ? 'os-theme-light' : 'os-theme-dark',
           },
         },
       });
-
-      // 테이블에 scroll bars 달기.
       useEffect(() => {
         initialize({
           target: listInfo?.fitHeight === 'Y' ? ref.current : scrollRef.current,
-          elements: {
-            viewport: listInfo?.fitHeight === 'Y' && ref.current,
-          },
+          elements: { viewport: listInfo?.fitHeight === 'Y' && ref.current },
         });
-
         return () => osInstance()?.destroy();
       }, [initialize]);
-
-      // 페이징 시 넘길 객체.
       useEffect(() => {
         scrollRef.current = osInstance();
       }, [osInstance]);
-
-      // react-virtuoso 외부 프레임 참조 객체 저장 함수.
       const refSetter = useCallback(
         (node) => {
           if (ref && node) {
             ref.current = node;
           }
         },
-        [ref],
+        [ref]
       );
-
       return (
         <TableContainer
           className="CMM-rt-scrollerArea-tableContainer"
           sx={{
             height: listInfo?.fitHeight === 'Y' && 'calc(100vh - 335px)',
-            display: 'flex',
-            flex: 1,
-            '& .os-scrollbar-horizontal': {
-              left: `${fixColumnWidth}px !important`,
-            },
-            '& .os-scrollbar-vertical': {
-              zIndex: '10 !important',
-              visibility: listInfo?.fitHeight === 'N' && 'hidden',
-            },
+            display: listInfo?.fitHeight === 'Y' ? undefined : 'flex',
+            flex: listInfo?.fitHeight === 'Y' ? undefined : 1,
+            flexDirection: listInfo?.fitHeight === 'Y' ? undefined : 'column',
+            '& .os-scrollbar-horizontal': { left: `${fixColumnWidth}px !important` },
+            '& .os-scrollbar-vertical': { zIndex: '10 !important', visibility: listInfo?.fitHeight === 'N' && 'hidden' },
             borderBottom: '1px solid #d4d8e1',
             flexDirection: 'column',
             '& .MuiTableHead-root': {
-              backgroundColor:
-                theme.palette.mode === 'dark' ? '#1E1E1E' : theme.palette.common.white,
+              backgroundColor: theme.palette.mode === 'dark' ? '#1E1E1E' : theme.palette.common.white,
             },
             '& .MuiTableCell-head:after': {
               width: tableMode === 'horizontal' ? '2px !important' : '1px !important',
@@ -1070,12 +913,8 @@
               top: '0 !important',
             },
             '& [data-sticky-last-left-td]': {
-              // 고정
               borderRight: tableMode === 'horizontal' && '1px solid #e6ebf1',
             },
-            // '& .MuiTableBody-root:last-child': {
-            //   borderBottom: '1px solid #f0f0f0',
-            // },
             '& .MuiTableBody-root tr:last-child td': {
               borderBottom: '1px solid #f0f0f0',
             },
@@ -1083,18 +922,12 @@
               borderBottom: theme.palette.mode === 'dark' && '1px solid #e6ebf1',
             },
             '& .MuiTableCell-root': {
-              // 테이블 전체
               borderRight: tableMode === 'vertical' && '1px solid #e6ebf1',
-              ...(id === 'PermissionForm' && {
-                p: 0,
-              }),
+              ...(id === 'PermissionForm' && { p: 0 }),
             },
             '& .MuiTableCell-root:nth-of-type(1)': {
-              // 테이블 전체
               borderLeft: tableMode === 'vertical' && '1px solid #e6ebf1',
-              ...(id === 'PermissionForm' && {
-                p: 0,
-              }),
+              ...(id === 'PermissionForm' && { p: 0 }),
             },
             ...rest.sx,
           }}
@@ -1106,10 +939,9 @@
         </TableContainer>
       );
     }),
-    [theme, tableMode, listInfo],
+    [theme, tableMode, listInfo]
   );
 
-  // react-virtuoso Table Header 정의.
   const Header = useCallback(
     forwardRef(function RenderHeader(props, ref) {
       return (
@@ -1121,32 +953,29 @@
         />
       );
     }),
-    [],
+    []
   );
 
-  // react-virtuoso Table components  정의.
   const TableComponents = useCallback(
     {
       Scroller,
-      Table: (props) => {
-        return (
-          <Table
-            {...getTableProps()}
-            {...props}
-            size="small"
-            stickyHeader
-            className="table sticky CMM-rt-tableArea-table"
-            id={id}
-            sx={{
-              flex: 1,
-              width: 'N' === listInfo?.fitWidth ? totalColumnsWidth : undefined,
-              borderCollapse: 'separate',
-              ...{ ...props.style, ...getTableProps().style },
-            }}
-            ref={tableInfoRef}
-          />
-        );
-      },
+      Table: (props) => (
+        <Table
+          {...getTableProps()}
+          {...props}
+          size="small"
+          stickyHeader
+          className="table sticky CMM-rt-tableArea-table"
+          id={id}
+          sx={{
+            flex: 1,
+            width: 'N' === listInfo?.fitWidth ? totalColumnsWidth : undefined,
+            borderCollapse: 'separate',
+            ...{ ...props.style, ...getTableProps().style },
+          }}
+          ref={tableInfoRef}
+        />
+      ),
       TableHead: Header,
       TableRow: ({ item, ...props }) => {
         const { original, index, isSelected } = item;
@@ -1154,9 +983,7 @@
           return (
             <TableRow
               className="CMM-rt-tableArea-tableRow"
-              {...item.getRowProps({
-                style: { ...props.style, backgroundColor: 'rgba(0,0,0,0)!important' },
-              })}
+              {...item.getRowProps({ style: { ...props.style, backgroundColor: 'rgba(0,0,0,0)!important' } })}
               {...props}
               height={parameters.current?.itemHeight}
             />
@@ -1175,16 +1002,11 @@
               } else if (setColumnCollapse) {
                 setColumnCollapse((prev) => {
                   if (!prev.index) {
-                    return {
-                      ...prev,
-                      index: index + 1,
-                      isOpen: true,
-                    };
+                    return { ...prev, index: index + 1, isOpen: true };
                   } else {
                     return {
                       ...prev,
-                      index:
-                        prev.index - 1 === index ? null : prev.index < index ? index : index + 1,
+                      index: prev.index - 1 === index ? null : prev.index < index ? index : index + 1,
                       isOpen: prev.index - 1 === index ? false : true,
                     };
                   }
@@ -1196,7 +1018,6 @@
           />
         );
       },
-
       TableBody: forwardRef(function RenderBody({ children, ...props }, ref) {
         return (
           <TableBody
@@ -1214,13 +1035,7 @@
                   sx={{ border: '0 !important' }}
                   className="CMM-rt-tableArea-tableBody-tableRow-tableCell"
                 >
-                  <Grid
-                    container
-                    item
-                    justifyContent="center"
-                    my={3}
-                    className="CMM-rt-tableArea-tableBody-tableRow-tableCell-grid"
-                  >
+                  <Grid container item justifyContent="center" my={3} className="CMM-rt-tableArea-tableBody-tableRow-tableCell-grid">
                     데이터가 존재하지 않습니다.
                   </Grid>
                 </TableCell>
@@ -1230,35 +1045,12 @@
         );
       }),
     },
-    [
-      listInfo,
-      totalColumnsWidth,
-      theme,
-      intl,
-      flatHeaders,
-      toggleRowSelected,
-      toggleAllRowsSelected,
-    ],
+    [listInfo, totalColumnsWidth, theme, intl, flatHeaders, toggleRowSelected, toggleAllRowsSelected]
   );
 
-  /* 2024.05.22 - 테이블 헤더 미고정 관련 로직 주석 후
-   *  문제없음 확인되면 관련 주석 삭제 필요.
-   * (유승종, Story book 작업 중 확인)
-   */
-  // useEffect(() => {
-
-  //   if (listInfo.fitHeight !== 'Y') {
-  //     setTimeout(() => {
-  //       setTableHeight(tableInfoRef?.current?.clientHeight);
-  //     }, 100);
-  //   }
-  // }, [tableInfoRef.current]);
-
-  //> 2024.01.08 - 재조회 시 페이징 오류 보완
   const ref = useRef(0);
-
   useEffect(() => {
-    if (ref.current != 0) {
+    if (ref.current !== 0) {
       unstable_batchedUpdates(() => {
         setPageIndex(0);
         setParameters({ ...parameters.current, page: 0 });
@@ -1267,17 +1059,12 @@
     }
     ref.current = gridInfo.total;
   }, []);
-  // }, [gridInfo.total]);
 
   const reloadData = async () => {
     const params = searchParameters ? searchParameters(parameters.current) : parameters.current;
-
     let func = gridInfo.api[`${listFuncName}`];
     if (typeof func === 'function') {
-      const result = await apiCall(gridInfo.api[`${listFuncName}`], {
-        ...params,
-      });
-
+      const result = await apiCall(gridInfo.api[`${listFuncName}`], { ...params });
       if (result.status === 200) {
         setData(result.data.content);
       }
@@ -1285,7 +1072,6 @@
   };
 
   let maxPageSize = Math.ceil(gridInfo.total / size);
-
   const onChangePage = (event, changedPage, changedSize) => {
     if (pageIndex === changedPage) setPageIndex(changedPage);
     if (changedSize !== size) setSize(changedSize);
@@ -1308,10 +1094,7 @@
         components={TableComponents}
         fixedHeaderContent={HeaderContents}
         itemContent={RowContents}
-        sx={{
-          // height: listInfo.fitHeight !== 'Y' && `${tableHeight}px !important`,
-          ...parameters.current?.sx,
-        }}
+        sx={{ ...parameters.current?.sx }}
       />
       {!disabledFooter && listInfo?.showFooter === 'Y' && !enableHsPage && (
         <TablePagination
@@ -1354,147 +1137,40 @@
 }
 
 ReactTable.propTypes = {
-  /**
-   * ReactTable Column 객체 목록 상태 값.
-   * - **HsLib.getGridInfo 함수를 이용해 생성 가능.**
-   */
   columns: PropTypes.array.isRequired,
-  /**
-   * 숨김 컬럼 목록 상태 값.
-   * - **Column accessor 목록**
-   */
   hiddenColumns: PropTypes.array,
-  /**
-   * ReactTable Data 객체 목록 상태 값.
-   * - **Column Accessor key 맵핑.**
-   */
   data: PropTypes.array.isRequired,
-  /**
-   * data 상태 변경 함수.
-   */
   setData: PropTypes.func,
-  /**
-   * ReactTable 페이징 표시 여부.
-   */
   disabledFooter: PropTypes.bool,
-  /**
-   * Row 체크 시 Row 정보를 담을 목록 상태 값.
-   */
   checkList: PropTypes.array,
-  /**
-   * checkList 상태 변경 함수.
-   */
   onChangeChecked: PropTypes.func,
-  /**
-   * ReactTable ID.
-   */
   id: PropTypes.string,
-  /**
-   * ReactTable 관련 정보 객체 상태 값.
-   * - **api: 해당 테이블에서 사용하는 함수를 보유하고 있는 api 객체.**
-   * - **listInfo: 서버로부터 조회한 테이블 설정 정보.**
-   * - **parameters: 해당 테이블에서 사용하는 함수 호출 시 넘겨주는 객체. **
-   * - **total: 전체 데이터 개수.**
-   */
   gridInfo: PropTypes.shape({
     api: PropTypes.object,
     listInfo: PropTypes.object,
     parameters: PropTypes.object,
     total: PropTypes.number,
   }),
-  /**
-   * gridInfo 상태 변경 함수.
-   */
   setGridInfo: PropTypes.func.isRequired,
-  /**
-   * ReactTable 목록 호출 시 넘겨주는 파라미터 객체.
-   * - **useInput hook index 4 값.**
-   * - **useRef 변수 사용.**
-   */
   parameters: PropTypes.shape({ current: PropTypes.object }),
-  /**
-   * parameters 변경 함수.
-   * - **useInput hook index 3 값.**
-   */
   setParameters: PropTypes.func.isRequired,
-  /**
-   * ReactTable 수정 목록 상태 값 변경 함수.
-   * - **ReactTable 수정 가능인 경우만 전달.**
-   * - **data 상태 값과 별개로 선언되는 상태의 변경 함수를 의미.**
-   *
-   * ```
-   * ...생략
-   * const [data,setData] = useState([]);
-   * // 해당 상태 값의 변경 함수.
-   * const [updateList, setUpdateList] = useState([])
-   * ...
-   * ```
-   *
-   */
   setUpdateData: PropTypes.func,
-  /**
-   * ReactTable 목록 호출 시 사용하는 함수명.
-   */
   listFuncName: PropTypes.string,
-  /**
-   * ReactTable 목록 호출 시 파라미터에 대한 추가 작업 함수.
-   * - **ex) Date Format 변환 후 전달.**
-   */
   searchParameters: PropTypes.func,
-  /**
-   * ReactTable Collapse Row 정보 상태 값.
-   * - **index: Row index.**
-   * - **isOpen: Collapse Row 확장 여부.**
-   * - **cellInfo: Collapse Row 표시 내용.**
-   */
   columnCollapse: PropTypes.shape({
     index: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf([null])]),
     isOpen: PropTypes.bool,
     cellInfo: PropTypes.any,
   }),
-  /**
-   * columnCollapse 상태 값 변경 함수.
-   */
   setColumnCollapse: PropTypes.func,
-  /**
-   * Row 상태 값에 할당하고자 하는 객체.
-   */
   rowState: PropTypes.object,
-  /**
-   * ReactTable 페이징 요소 중 전체 데이터 수 표시 여부.
-   */
   totalPage: PropTypes.bool,
-  /**
-   * ReactTable 페이징 요소 중 페이지당 건 수 표시 여부.
-   */
   pageSelectNum: PropTypes.bool,
-  /**
-   * ReactTable 페이징 요소 중 전체 페이지 중 페이지 수 표시 여부.
-   */
   pageInputNum: PropTypes.bool,
-  /**
-   * ReactTable 미니 페이징 사용 여부.
-   */
   miniPaging: PropTypes.bool,
-  /**
-   * Row Select 이벤트 핸들러.
-   * @param {*} item 선택한 Row 정보.
-   * @param {*} toggleRowSelected Row 선택 여부 제어함수.
-   * @param {*} toggleAllRowsSelected 전체 Row 선택 여부 제어함수.
-   */
-  rowSelectHandler: (item, toggleRowSelected, toggleAllRowsSelected) => {},
-  /**
-   * 전체선택 체크박스 사용 여부.
-   */
+  rowSelectHandler: PropTypes.func,
   disableHeaderCheckbox: PropTypes.bool,
-  /**
-   * 그룹 테이블의 기준이 되는 컬럼 accessor 목록.
-   */
   groupBy: PropTypes.arrayOf(PropTypes.string),
-  /**
-   * 정렬 기능을 사용하고자 하는 컬럼 accessor 목록.
-   * - **all 지정 시 모든 컬럼 적용.**
-   */
   sortList: PropTypes.arrayOf(PropTypes.string),
 };
 
diff -urN ..\hss-frontend\src\/components/third-party/react-hook-form/ValidateInput.jsx .\src\/components/third-party/react-hook-form/ValidateInput.jsx
--- ..\hss-frontend\src\/components/third-party/react-hook-form/ValidateInput.jsx	2024-10-18 16:27:14.148452100 +0900
+++ .\src\/components/third-party/react-hook-form/ValidateInput.jsx	2025-03-11 18:55:38.796703500 +0900
@@ -1,12 +1,10 @@
-import React, { useEffect } from 'react';
+import React, { useEffect, useRef } from 'react';
 import { Controller, useFormContext, useWatch } from 'react-hook-form';
 import { useIMask } from 'react-imask';
 import moment from 'moment';
 
 function ValidateInput(props) {
-  const { name, rules, type, onHandleChange, onHandleBlur, checkList, children, maskOptions } =
-    props;
-
+  const { name, rules, type, onHandleChange, onHandleBlur, checkList, children, maskOptions } = props;
   const { control, setValue } = useFormContext();
   const watchValue = useWatch({ control, name, disabled: maskOptions ? false : true });
 
@@ -17,7 +15,7 @@
         maskOptions?.type === 'cellPhone'
           ? '000-0000-0000'
           : maskOptions?.type === 'phone'
-          ? '00[0])0000-0000'
+          ? '00[0]0000-0000'
           : maskOptions?.type === 'ipv4'
           ? 'w.w.w.w'
           : maskOptions?.type === 'ipv6'
@@ -58,121 +56,41 @@
         if (unmaskedValue) setValue(name, value);
         else setValue(name, null);
       },
-    },
-  );
-
-  const ruleOptions = { ...rules };
-
-  // react-imask 입력값 validation.
-  if (maskOptions) {
-    if (maskOptions.type === 'phone') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validatePhone: (value) => {
-          const { unmaskedValue } = maskRef.current;
-          if (
-            !unmaskedValue ||
-            (!value.includes('_') && (unmaskedValue.length === 11 || unmaskedValue.length === 10))
-          )
-            return true;
-          return '전화번호 입력을 확인해주세요.';
-        },
-      };
-    } else if (maskOptions.type === 'cellPhone') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validateCellPhone: (value) => {
-          const { unmaskedValue } = maskRef.current;
-          if (!unmaskedValue || (!value.includes('_') && unmaskedValue.length === 11)) return true;
-          return '핸드폰번호 입력을 확인해주세요.';
-        },
-      };
-    } else if (maskOptions.type === 'email') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validateEmail: (value) => {
-          const { unmaskedValue } = maskRef.current;
-
-          if (unmaskedValue) {
-            const [id, email] = value.split('@');
-            let dotCount = 0;
-
-            if (email != '') {
-              dotCount = email.match(/\./g)?.filter((item) => item !== '').length;
-            }
-
-            const [address, domain, lastDomain] = email.split('.');
-
-            if (dotCount === 1 && id && email && address && domain) return true;
-            if (dotCount === 2 && id && email && address && domain && lastDomain) return true;
-
-            return '올바르지 않은 이메일 형식입니다.';
-          }
-          return true;
-        },
-      };
-    } else if (maskOptions.type === 'ipv4') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validateIpv4: (value) => {
-          const { unmaskedValue } = maskRef.current;
-          if (!unmaskedValue || value.match(/^(?:(?:^|\.)(?:2[0-4]\d|25[0-5]|[01]?\d\d?)){4}$/)) {
-            return true;
-          }
-          return '올바르지 않은 IP 형식입니다.';
-        },
-      };
-    } else if (maskOptions.type === 'ipv6') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validateIpv6: (value) => {
-          const { unmaskedValue } = maskRef.current;
-          if (!unmaskedValue || value.match(/^[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}$/)) {
-            return true;
-          }
-          return '올바르지 않은 IP 형식입니다.';
-        },
-      };
-    } else if (maskOptions.type === 'mac') {
-      ruleOptions.validate = {
-        ...ruleOptions.validate,
-        validateMac: (value) => {
-          const { unmaskedValue } = maskRef.current;
-          if (!unmaskedValue || value.match(/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/)) {
-            return true;
-          }
-          return '올바르지 않은 MAC 형식입니다.';
-        },
-      };
     }
-  }
+  );
 
-  useEffect(() => {
-    if (maskRef && maskRef.current) {
-      maskRef.current.typedValue = watchValue || '';
-      maskRef.current.updateValue();
-    }
-  }, [maskRef, watchValue]);
+  // 기존 watchValue와 maskRef를 동기화하는 useEffect를 제거합니다.
+  // IMask의 onAccept 콜백에서 setValue를 처리하므로, 별도의 updateValue 호출이 불필요하여 무한 업데이트를 방지합니다.
 
+  // checkbox 관련 useEffect (필요 시 별도 관리; 여기서는 제거)
+  // useEffect(() => {
+  //   if (!isSecondCallAllowed.current) return;
+  //   if (type === 'checkbox' && checkList.length !== 0 && checkList.includes(children.props.value)) {
+  //     setValue(name, children.props.value);
+  //   }
+  // }, []);
+
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
-    if (type === 'checkbox' && checkList.length !== 0 && checkList.includes(children.props.value)) {
-      setValue(name, children.props.value);
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
     }
-  }, []);
+    if (!isSecondCallAllowed.current) return;
+    // 다른 부수 효과가 필요하다면 여기에 추가합니다.
+  }, []); 
 
   return (
     <Controller
       className="CMM-li-inputArea-controller"
       control={control}
       name={name}
-      rules={ruleOptions}
-      defaultValue={
-        type === 'checkbox' && checkList.includes(children.props.value)
-          ? children.props.value
-          : children.props?.defaultValue || ''
-      }
+      rules={rules}
+      defaultValue={type === 'checkbox' && checkList.includes(children.props.value) ? children.props.value : children.props?.defaultValue || ''}
       render={({ field }) => {
-        let props = {
+        let propsToPass = {
           ...field,
           ...children.props,
           inputRef: (e) => {
@@ -182,29 +100,27 @@
             }
           },
         };
-        delete props.ref;
-        // Timepicker, Datapicker Value값 Locale적용
+        delete propsToPass.ref;
+
+        // 시간 타입의 경우 moment 적용
         let tempValue = null;
         if (type === 'time1' || type === 'date1' || type === 'dateTime') {
           tempValue = moment(field.value);
         } else {
           tempValue = field.value;
         }
-        // select null 값인 경우, '선택' 옵션 선택하도록 값 변경.
         if (type === 'select' && field.value === null) field.value = '';
 
         if (!maskOptions) {
-          props = {
+          propsToPass = {
             ...children.props,
-            // ...field,
             value: tempValue,
             inputRef: field.ref,
-            checked:
-              type === 'checkbox'
-                ? children.props.value === field.value
-                  ? true
-                  : false
-                : type === 'radio' && field.value === children.props.value,
+            checked: type === 'checkbox'
+              ? children.props.value === field.value
+                ? true
+                : false
+              : type === 'radio' && field.value === children.props.value,
             onChange: function onChange(e) {
               if (onHandleChange) {
                 field.onChange(
@@ -212,8 +128,8 @@
                     value: type === 'dateTime' ? e : children.props.value || e.target.value,
                     name,
                     type,
-                    checked: !type === 'dateTime' && e.target.checked,
-                  }),
+                    checked: type !== 'dateTime' && e.target.checked,
+                  })
                 );
               } else {
                 if (type === 'checkbox') {
@@ -223,7 +139,6 @@
                 } else if (type === 'day1') {
                   let newValue;
                   let index = field.value && field.value.indexOf(e.target.value);
-
                   if (e.target.value === '0') {
                     if (field.value.length >= 7) {
                       newValue = [];
@@ -234,21 +149,16 @@
                     if (field.value && index >= 0) {
                       newValue = field.value.slice();
                       newValue.splice(index, 1);
-
                       index = field.value && field.value.indexOf('0');
                       if (newValue.length === 1 && index >= 0) {
                         newValue.splice(index, 1);
                       }
                     } else {
-                      newValue = field.value
-                        ? field.value.concat(e.target.value)
-                        : [e.target.value];
-
+                      newValue = field.value ? field.value.concat(e.target.value) : [e.target.value];
                       if (newValue.length === 7) {
                         newValue.push('0');
                       }
                     }
-
                     index = newValue && newValue.indexOf('0');
                     if (newValue.length < 8 && index >= 0) {
                       newValue.splice(index, 1);
@@ -261,30 +171,24 @@
                 }
               }
             },
-            // selected: type === 'day1' ? (field.value.length >= 7 ? true : false) : false,
           };
-          delete props.ref;
-
+          delete propsToPass.ref;
           if (type === 'day1') {
-            delete props.inputRef;
+            delete propsToPass.inputRef;
           }
         }
 
         if (onHandleBlur) {
-          props = {
-            ...props,
+          propsToPass = {
+            ...propsToPass,
             onBlur: function onBlur(e) {
-              field.onBlur(
-                onHandleBlur({
-                  value: children.props.value || e.target.value,
-                }),
-              );
+              field.onBlur(onHandleBlur({ value: children.props.value || e.target.value }));
             },
           };
         }
 
         return React.createElement(children.type, {
-          ...props,
+          ...propsToPass,
         });
       }}
     />
diff -urN ..\hss-frontend\src\/modules/axios/index.js .\src\/modules/axios/index.js
--- ..\hss-frontend\src\/modules/axios/index.js	2024-10-18 16:27:14.149446200 +0900
+++ .\src\/modules/axios/index.js	2025-03-07 09:07:03.375622100 +0900
@@ -319,7 +319,7 @@
               return error.request;
             } else {
               // 요청을 설정하는 동안 문제발생.
-              console.log('Error', error.message);
+              console.log('Error axios/index.js', error.message);
               return error.message;
             }
           }
diff -urN ..\hss-frontend\src\/modules/common/HsLib.js .\src\/modules/common/HsLib.js
--- ..\hss-frontend\src\/modules/common/HsLib.js	2024-10-30 10:15:29.824850300 +0900
+++ .\src\/modules/common/HsLib.js	2025-03-11 14:04:08.059269600 +0900
@@ -2,6 +2,201 @@
 import { getSession } from 'next-auth/react';
 import moment from 'moment';
 import _ from 'lodash';
+/*
+
+// ZONE 상태 수정 (재시도 로직 포함)
+async function updateZoneStatusInternal(id, retryCount = 3) {
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const result = await zoneApi.axios.post('/api/sslvpn/zone', {
+      run_type: 'put',
+      status: true,
+      name: id,
+      signal,
+    });
+    if (!result.data.errorYn) {
+      return 'ZONE 상태 정보가 수정 되었습니다.';
+    }
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return updateZoneStatusInternal(id, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return 'ZONE 상태 정보 수정이 실패되었습니다.';
+  }
+}
+*/
+async function  getGridInfoInternal(listCode, api, openModal, callbackList = [],retryCount = 3){
+  try {
+    const controller = new AbortController();
+    const signal = controller.signal;
+    const gridInfo = await api.axios.get('/api/gridInfo?listCode=' + listCode,{signal});
+    return HsLib.getGridColumn(gridInfo.data, api, callbackList, openModal);
+  } catch (error) {
+    if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+      await new Promise((resolve) => setTimeout(resolve, 1000));
+      return getGridInfoInternal(listCode, api, openModal, callbackList, retryCount - 1);
+    }
+    if (error.response && error.response.data.errorYn) {
+      const errorMessage = error.response.data.error.errorMessage;
+      let finalErrorMessage = '';
+      if (typeof errorMessage === 'object') {
+        finalErrorMessage = Object.values(errorMessage).flat().shift();
+      } else {
+        finalErrorMessage = errorMessage;
+      }
+      return finalErrorMessage;
+    }
+    return { listInfo: {}, columns: [] };
+  }
+}
+
+async function getGridColumnInternal(gridInfo, api, callbackList, openModal,retryCount = 3){
+  const listInfo = gridInfo.listInfo;
+  const columnInfo = gridInfo.cellInfo;
+
+  let columns = [];
+  if (!_.isEmpty(listInfo) && listInfo[0].useChecked === 'Y') {
+    columns = [
+      {
+        id: 'row-selection-chk',
+        accessor: 'Selection',
+        sticky: listInfo[0].fixCells !== 0 ? 'left' : undefined,
+        width: 50,
+        minWidth: 50,
+        // maxWidth: '50px',
+      },
+    ];
+  }
+  // 컬럼 추가 정보
+  let addColumn = {};
+
+  // Editable 가능 컬럼
+  let editColumn = [];
+
+  // no 컬럼을 사용하는지 확인.
+  const existNo = columnInfo.find((data) => data.cellName === 'no');
+  for (let i = 0; i < columnInfo.length; i++) {
+    const column = columnInfo[`${i}`];
+    let newValue;
+    column['valueOptions'] = [];
+
+    // 컬럼 고정
+    if (listInfo[0].fixCells !== 0 && i + 1 <= listInfo[0].fixCells) column.sticky = 'left';
+
+    // 컬럼 타입 설정
+    const cellType = column.cellType;
+    // Text
+    if (cellType === 'T') {
+      column.type = 'string';
+      newValue = '';
+      // Number or Number(,)
+    } else if (cellType === 'M' || cellType === 'I') {
+      column.type = 'number';
+      newValue = 0;
+      // Date
+    } else if (cellType === 'D') {
+      column.type = 'date';
+      newValue = '';
+      // Combo
+    } else if (cellType === 'C') {
+      try {
+        const controller = new AbortController();
+        const signal = controller.signal;
+        column.type = 'select';
+        const codeResult = await api.axios.get(
+          '/api/system/codes/all?codeType=' + column.cellParam + '&deleteYn=N',
+          {signal}
+        );
+        const codes = codeResult.data.resultData;
+        if (codes.length > 0) {
+          codes.forEach((code) => {
+            column['valueOptions'].push({ value: code.codeValue, label: code.codeDesc });
+          });
+          newValue = codes[0].codeValue;
+        } else {
+          column.type = 'string';
+          newValue = '';
+        }
+      } catch (error) {
+        if ((error.name === 'CanceledError' || error.code === 'ERR_CANCELED') && retryCount > 0) {
+          await new Promise((resolve) => setTimeout(resolve, 1000));
+          return getGridColumnInternal(gridInfo, api, callbackList, openModal,retryCount -1);
+        }
+        if (error.response) {
+          const {
+            errorYn,
+            error: { errorMessage },
+          } = error.response.data;
+
+          if (errorYn) {
+            openModal({
+              message: errorMessage || '오류가 발생했습니다. 관리자에게 문의해주시기 바랍니다.',
+              type: 'error',
+            });
+          }
+        } else if (error.request) {
+          console.log(error.request);
+        } else {
+          console.log('Error', error.message);
+        }
+      }
+    } else if (cellType === 'o') {
+      column.type = 'select';
+      // No
+    } else if (cellType === 'N') {
+      column.type = 'number';
+      newValue = '-';
+    }
+
+    // attribute type이 Button인 경우, 콜백 함수 설정.
+    if (column.attributeType === 'B') {
+      for (let i = 0; i < callbackList.length; i++) {
+        if (callbackList[`${i}`].accessor === column.cellName) {
+          column.buttonCallback = callbackList[`${i}`].func;
+          break;
+        }
+      }
+    }
+
+    // 변환된 컬럼 정보 colums에 추가
+    // if(i===columns.length-1 ) column.cellWidth = null;
+    columns.push(HsLib.getReactTableColumnAuto(column));
+
+    // 추가할 컬럼의 초기값 입력
+    addColumn[column.cellName] = newValue;
+
+    // 컬럼 수정 여부
+    // if (column.editableYn === 'N') editColumn.push(column.cellName);
+  }
+  // no 컬럼이 존재하지 않는 경우, EditableCell 동작할 수 있게 값 추가.
+  if (!existNo) {
+    addColumn['no'] = '-';
+  }
+  // 컬럼 추가 Row 구분 Flag.
+  addColumn['addColumnFlag'] = true;
+  // 컬럼 추가시 초기 상태
+  addColumn['status'] = 'I';
+  return {
+    columns: columns,
+    addColumn: addColumn,
+    editColumn: editColumn,
+    listInfo: listInfo[0] || {},
+  };
+};
+
+
 
 const HsLib = {
   //
@@ -470,177 +665,10 @@
     }
   },
   //그리드 정보 조회
-  getGridInfo: async (listCode, api, openModal, callbackList = []) => {
-    try {
-      // const gridInfo = await api.getGridInfo(listCode);
-      const gridInfo = await api.axios.get('/api/gridInfo?listCode=' + listCode);
-      return HsLib.getGridColumn(gridInfo.data, api, callbackList, openModal);
-    } catch (error) {
-      if (error.response) {
-        // 요청이 전송되었고, 서버는 2xx 외의 코드로 응답.
-        const {
-          errorYn,
-          error: { errorMessage },
-        } = error.response.data;
-
-        if (errorYn && openModal) {
-          openModal({
-            message: errorMessage || '오류가 발생했습니다. 관리자에게 문의해주시기 바랍니다.',
-            type: 'error',
-          });
-        }
-      } else if (error.request) {
-        // 요청이 전송되었지만, 응답이 수신되지 않음.
-        console.log(error.request);
-      } else {
-        // 요청을 설정하는 동안 문제발생.
-        console.log('Error', error.message);
-      }
-
-      return { listInfo: {}, columns: [] };
-    }
-  },
+  getGridInfo: getGridInfoInternal,
 
   // 그리드 컬럼 정보 조회
-  getGridColumn: async (gridInfo, api, callbackList, openModal) => {
-    // 그리드 정보
-    const listInfo = gridInfo.listInfo;
-    // 셀 정보
-    const columnInfo = gridInfo.cellInfo;
-
-    // 체크박스 추가
-    let columns = [];
-    if (!_.isEmpty(listInfo) && listInfo[0].useChecked === 'Y') {
-      columns = [
-        {
-          id: 'row-selection-chk',
-          accessor: 'Selection',
-          sticky: listInfo[0].fixCells !== 0 ? 'left' : undefined,
-          width: 50,
-          minWidth: 50,
-          // maxWidth: '50px',
-        },
-      ];
-    }
-    // 컬럼 추가 정보
-    let addColumn = {};
-
-    // Editable 가능 컬럼
-    let editColumn = [];
-
-    // no 컬럼을 사용하는지 확인.
-    const existNo = columnInfo.find((data) => data.cellName === 'no');
-    for (let i = 0; i < columnInfo.length; i++) {
-      const column = columnInfo[`${i}`];
-      let newValue;
-      column['valueOptions'] = [];
-
-      // 컬럼 고정
-      if (listInfo[0].fixCells !== 0 && i + 1 <= listInfo[0].fixCells) column.sticky = 'left';
-
-      // 컬럼 타입 설정
-      const cellType = column.cellType;
-      // Text
-      if (cellType === 'T') {
-        column.type = 'string';
-        newValue = '';
-        // Number or Number(,)
-      } else if (cellType === 'M' || cellType === 'I') {
-        column.type = 'number';
-        newValue = 0;
-        // Date
-      } else if (cellType === 'D') {
-        column.type = 'date';
-        newValue = '';
-        // Combo
-      } else if (cellType === 'C') {
-        try {
-          column.type = 'select';
-          /**
-           * 2023.11.21 - 조회 응답 데이터 (resultData -> content / total -> totalElements 로 통일.)
-           * getComboInfo back-end 작성 시 참고 필요.
-           **/
-          // const codeResult = await api.getComboInfo(column.cellParam, api);
-          const codeResult = await api.axios.get(
-            '/api/system/codes/all?codeType=' + column.cellParam + '&deleteYn=N',
-          );
-          // const codes = codeResult.data.content;
-          // if (codeResult.data.totalElements !== 0) {
-          const codes = codeResult.data.resultData;
-          if (codes.length > 0) {
-            codes.forEach((code) => {
-              column['valueOptions'].push({ value: code.codeValue, label: code.codeDesc });
-            });
-            newValue = codes[0].codeValue;
-          } else {
-            column.type = 'string';
-            newValue = '';
-          }
-        } catch (error) {
-          if (error.response) {
-            // 요청이 전송되었고, 서버는 2xx 외의 코드로 응답.
-            const {
-              errorYn,
-              error: { errorMessage },
-            } = error.response.data;
-
-            if (errorYn) {
-              openModal({
-                message: errorMessage || '오류가 발생했습니다. 관리자에게 문의해주시기 바랍니다.',
-                type: 'error',
-              });
-            }
-          } else if (error.request) {
-            // 요청이 전송되었지만, 응답이 수신되지 않음.
-            console.log(error.request);
-          } else {
-            // 요청을 설정하는 동안 문제발생.
-            console.log('Error', error.message);
-          }
-        }
-      } else if (cellType === 'o') {
-        column.type = 'select';
-        // No
-      } else if (cellType === 'N') {
-        column.type = 'number';
-        newValue = '-';
-      }
-
-      // attribute type이 Button인 경우, 콜백 함수 설정.
-      if (column.attributeType === 'B') {
-        for (let i = 0; i < callbackList.length; i++) {
-          if (callbackList[`${i}`].accessor === column.cellName) {
-            column.buttonCallback = callbackList[`${i}`].func;
-            break;
-          }
-        }
-      }
-
-      // 변환된 컬럼 정보 colums에 추가
-      // if(i===columns.length-1 ) column.cellWidth = null;
-      columns.push(HsLib.getReactTableColumnAuto(column));
-
-      // 추가할 컬럼의 초기값 입력
-      addColumn[column.cellName] = newValue;
-
-      // 컬럼 수정 여부
-      // if (column.editableYn === 'N') editColumn.push(column.cellName);
-    }
-    // no 컬럼이 존재하지 않는 경우, EditableCell 동작할 수 있게 값 추가.
-    if (!existNo) {
-      addColumn['no'] = '-';
-    }
-    // 컬럼 추가 Row 구분 Flag.
-    addColumn['addColumnFlag'] = true;
-    // 컬럼 추가시 초기 상태
-    addColumn['status'] = 'I';
-    return {
-      columns: columns,
-      addColumn: addColumn,
-      editColumn: editColumn,
-      listInfo: listInfo[0] || {},
-    };
-  },
+  getGridColumn: getGridColumnInternal,
 
   // 그리드 마지막 ID 조회
   getId: (table) => {
diff -urN ..\hss-frontend\src\/modules/common/HsLibV2.js .\src\/modules/common/HsLibV2.js
--- ..\hss-frontend\src\/modules/common/HsLibV2.js	2024-10-18 16:27:14.152448600 +0900
+++ .\src\/modules/common/HsLibV2.js	2025-03-07 09:07:51.075873300 +0900
@@ -484,7 +484,7 @@
         console.log(error.request);
       } else {
         // 요청을 설정하는 동안 문제발생.
-        console.log('Error', error.message);
+        console.log('Error HSlibV2.js 1', error.message);
       }
 
       return { listInfo: {} };
@@ -594,7 +594,7 @@
             console.log(error.request);
           } else {
             // 요청을 설정하는 동안 문제발생.
-            console.log('Error', error.message);
+            console.log('Error HsLibV2.js 2', error.message);
           }
         }
       } else if (cellType === 'o') {
diff -urN ..\hss-frontend\src\/modules/hooks/useApi.js .\src\/modules/hooks/useApi.js
--- ..\hss-frontend\src\/modules/hooks/useApi.js	2024-10-18 16:27:14.153447700 +0900
+++ .\src\/modules/hooks/useApi.js	2025-03-07 09:08:16.962050700 +0900
@@ -44,7 +44,7 @@
         return error.request;
       } else {
         // 요청을 설정하는 동안 문제발생.
-        console.log('Error', error.message);
+        console.log('Error useApi.js 1', error.message);
         return error.message;
       }
     }
@@ -79,7 +79,7 @@
           return error.request;
         } else {
           // 요청을 설정하는 동안 문제발생.
-          console.log('Error', error.message);
+          console.log('Error useApi.js 2', error.message);
           return error.message;
         }
       }
diff -urN ..\hss-frontend\src\/modules/utils/route-guard/PermissionGuard.js .\src\/modules/utils/route-guard/PermissionGuard.js
--- ..\hss-frontend\src\/modules/utils/route-guard/PermissionGuard.js	2024-10-18 16:27:14.192082100 +0900
+++ .\src\/modules/utils/route-guard/PermissionGuard.js	2025-03-10 15:24:26.961851700 +0900
@@ -16,28 +16,20 @@
 import codeApi from '@api/system/codeApi';
 import { setAllCodeList } from '@modules/redux/reducers/code';
 
-// ==============================|| AUTH GUARD ||============================== //
-
 const checkMenu = (menuList, currentPath, menuRef) => {
   return menuList.find((menu) => {
     if (menu.type !== 'item' && menu.children.length !== 0) {
-      const pMenu = checkMenu(menu.children, currentPath, menuRef);
-      if (pMenu) {
-        return pMenu;
-      }
+      return checkMenu(menu.children, currentPath, menuRef);
     } else if (menu.type === 'item') {
       const urlList = menu.url.split('/').filter((url) => url);
-      const sameEl = menu.url
-        .split('/')
-        .filter((url) => url && currentPath.split('/').includes(url));
-      let urlMatch = false;
+      const sameEl = menu.url.split('/').filter((url) => url && currentPath.split('/').includes(url));
 
+      let urlMatch = false;
       if (sameEl.length >= urlList.length - 1) {
         let preUrl = '/';
         for (let i = 0; i < urlList.length - 1; i++) {
-          preUrl += `${urlList[`${i}`]}/`;
+          preUrl += `${urlList[i]}/`;
         }
-        // eslint-disable-next-line security/detect-non-literal-regexp
         let regexp = new RegExp(`^${preUrl}${menu.subUrlRegex}$`, 'gi');
         urlMatch = regexp.test(currentPath);
       }
@@ -52,7 +44,7 @@
 const checkPmenu = (list = [], target) => {
   let pMenuId = '';
   for (let i = 0; i < list.length; i++) {
-    const menu = list[`${i}`];
+    const menu = list[i];
 
     if (target === menu.menuId) {
       return menu;
@@ -71,73 +63,89 @@
 const PermissionGuard = ({ children, auth }) => {
   const dispatch = useDispatch();
   const { selectedTopMenu } = useSelector((state) => state.menu);
-
   const { data: session, update: sessionUpdate } = useSession();
   const router = useRouter();
   const menuRef = useRef(null);
+  //const isMountedRef = useRef(false);
 
   const [isPermit, setIsPermit] = useState(true);
   const [menuList, setMenuList] = useState([]);
   const [roleList, setRoleList] = useState([]);
+  const [loading, setLoading] = useState(true);
 
   const { flag } = router.query;
 
-  // api 호출 함수
+  // API 호출 함수
   const [apiCall, openModal] = useApi();
 
-  const { instance, source } = AuthInstance();
-
+  const { instance } = AuthInstance();
   menuApi.axios = instance;
   adminApi.axios = instance;
   codeApi.axios = instance;
 
-  let currentPath = document.location.pathname;
-
+  let currentPath = typeof window !== "undefined" ? window.location.pathname : "";
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+
+
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+
+    if (!isSecondCallAllowed.current){
+      return;
+    } 
+
     const getMenuList = async () => {
-      const menuRequest = apiCall(menuApi.getMenuList, { useYn: 'Y', isMenu: true, common: true });
-      const roleRequest = apiCall(adminApi.getUserRoleList, {
-        userSeq: session.user.userSeq,
-        common: true,
-      });
-      const [menuResult, roleResult] = await Promise.all([menuRequest, roleRequest]);
+      try {
+        const menuRequest = apiCall(menuApi.getMenuList, { useYn: 'Y', isMenu: true, common: true});
+        const roleRequest = apiCall(adminApi.getUserRoleList, { userSeq: session?.user?.userSeq, common: true });
+        const [menuResult, roleResult] = await Promise.all([menuRequest, roleRequest]);
+
+        if (menuResult.status === 200) {
+          if (menuResult.data?.firstDisplayMenu && session.user.firstPage !== menuResult.data.firstDisplayMenu) {
+            sessionUpdate({ firstPage: menuResult.data.firstDisplayMenu });
+          }
 
-      if (menuResult.status === 200) {
-        if (
-          menuResult.data?.firstDisplayMenu &&
-          session.user.firstPage !== menuResult.data.firstDisplayMenu
-        ) {
-          sessionUpdate({
-            firstPage: menuResult.data.firstDisplayMenu,
-          });
+          let pMenuId = checkPmenu(menuResult.data.menuList, menuResult.data.firstMenuPid);
+          if (!selectedTopMenu) dispatch(setSelectedTopMenu({ selectedTopMenu: pMenuId }));
+
+          setMenuList(menuResult.data.menuList);
         }
-        let pMenuId = checkPmenu(menuResult.data.menuList, menuResult.data.firstMenuPid);
 
-        if (!selectedTopMenu) dispatch(setSelectedTopMenu({ selectedTopMenu: pMenuId }));
-        setMenuList(menuResult.data.menuList);
-      }
-      if (roleResult.status === 200) {
-        setRoleList(roleResult.data);
+        if (roleResult.status === 200) {
+          setRoleList(roleResult.data);
+        }
+      } catch (error) {
+        if (error.name !== 'AbortError') {
+          console.error('메뉴 목록 로딩 중 오류:', error);
+        }
+      } finally {
+        setLoading(false);
       }
     };
 
     if (session) getMenuList();
+
     return () => {
-      source.cancel();
+      //controller.abort();
     };
-  }, [currentPath]);
+  }, [session]);
 
   useEffect(() => {
-    let mounted = true;
     const checkPermission = () => {
-      if (menuList?.length !== 0 && !auth && roleList.length !== 0) {
+      if (menuList.length !== 0 && !auth && roleList.length !== 0) {
         menuRef.current = null;
         const topMenu = checkMenu(menuList, currentPath, menuRef);
+
         const menuRoleList = roleList
-          .filter((role) => role?.indexOf(menuRef.current?.menuCode) !== -1)
+          .filter((role) => role?.includes(menuRef.current?.menuCode))
           .map((role) => role?.slice(-1));
+
         if (
-          mounted &&
           menuRef.current &&
           topMenu &&
           (flag
@@ -146,11 +154,7 @@
             : true)
         ) {
           setIsPermit(true);
-          dispatch(
-            setMenuRoleList({
-              menuRoleList: menuRoleList,
-            }),
-          );
+          dispatch(setMenuRoleList({ menuRoleList }));
           dispatch(setSelectedTopMenu({ selectedTopMenu: topMenu.menuId }));
           dispatch(
             setMenuItem({
@@ -163,40 +167,34 @@
             }),
           );
         } else {
-          if (router.back === undefined) {
-            openModal({
-              message: '접근 권한이 없습니다.',
-              type: 'error',
-              onConfirm: () => router.reload(),
-            });
-          } else {
-            openModal({
-              message: '접근 권한이 없습니다.',
-              type: 'error',
-              onConfirm: () => router.push(session.user.firstPage),
-            });
-          }
+          openModal({
+            message: '접근 권한이 없습니다.',
+            type: 'error',
+            onConfirm: () => router.push(session?.user?.firstPage || '/'),
+          });
           setIsPermit(false);
         }
       }
     };
+
     if (session) checkPermission();
-    return () => {
-      mounted = false;
-    };
-  }, [menuList, currentPath, roleList]);
+  }, [menuList, roleList, currentPath]);
+
 
   useEffect(() => {
     const getAllCodeList = async () => {
-      const result = await apiCall(codeApi.getTotalCodeList, '');
-
-      dispatch(setAllCodeList(result));
+      try {
+        const result = await apiCall(codeApi.getTotalCodeList);
+        dispatch(setAllCodeList(result));
+      } catch (error) {
+        console.error("코드 목록 로딩 중 오류:", error);
+      }
     };
     getAllCodeList();
   }, []);
 
-  if (isPermit || auth) return children;
-  else return <Loader />;
+  if (loading) return <Loader />;
+  return isPermit || auth ? children : <Loader />;
 };
 
 PermissionGuard.propTypes = {
diff -urN ..\hss-frontend\src\/pages/_app.jsx .\src\/pages/_app.jsx
--- ..\hss-frontend\src\/pages/_app.jsx	2024-10-18 16:27:14.193089100 +0900
+++ .\src\/pages/_app.jsx	2025-03-10 18:57:19.281516600 +0900
@@ -1,6 +1,8 @@
+'use client';
+
 import Head from 'next/head';
-import { useStore } from 'react-redux';
-import { wrapper } from '@modules/redux';
+import { Provider } from 'react-redux';
+import { wrapper } from '@modules/redux'; // store 생성 관련 코드가 포함된 파일에서 가져오기
 import { PersistGate } from 'redux-persist/integration/react';
 import { SessionProvider } from 'next-auth/react';
 import { ConfigProvider } from '@modules/contexts/ConfigContext';
@@ -11,20 +13,26 @@
 import ConfirmAlert from '@components/modules/common/ConfirmAlert';
 import { useEffect } from 'react';
 import Loader from '@components/mantis/Loader';
+import CustomModal from '@components/modules/common/CustomModal';
 
 import { AdapterMoment } from '@mui/x-date-pickers/AdapterMoment';
 import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
 
 import Locales from '@components/Locales';
-import 'simplebar/src/simplebar.css';
+import 'simplebar-react/dist/simplebar.min.css';
 import 'overlayscrollbars/overlayscrollbars.css';
 import '@styles/common.css';
 import 'moment/locale/ko';
-import CustomModal from '@components/modules/common/CustomModal';
 
-function App({ Component, pageProps: { session, ...pageProps } }) {
+import { ThemeProvider, StyledEngineProvider, createTheme } from '@mui/material/styles';
+import CssBaseline from '@mui/material/CssBaseline';
+
+const theme = createTheme();
+function App({ Component, pageProps }) {
+  const session = pageProps?.session ?? null;
+  // wrapper.useWrappedStore()를 통해 store와 persistor 가져오기
+  const { store, props } = wrapper.useWrappedStore(pageProps);
   const getLayout = Component.getLayout ?? ((page) => page);
-  const store = useStore();
 
   useEffect(() => {
     const addLicense5 = async () => {
@@ -48,37 +56,44 @@
 
   return (
     <SessionProvider session={session}>
-      <PersistGate persistor={store.__persistor}>
-        <ConfigProvider>
-          <ThemeCustomization>
-            <Locales>
-              <ScrollTop>
-                <LocalizationProvider
-                  dateAdapter={AdapterMoment}
-                  adapterLocale="ko"
-                  localeText={{
-                    cancelButtonLabel: '취소',
-                    okButtonLabel: '확인',
-                  }}
-                >
-                  <Head>
-                    <title>SecureGate</title>
-                    <link rel="icon" href="/favicon.ico" />
-                  </Head>
-                  <Snackbar />
-                  <Alert />
-                  <Loader />
-                  <ConfirmAlert />
-                  <CustomModal />
-                  {getLayout(<Component {...pageProps} />)}
-                </LocalizationProvider>
-              </ScrollTop>
-            </Locales>
-          </ThemeCustomization>
-        </ConfigProvider>
-      </PersistGate>
+      <Provider store={store}>
+        <PersistGate persistor={store.__persistor} loading={<div>Loading...</div>}>
+          <StyledEngineProvider injectFirst>
+            <ThemeProvider theme={theme}>
+              <CssBaseline />
+              <ThemeCustomization>
+                <ConfigProvider>
+                  <Locales>
+                    <ScrollTop>
+                      <LocalizationProvider
+                        dateAdapter={AdapterMoment}
+                        adapterLocale="ko"
+                        localeText={{
+                          cancelButtonLabel: '취소',
+                          okButtonLabel: '확인',
+                        }}
+                      >
+                        <Head>
+                          <title>SecureGate</title>
+                          <link rel="icon" href="/favicon.ico" />
+                        </Head>
+                        <Snackbar />
+                        <Alert />
+                        <Loader />
+                        <ConfirmAlert />
+                        <CustomModal />
+                        {getLayout(<Component {...props.pageProps} />)}
+                      </LocalizationProvider>
+                    </ScrollTop>
+                  </Locales>
+                </ConfigProvider>
+              </ThemeCustomization>
+            </ThemeProvider>
+          </StyledEngineProvider>
+        </PersistGate>
+      </Provider>
     </SessionProvider>
   );
 }
 
-export default wrapper.withRedux(App);
+export default App;
diff -urN ..\hss-frontend\src\/pages/cds/policyManage/destinationPolicyList.jsx .\src\/pages/cds/policyManage/destinationPolicyList.jsx
--- ..\hss-frontend\src\/pages/cds/policyManage/destinationPolicyList.jsx	2024-10-18 16:27:14.198084600 +0900
+++ .\src\/pages/cds/policyManage/destinationPolicyList.jsx	2025-03-08 16:16:58.975389400 +0900
@@ -183,7 +183,6 @@
       const gridInfo = await HsLib.getGridInfo('DestinationList', policyDestinationApi);
       // 정책현황 목록 요청
 
-      console.log(gridInfo);
       // 일괄 변경처리
       unstable_batchedUpdates(() => {
         // 테이블, 컬럼정보 응답처리
diff -urN ..\hss-frontend\src\/pages/hss/networkManage/interfaceManage/index.jsx .\src\/pages/hss/networkManage/interfaceManage/index.jsx
--- ..\hss-frontend\src\/pages/hss/networkManage/interfaceManage/index.jsx	2025-02-19 14:50:03.887808900 +0900
+++ .\src\/pages/hss/networkManage/interfaceManage/index.jsx	2025-03-08 16:08:03.428239700 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect } from 'react';
+import { useCallback, useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -38,11 +38,9 @@
 
   const init = async () => {
     const gridInfo = await HsLib.getGridInfo('InterfaceList', interfaceApi);
-
     unstable_batchedUpdates(() => {
       responseGridInfo(gridInfo);
     });
-
     getInterfaceNameList();
     getInterfaceMemberList();
     getInterfaceTypeList();
@@ -59,14 +57,14 @@
   };
 
   const getInterfaceList = async (param) => {
-    const { totalElements, content } = await apiCall(interfaceApi.getInterfaceList, param);
-
-    dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    const { totalElements, content } = await apiCall(interfaceApi.getInterfaceList, param);   
+    if(content){
+      dispatch(setPageDataList({ pageDataList: content, totalElements }));
+    }
   };
 
   const getInterfaceNameList = useCallback(async () => {
     const data = await apiCall(interfaceApi.getInterfaceColumnList, 'name');
-
     if (data) {
       const list = data.map((item) => ({
         value: item,
@@ -78,7 +76,6 @@
 
   const getInterfaceMemberList = useCallback(async () => {
     const data = await apiCall(interfaceApi.getInterfaceMemberList, 'member');
-
     if (data) {
       const list = data.map((item) => ({
         value: item,
@@ -90,7 +87,6 @@
 
   const getInterfaceTypeList = useCallback(async () => {
     const data = await apiCall(interfaceApi.getInterfaceColumnList, 'type');
-
     if (data) {
       const uniqueData = _.uniq(data); // 중복값 제거
       const list = uniqueData.map((item) => ({
@@ -100,15 +96,26 @@
       dispatch(setInterfaceTypeList(list));
     }
   }, []);
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender01 = useRef(true);
+  const isSecondCallAllowed01 = useRef(isStrictMode);
+  
   useEffect(() => {
+    if (isFirstRender01.current) {
+      isFirstRender01.current = false;
+      return;
+    }
+    if (!isSecondCallAllowed01.current){
+      return;
+    } 
+
     init();
 
     return () => {
       source.cancel();
     };
   }, []);
-
+  
   useEffect(() => {
     getInterfaceList(parameterData.parameters.current);
   }, [size, page]);
diff -urN ..\hss-frontend\src\/pages/hss/sslswgManage/policyDetailManage/srcIpManage/index.jsx .\src\/pages/hss/sslswgManage/policyDetailManage/srcIpManage/index.jsx
--- ..\hss-frontend\src\/pages/hss/sslswgManage/policyDetailManage/srcIpManage/index.jsx	2025-03-12 13:30:03.217968000 +0900
+++ .\src\/pages/hss/sslswgManage/policyDetailManage/srcIpManage/index.jsx	2025-03-11 18:15:41.922936700 +0900
@@ -6,26 +6,22 @@
 import { useEffect, useState } from 'react';
 
 const tabList = [
-  {
-    label: '출발지IP 그룹',
-    value: 'srcIpGroupStatus',
-  },
-  {
-    label: '출발지IP',
-    value: 'srcIpStatus',
-  },
+  { label: '출발지IP 그룹', value: 'srcIpGroupStatus' },
+  { label: '출발지IP', value: 'srcIpStatus' },
 ];
 
 function SrcIpManage() {
   const router = useRouter();
   const { tab } = router.query;
-  const [tabValues, setTabValues] = useState(tab || 'srcIpStatus');
+  // 초기값은 'srcIpStatus'로 설정합니다.
+  const [tabValues, setTabValues] = useState('srcIpStatus');
 
   useEffect(() => {
-    if (tab && tabList.some((t) => t.value === tab)) {
+    // tab이 존재하고, 유효하며 현재 상태와 다를 때만 업데이트
+    if (tab && tabList.some((t) => t.value === tab) && tab !== tabValues) {
       setTabValues(tab);
     }
-  }, [tab]);
+  }, [tab, tabValues]);
 
   return (
     <>
diff -urN ..\hss-frontend\src\/pages/hss/sslvpnManage/userManage/index.jsx .\src\/pages/hss/sslvpnManage/userManage/index.jsx
--- ..\hss-frontend\src\/pages/hss/sslvpnManage/userManage/index.jsx	2025-02-19 14:50:03.896808900 +0900
+++ .\src\/pages/hss/sslvpnManage/userManage/index.jsx	2025-03-11 16:32:27.078237400 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect } from 'react';
+import { useCallback, useEffect,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -96,7 +96,16 @@
     }
   }, []);
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     init();
 
     return () => {
@@ -105,14 +114,7 @@
   }, []);
 
   useEffect(() => {
-    init();
-
-    return () => {
-      source.cancel();
-    };
-  }, []);
-
-  useEffect(() => {
+    if (!isSecondCallAllowed.current) return;  
     getUserList(parameterData.parameters.current);
   }, [size, page]);
 
diff -urN ..\hss-frontend\src\/pages/hss/sslvpnManage/zoneManage/index.jsx .\src\/pages/hss/sslvpnManage/zoneManage/index.jsx
--- ..\hss-frontend\src\/pages/hss/sslvpnManage/zoneManage/index.jsx	2025-02-19 14:50:03.897808500 +0900
+++ .\src\/pages/hss/sslvpnManage/zoneManage/index.jsx	2025-03-11 16:30:56.275176200 +0900
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useState } from 'react';
+import { useCallback, useEffect, useState,useRef } from 'react';
 import { unstable_batchedUpdates } from 'react-dom';
 import { useDispatch, useSelector } from 'react-redux';
 import GridItem from '@components/modules/grid/GridItem';
@@ -103,8 +103,16 @@
   const getLoadingStatus = async (param) => {
     setIsLoading(param);
   };
-
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;   
     init();
 
     return () => {
@@ -113,6 +121,7 @@
   }, []);
 
   useEffect(() => {
+    if (!isSecondCallAllowed.current) return;  
     getZoneList(parameterData.parameters.current);
   }, [size, page]);
 
diff -urN ..\hss-frontend\src\/pages/hss/systemManage/dashboardManage/index.jsx .\src\/pages/hss/systemManage/dashboardManage/index.jsx
--- ..\hss-frontend\src\/pages/hss/systemManage/dashboardManage/index.jsx	2025-02-19 14:50:03.898808400 +0900
+++ .\src\/pages/hss/systemManage/dashboardManage/index.jsx	2025-03-10 14:21:05.358356800 +0900
@@ -1,4 +1,4 @@
-import { useEffect, useState, useCallback } from 'react';
+import { useEffect, useState, useCallback, useRef } from 'react';
 import Layout from '@components/layouts';
 import GridItem from '@components/modules/grid/GridItem';
 import MainCard from '@components/mantis/MainCard';
@@ -83,8 +83,8 @@
 
 function DashboardManage() {
   const router = useRouter();
-
   const [apiCall] = useApi();
+
   const { instance, source } = AuthInstance();
   versionApi.axios = instance;
   interfaceApi.axios = instance;
@@ -101,52 +101,77 @@
   const [interfaceList, setInterfaceList] = useState([]);
   const [isLoading, setIsLoading] = useState(true);
 
-  const getZoneList = useCallback(async () => {
-    const result = await apiCall(dashboardApi.getServiceStatus, {
-      hasToken: false,
-    });
-
-    if (result.status === 200) {
-      const data = result.data;
-      const list = data.map((item) => ({
-        name: item.name,
-        status: item.enabled === '1' ? '활성화' : '비활성화',
-      }));
-      return list;
+
+  const getZoneList = useCallback(async (signal) => {
+    try {
+      const result = await apiCall(dashboardApi.getServiceStatus, {
+        hasToken: false, signal
+      });
+
+      if (result.status === 200) {
+        const data = result.data;
+        const list = data.map((item) => ({
+          name: item.name,
+          status: item.enabled === '1' ? '활성화' : '비활성화',
+        }));
+        return list;
+
+      }
+    } catch (error) {
+      console.error('서비스 상태를 가져오는 중 오류 발생:', error);
     }
     return [];
   }, []);
 
-  const getVersionInfo = useCallback(async () => {
-    const data = await apiCall(versionApi.getVersionDetail);
-    if (data) {
-      return data;
+  const getVersionInfo = useCallback(async (signal) => {
+    try {
+      const data = await apiCall(versionApi.getVersionDetail, { signal });
+      if (data) {
+        return data;
+      }
+    } catch (error) {
+      console.error('버전 정보를 가져오는 중 오류 발생:', error);
     }
     return [];
   }, []);
 
-  const getInterfaceList = useCallback(async () => {
-    const data = await apiCall(interfaceApi.getInterfaceList, { contentOnly: true });
-    if (data) {
-      const list = data.map((item) => ({
-        name: item.name,
-        type: item.type,
-        ip: item.ip,
-      }));
-      return list;
+  const getInterfaceList = useCallback(async (signal) => {
+    try {
+      const data = await apiCall(interfaceApi.getInterfaceList, { contentOnly: true, signal });
+      if (Array.isArray(data)) {
+        const list = data.map((item) => ({
+          name: item.name,
+          type: item.type,
+          ip: item.ip,
+        }));
+        return list;
+      }
+    } catch (error) {
+      console.error('인터페이스 목록을 가져오는 중 오류 발생:', error);
     }
     return [];
   }, []);
 
+  const isStrictMode = process.env.NODE_ENV === 'development';
+  const isFirstRender = useRef(true);
+  const isSecondCallAllowed = useRef(isStrictMode);
   useEffect(() => {
+    if (isFirstRender.current) {
+      isFirstRender.current = false;
+      return;
+    }
+    // Strict Mode가 아닐 때 두 번째 실행 방지
+    if (!isSecondCallAllowed.current) return;
+
+    const controller = new AbortController();
+    const signal = controller.signal;
     const fetchData = async () => {
       try {
         const [zoneList, versionInfo, interfaceList] = await Promise.all([
-          getZoneList(),
-          getVersionInfo(),
-          getInterfaceList(),
+          getZoneList(signal),
+          getVersionInfo(signal),
+          getInterfaceList(signal),
         ]);
-
         unstable_batchedUpdates(() => {
           setZoneList(zoneList);
           setVersionInfo(versionInfo);
@@ -155,17 +180,21 @@
           setIsLoading(false);
         });
       } catch (error) {
-        console.error('Error fetching data:', error);
+        if (error.message !== 'canceled') {
+          console.error("데이터 로딩 중 오류 발생:", error);
+        }
       }
     };
 
     fetchData();
 
     return () => {
-      source.cancel();
+      controller.abort(); // 요청 취소
     };
   }, []);
 
+
+
   return (
     <GridItem
       container
@@ -223,53 +252,53 @@
                       // 스크롤 끝 //
                     }}
                   >
-                    { isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
-                    <MiniTable
-                      ellipsis
-                      columns={[
-                        {
-                          label: '서비스명',
-                          id: 'name',
-                          options: columnStyle,
-                        },
-                        {
-                          label: '상태',
-                          id: 'status',
-                          options: columnStyle,
-                        },
-                      ]}
-                      data={zoneList}
-                      sx={{
-                        container: { border: 'unset !important' },
-                        head: {
-                          '& th': {
-                            color: '#eee',
-                            backgroundColor: '#272C38',
-                            minWidth: '70px',
-                            border: 'unset',
+                    {isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
+                      <MiniTable
+                        ellipsis
+                        columns={[
+                          {
+                            label: '서비스명',
+                            id: 'name',
+                            options: columnStyle,
                           },
-                        },
-                        body: {
-                          '& p': {
-                            color: '#dddddd',
-                            backgroundColor: 'unset',
-                            lineHeight: '20px;',
+                          {
+                            label: '상태',
+                            id: 'status',
+                            options: columnStyle,
                           },
-                          '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
-                        },
-                        bodyRow: {
-                          ':hover': { backgroundColor: '#f5f5f521 !important' },
-                          '& div': { height: '20px' },
-                          ':last-of-type > td': { borderBottom: '1px solid #f5f5f547 !important' },
-                        },
-                        bodyCell: {
-                          height: '20px',
-                          maxHeight: '20px',
-                          borderRight: 'unset !important',
-                          borderColor: '#f5f5f547 !important',
-                        },
-                      }}
-                    />
+                        ]}
+                        data={zoneList}
+                        sx={{
+                          container: { border: 'unset !important' },
+                          head: {
+                            '& th': {
+                              color: '#eee',
+                              backgroundColor: '#272C38',
+                              minWidth: '70px',
+                              border: 'unset',
+                            },
+                          },
+                          body: {
+                            '& p': {
+                              color: '#dddddd',
+                              backgroundColor: 'unset',
+                              lineHeight: '20px;',
+                            },
+                            '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
+                          },
+                          bodyRow: {
+                            ':hover': { backgroundColor: '#f5f5f521 !important' },
+                            '& div': { height: '20px' },
+                            ':last-of-type > td': { borderBottom: '1px solid #f5f5f547 !important' },
+                          },
+                          bodyCell: {
+                            height: '20px',
+                            maxHeight: '20px',
+                            borderRight: 'unset !important',
+                            borderColor: '#f5f5f547 !important',
+                          },
+                        }}
+                      />
                     }
                   </GridItem>
                 </MainCard>
@@ -306,36 +335,36 @@
                     alignItems="center"
                     sx={{ height: '160px' }}
                   >
-                  { isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
-                    <GridItem item xs={12}>
-                      <GridItem container item spacing={2} alignItems="center">
-                        <GridItem item xs={4}>
-                          <Typography variant="body1" fontWeight="bold">
-                            제품명
-                          </Typography>
-                        </GridItem>
-                        <GridItem item xs={8}>
-                          <Typography variant="body1">{versionInfo.productName}</Typography>
+                    {isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
+                      <GridItem item xs={12}>
+                        <GridItem container item spacing={2} alignItems="center">
+                          <GridItem item xs={4}>
+                            <Typography variant="body1" fontWeight="bold">
+                              제품명
+                            </Typography>
+                          </GridItem>
+                          <GridItem item xs={8}>
+                            <Typography variant="body1">{versionInfo.productName}</Typography>
+                          </GridItem>
+                          <GridItem item xs={4}>
+                            <Typography variant="body1" fontWeight="bold">
+                              세부버전
+                            </Typography>
+                          </GridItem>
+                          <GridItem item xs={8}>
+                            <Typography variant="body1">{versionInfo.detailVersion}</Typography>
+                          </GridItem>
+                          <Grid item xs={4}>
+                            <Typography variant="body1" fontWeight="bold">
+                              기타정보
+                            </Typography>
+                          </Grid>
+                          <Grid item xs={8}>
+                            <Typography variant="body1">{versionInfo.etcInfo}</Typography>
+                          </Grid>
                         </GridItem>
-                        <GridItem item xs={4}>
-                          <Typography variant="body1" fontWeight="bold">
-                            세부버전
-                          </Typography>
-                        </GridItem>
-                        <GridItem item xs={8}>
-                          <Typography variant="body1">{versionInfo.detailVersion}</Typography>
-                        </GridItem>
-                        <Grid item xs={4}>
-                          <Typography variant="body1" fontWeight="bold">
-                            기타정보
-                          </Typography>
-                        </Grid>
-                        <Grid item xs={8}>
-                          <Typography variant="body1">{versionInfo.etcInfo}</Typography>
-                        </Grid>
                       </GridItem>
-                    </GridItem>
-                  }
+                    }
                   </GridItem>
                 </MainCard>
               </GridItem>
@@ -370,39 +399,39 @@
                 >
                   <></>
                 </GridItem>
-                { isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> : 
-                <MiniTable
-                  ellipsis
-                  columns={column1}
-                  data={miniData1}
-                  sx={{
-                    container: { border: 'unset !important' },
-                    head: {
-                      '& th': {
-                        color: '#eee',
-                        backgroundColor: '#272C38',
-                        minWidth: '70px',
-                        border: 'unset',
-                      },
-                    },
-                    body: {
-                      '& p': { color: '#dddddd', backgroundColor: 'unset', lineHeight: '20px;' },
-                      '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
-                    },
-                    bodyRow: {
-                      ':hover': { backgroundColor: '#f5f5f521 !important' },
-                      '& div': { height: '20px' },
-                      ':last-of-type > td': { borderBottom: '1px solid #f5f5f547 !important' },
-                    },
-                    bodyCell: {
-                      height: '20px',
-                      maxHeight: '20px',
-                      borderRight: 'unset !important',
-                      borderColor: '#f5f5f547 !important',
-                    },
-                  }}
-                />
-              }
+                {isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
+                  <MiniTable
+                    ellipsis
+                    columns={column1}
+                    data={miniData1}
+                    sx={{
+                      container: { border: 'unset !important' },
+                      head: {
+                        '& th': {
+                          color: '#eee',
+                          backgroundColor: '#272C38',
+                          minWidth: '70px',
+                          border: 'unset',
+                        },
+                      },
+                      body: {
+                        '& p': { color: '#dddddd', backgroundColor: 'unset', lineHeight: '20px;' },
+                        '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
+                      },
+                      bodyRow: {
+                        ':hover': { backgroundColor: '#f5f5f521 !important' },
+                        '& div': { height: '20px' },
+                        ':last-of-type > td': { borderBottom: '1px solid #f5f5f547 !important' },
+                      },
+                      bodyCell: {
+                        height: '20px',
+                        maxHeight: '20px',
+                        borderRight: 'unset !important',
+                        borderColor: '#f5f5f547 !important',
+                      },
+                    }}
+                  />
+                }
               </MainCard>
             </GridItem>
           </GridItem>
@@ -449,64 +478,64 @@
                   // 스크롤 끝 //
                 }}
               >
-                { isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
-                <MiniTable
-                  sx={{
-                    container: { border: 'unset !important' },
-                    head: {
-                      '& th': {
-                        color: '#eee',
-                        backgroundColor: '#272C38',
-                        minWidth: '40px',
-                        border: 'unset',
-                        lineHeight: '20px;',
-                        height: '20px',
+                {isLoading ? <LoadingButton loadingPosition="center" color='secondary' loading /> :
+                  <MiniTable
+                    sx={{
+                      container: { border: 'unset !important' },
+                      head: {
+                        '& th': {
+                          color: '#eee',
+                          backgroundColor: '#272C38',
+                          minWidth: '40px',
+                          border: 'unset',
+                          lineHeight: '20px;',
+                          height: '20px',
+                        },
+                        '& th:after': { width: 'unset !important' },
                       },
-                      '& th:after': { width: 'unset !important' },
-                    },
-                    body: {
-                      '& p': {
-                        color: '#dddddd',
-                        backgroundColor: 'unset',
-                        lineHeight: '20px;',
+                      body: {
+                        '& p': {
+                          color: '#dddddd',
+                          backgroundColor: 'unset',
+                          lineHeight: '20px;',
+                          height: '20px',
+                        },
+                        '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
+                      },
+                      bodyRow: {
+                        ':hover': { backgroundColor: '#f5f5f521 !important' },
+                        '& div': { height: '20px' },
+                        ':last-of-type > td': {
+                          borderBottom: '1px solid #f5f5f547 !important',
+                        },
+                      },
+                      bodyCell: {
                         height: '20px',
+                        maxHeight: '20px',
+                        borderRight: 'unset !important',
+                        borderColor: '#f5f5f547 !important',
                       },
-                      '& tr:last-of-type > td': { borderBottom: '1px solid !important' },
-                    },
-                    bodyRow: {
-                      ':hover': { backgroundColor: '#f5f5f521 !important' },
-                      '& div': { height: '20px' },
-                      ':last-of-type > td': {
-                        borderBottom: '1px solid #f5f5f547 !important',
-                      },
-                    },
-                    bodyCell: {
-                      height: '20px',
-                      maxHeight: '20px',
-                      borderRight: 'unset !important',
-                      borderColor: '#f5f5f547 !important',
-                    },
-                  }}
-                  ellipsis
-                  columns={[
-                    {
-                      label: '인터페이스명',
-                      id: 'name',
-                      options: columnStyle,
-                    },
-                    {
-                      label: '타입',
-                      id: 'type',
-                      options: columnStyle,
-                    },
-                    {
-                      label: 'IP 주소',
-                      id: 'ip',
-                      options: columnStyle,
-                    },
-                  ]}
-                  data={interfaceList}
-                />
+                    }}
+                    ellipsis
+                    columns={[
+                      {
+                        label: '인터페이스명',
+                        id: 'name',
+                        options: columnStyle,
+                      },
+                      {
+                        label: '타입',
+                        id: 'type',
+                        options: columnStyle,
+                      },
+                      {
+                        label: 'IP 주소',
+                        id: 'ip',
+                        options: columnStyle,
+                      },
+                    ]}
+                    data={interfaceList}
+                  />
                 }
               </Stack>
               <Box sx={{ background: '#51555E', padding: '2px' }}>
diff -urN ..\hss-frontend\src\/pages/system/menu/menuList.jsx .\src\/pages/system/menu/menuList.jsx
--- ..\hss-frontend\src\/pages/system/menu/menuList.jsx	2024-10-18 16:27:14.235052000 +0900
+++ .\src\/pages/system/menu/menuList.jsx	2025-03-10 17:39:09.884288000 +0900
@@ -26,14 +26,9 @@
 import useApi from '@modules/hooks/useApi';
 import { setMenuItem } from '@modules/redux/reducers/menu';
 import { openSnackbar } from '@modules/redux/reducers/snackbar';
-import { DragDropContext, Draggable, Droppable } from '@hello-pangea/dnd';
-// Drag Style (함수)
-const getItemStyle = (isDragging, draggableStyle) => ({
-  background: isDragging && 'rgba(0, 0, 0, 0.04)',
+//import { DragDropContext, Draggable, Droppable } from '@hello-pangea/dnd';
 
-  ...draggableStyle,
-});
-// Scrollbar Style (라이브러리)
+// Scrollbar Style
 const Scrollbar = styled(OverlayScrollbarsComponent)({
   height: '100%',
   '& .os-scrollbar-vertical .os-scrollbar-track .os-scrollbar-handle': {
@@ -43,17 +38,14 @@
 });
 
 function MenuList() {
-  // theme 객체(테마)
   const theme = useTheme();
-  // Axios 인트턴스(Http통신)
   const { instance, source } = AuthInstance();
   menuApi.axios = instance;
   preferencesApi.axios = instance;
-  // 액션실행 Hook
+
   const dispatch = useDispatch();
-  // API, openModal 호출 함수
   const [apiCall, openModal, apiAllCall] = useApi();
-  // Form 객체(초기값 할당)
+
   const methods = useForm({
     defaultValues: {
       useYn: '',
@@ -67,439 +59,82 @@
       depth2: '',
     },
   });
+
   const {
     selectedTopMenu,
     menuItem: { topItems },
   } = useSelector((state) => state.menu);
 
   const isTopMenu = useRef(false);
-  // 메뉴 목록 상태값
+  const hasFetched = useRef(false); // 첫 번째 렌더링 시 중복 요청 방지
+
   const [menuList, setMenuList] = useState([
     { key: 'root', menuId: 'root', id: 'root', title: 'HSCK SECURE GATE', children: [] },
   ]);
-  // 요청 URL 공통 정규표현식 표시여부 상태값
   const [commonRegexFlag, setCommonRegexFlag] = useState(false);
-  // 하위메뉴 선택여부 상태값
   const [contentClick, setContentClick] = useState(false);
-  // 메뉴 체크 목록 상태값
   const [checkList, setCheckList] = useState([]);
-  // 사용여부 상태값
   const [useYnVal, setUseYnVal] = useState('');
-  // 관리자전용여부 상태값
   const [adminUseYnVal, setAdminUseYnVal] = useState('');
-  // PopOver 엘리먼트(출력위치) 상태값
   const [popTarget, setPopTarget] = useState(null);
-  // 메뉴 추가 모달팝업 출력 상태값
   const [addAlertOpen, setAddAlertOpen] = useState(false);
-  // 메뉴 설정 모달팝업 출력 상태값
   const [settingAlertOpen, setSettingAlertOpen] = useState(false);
-  // 메뉴 설정 상태값
   const [configVal, setConfigVal] = useState('');
-  // 상위 메뉴 목록 상태값
-  const [upperMenuList, setUpperMenuList] = useState({
-    depth0: [],
-    depth1: [],
-    depth2: [],
-    depth3: [],
-  });
-  // select 박스 비활성화 상태값
-  const [isSelect, setIsSelect] = useState({
-    depth0: false,
-    depth1: false,
-    depth2: false,
-    depth3: false,
-  });
-  // Treelist 선택 상태값
   const [selected, setSelected] = useState(null);
-  // Treelist 확장 상태값
   const [expanded, setExpanded] = useState(['root', selectedTopMenu ? selectedTopMenu : null]);
 
-  const isDisabled =
-    (typeof selected === 'string' ? (selected.split(',')[1] === 'Y' ? true : false) : false) ||
-    !selected;
-
-  // Side effect Hook
   useEffect(() => {
-    // 메뉴목록 출력
-    getMenuList();
-    // Clean-up
-    return () => {
-      source.cancel();
-    };
-  }, []);
-  // 메뉴목록 출력
-  const getMenuList = useCallback(async (params) => {
-    // 메뉴정보,상위메뉴목록,메뉴설정정보 요청
-    const menuRequest = apiCall(menuApi.getMenuList, {
-      isMenu: false,
-      ...(params && { ...params }),
-    });
-    const upperMenuRequest = apiCall(menuApi.getUpperMenuList);
-    const preferenceRequest = apiCall(preferencesApi.getPreferences, {
-      configType: 'MENU',
-      hasToken: false,
-    });
-    const [menuResult, upperMenuResult, preferenceResult] = await apiAllCall([
-      menuRequest,
-      upperMenuRequest,
-      preferenceRequest,
-    ]);
-    // 일괄 변경처리
-    unstable_batchedUpdates(() => {
-      // 메뉴목록 상태값 변경
-      if (menuResult && menuResult.status === 200) {
-        setMenuList((initData) => {
-          const tempArray = [...initData];
-          tempArray[0].children = menuResult.data.menuList;
-          return tempArray;
-        });
-      }
-      // 상위메뉴목록 상태값 변경
-      if (upperMenuResult && upperMenuResult.status === 200) {
-        const {
-          depth0: resultDepth0,
-          depth1: resultDepth1,
-          depth2: resultDepth2,
-          depth3: resultDepth3,
-        } = upperMenuResult.data.upperMenuList;
-
-        const depth0 = resultDepth0.map((data) => {
-          const { menuName, menuId } = data;
-          return { value: menuId, label: menuName };
-        });
-        const depth1 = resultDepth1.map((data) => {
-          const { menuName, menuId } = data;
-          return { value: menuId, label: menuName };
-        });
-        const depth2 = resultDepth2?.map((data) => {
-          const { menuName, menuId } = data;
-          return { value: menuId, label: menuName };
-        });
-        const depth3 = resultDepth3?.map((data) => {
-          const { menuName, menuId } = data;
-          return { value: menuId, label: menuName };
-        });
-        setUpperMenuList({ depth0, depth1, depth2, depth3 });
-        // 메뉴설정정보 상태값 변경
-        if (preferenceResult && preferenceResult.status === 200) {
-          const { configValue } = preferenceResult.data.find(
-            (config) => config.configName === 'menuDepth',
-          );
-          setConfigVal(configValue);
-          const menuLevel = methods.getValues('menuLevel');
-
-          if (menuLevel !== undefined && configValue < menuLevel) {
-            // Treelist,상세정보 초기화
-            handleReset();
+    if (hasFetched.current) return;
+    hasFetched.current = true;
+
+    const fetchData = async () => {
+      try {
+        const menuRequest = apiCall(menuApi.getMenuList, { isMenu: false });
+        const upperMenuRequest = apiCall(menuApi.getUpperMenuList);
+        const preferenceRequest = apiCall(preferencesApi.getPreferences, {
+          configType: 'MENU',
+          hasToken: false,
+        });
+
+        const [menuResult, upperMenuResult, preferenceResult] = await apiAllCall([
+          menuRequest,
+          upperMenuRequest,
+          preferenceRequest,
+        ]);
+
+        unstable_batchedUpdates(() => {
+          if (menuResult?.status === 200) {
+            setMenuList((initData) => {
+              const tempArray = [...initData];
+              tempArray[0].children = menuResult.data.menuList;
+              return tempArray;
+            });
           }
-        }
-      }
-    });
-  }, []);
-  // 상세정보 저장
-  const editMenuList = async (data) => {
-    if (data.menuId === undefined) {
-      openModal({
-        message: `저장할 메뉴를 우선 선택해 주십시오.`,
-      });
-      setPopTarget(null);
-      return;
-    }
 
-    if (data['useSubCheck'].includes('Y')) data['useSubCheck'] = true;
-    else data['useSubCheck'] = false;
-    if (data['adminSubCheck'].includes('Y')) data['adminSubCheck'] = true;
-    else data['adminSubCheck'] = false;
-    const { depth0, depth1, depth2, depth3, menuPid, menuId } = data;
-    // 자식메뉴가 있는 상위메뉴를 수정할경우
-    let updateMenuLevel = '';
-    let updateMenuPid = '';
-
-    if (depth0 === '' && depth1 === '' && depth2 === '' && depth3 === '') {
-      // 상위메뉴 선택 안 했을 경우
-      updateMenuLevel = 0;
-      if (data.menuPid != 0) {
-        // 자식메뉴가 상위메뉴가 될 경우
-        updateMenuPid = 0;
-      } else {
-        updateMenuPid = '';
-      }
-    } else {
-      if (depth0 !== '') {
-        updateMenuLevel = 1;
-        updateMenuPid = depth0;
-      } else if (depth1 !== '') {
-        // 1 Depth 상위 메뉴 선택 한 경우
-        updateMenuLevel = 2;
-        updateMenuPid = depth1;
-      } else if (depth2 !== '') {
-        // 2 Depth 상위 메뉴 선택 한 경우
-        updateMenuLevel = 3;
-        updateMenuPid = depth2;
-      } else {
-        // 3 Detph 상위 메뉴 선택 한 경우
-        updateMenuLevel = 4;
-        updateMenuPid = depth3;
+          if (preferenceResult?.status === 200) {
+            const { configValue } = preferenceResult.data.find(
+              (config) => config.configName === 'menuDepth',
+            );
+            setConfigVal(configValue);
+          }
+        });
+      } catch (error) {
+        console.error('메뉴 목록을 가져오는 중 오류 발생:', error);
       }
-    }
-    // 상위 메뉴가 변경된 경우
-    if (updateMenuPid !== menuPid) {
-      data.updateMenuPid = updateMenuPid;
-      data.updateMenuLevel = updateMenuLevel;
-    }
-
-    if (updateMenuPid === menuId) {
-      openModal({
-        message: '상위메뉴를 다시 선택해 주세요.',
-      });
-      setPopTarget(null);
-      return;
-    }
-
-    const result = await apiCall(menuApi.editMenuList, data, true);
+    };
 
-    if (result.status === 200) {
-      const { count, menuPidList } = result.data;
-      data.menuPidList = menuPidList;
-
-      if (data.updateMenuPid !== undefined) {
-        data.menuPid = data.updateMenuPid;
-        data.menuLevel = data.updateMenuLevel;
-        delete data.updateMenuPid;
-        delete data.updateMenuLevel;
-      }
+    fetchData();
 
-      if (count > 0) {
-        const menuResult = await apiCall(menuApi.getMenuList, {
-          useYn: 'Y',
-          isMenu: true,
-          common: true,
-          isEdit: true,
-        });
-        if (menuResult.status === 200) {
-          unstable_batchedUpdates(() => {
-            dispatch(
-              setMenuItem({
-                topMenuItem: menuResult.data.menuList.map((menu) => ({
-                  label: menu.label,
-                  menuId: menu.menuId,
-                  children: menu.children,
-                })),
-                menuItem: menuResult.data.menuList.find(
-                  (topMenu) => topMenu.menuId === selectedTopMenu,
-                ).children,
-              }),
-            );
-            openModal({
-              message: '수정되었습니다.',
-              onConfirm: () => {
-                // 일괄 변경처리
-                setPopTarget(null);
-                getMenuList({ isEdit: true });
-                // Treelist,상세정보 초기화
-                handleReset(data);
-              },
-            });
-          });
-        }
-      }
-    } else {
-      const { message } = result.data;
-      openModal({
-        message,
-        onConfirm: () => {
-          methods.setValue('useYn', useYnVal);
-          methods.setValue('adminYn', adminUseYnVal);
-          setPopTarget(null);
-        },
-      });
-    }
-  };
-  // 메뉴 클릭 이벤트(상세정보 출력)
-  const clickHandler = useCallback((menuList) => {
-    methods.reset();
-    if (menuList.type == 'item') {
-      // 마지막 depth인경우 하위메뉴 체크박스 안보이게
-      setContentClick(true);
-    } else {
-      setContentClick(false);
-    }
-    for (const key in menuList) {
-      if (key === 'iconName' && !menuList[`${key}`]) {
-        methods.setValue(key, '');
-        continue;
-      }
-      methods.setValue(key, menuList[`${key}`]);
-    }
-    // 상위 메뉴 값 설정
-    const { menuLevel, menuPid, children } = menuList;
-    let depth0 = '',
-      depth1 = '',
-      depth2 = '',
-      depth3 = '';
-    switch (menuLevel) {
-      case 1: // 레벨이 1일 때 상단허용
-        depth0 = menuPid;
-        setIsSelect({ depth0: false, depth1: true, depth2: true, depth3: true });
-        break;
-      case 2: // 레벨이 2일 때 1허용
-        depth1 = menuPid;
-        setIsSelect({ depth0: true, depth1: false, depth2: true, depth3: true });
-        break;
-      case 3: // 레벨이 3일 때 2허용
-        depth2 = menuPid;
-        setIsSelect({ depth0: true, depth1: true, depth2: false, depth3: true });
-        break;
-      case 4: // 레벨이 4일 때 3허용
-        depth3 = menuPid;
-        setIsSelect({ depth0: true, depth1: true, depth2: true, depth3: false });
-        break;
-      default: // default 모두 허용
-        setIsSelect({ depth0: false, depth1: false, depth2: false, depth3: false });
-        break;
-    }
-    methods.setValue('useSubCheck', []);
-    methods.setValue('adminSubCheck', []);
-    methods.setValue('depth0', depth0);
-    methods.setValue('depth1', depth1);
-    methods.setValue('depth2', depth2);
-    methods.setValue('depth3', depth3);
-    setUseYnVal(methods.getValues('useYn'));
-
-    setAdminUseYnVal(methods.getValues('adminYn'));
-    if (children && children?.length !== 0) {
-      setIsSelect({ depth0: true, depth1: true, depth2: true, depth3: true });
-    }
+    return () => {
+      source.cancel();
+    };
   }, []);
-  // 메뉴 순서정보 변경(재귀 함수)
-  const findParentMenu = (menuList, target, source, destination) =>
-    menuList.map((menu) => {
-      // Target (드래그된 메뉴들의 부모 메뉴)을 찾은 경우,
-      if (String(menu.menuId) === target) {
-        // 드래그된 영역의 배열.
-        const menuArrayList = Array.from(menu.children);
-
-        const [removed] = menuArrayList.splice(source, 1);
-
-        menuArrayList.splice(destination, 0, removed);
-
-        // 메뉴 순서 변경 비동기 처리.
-        apiCall(menuApi.updateMenuDisplayOrder, menuArrayList);
-
-        menu.children = menuArrayList;
-      } else if (menu.children.length !== 0)
-        findParentMenu(menu.children, target, source, destination);
-
-      return menu;
-    });
-  // Drag 종료
-  const onDragEnd = useCallback(
-    (result) => {
-      const { source, destination, type } = result;
-
-      // 리스트 밖으로 drop 됐을 경우
-      if (!destination) return;
-
-      // 출발지와 도착지가 같을 경우
-      if (destination.droppableId === source.droppableId && destination.index === source.index)
-        return;
-
-      // 드래그되는 영역의 상위 메뉴 TYPE.
-      const parentMenu = type.split('_')[0];
-
-      const changeMenuList = findParentMenu(menuList, parentMenu, source.index, destination.index);
-      setMenuList(changeMenuList);
-      // 상단 메뉴 상태 업데이트.
-      dispatch(
-        setMenuItem({
-          topMenuItem: changeMenuList[0].children.map((menu) => ({
-            label: menu.title,
-            menuId: menu.menuId,
-            children: topItems.find((topMenu) => topMenu.menuId === menu.menuId)?.children,
-          })),
-        }),
-      );
-      dispatch(
-        openSnackbar({
-          message: '메뉴의 순서가 변경되었습니다.',
-          open: true,
-          variant: 'default',
-          transition: 'SlideUp',
-        }),
-      );
-    },
-    [menuList],
-  );
-  // Check 박스 변경 이벤트
-  const handleChangeCheck = ({ id, children }) => {
-    // 하위메뉴 id목록 생성(재귀 함수)
-    const idList = getChildMenuId(children) || [];
-    idList.push(id);
-
-    let idArr = idList.filter((ids) => {
-      if (idList.length === 1) {
-        if (!checkList.includes(ids)) return ids;
-      } else {
-        if (!checkList.includes(id)) return idList.includes(ids);
-      }
-    });
-    const checkArr = checkList.filter((ids) => {
-      if (idList.length === 1) {
-        if (!idList.includes(ids)) return ids;
-      } else {
-        if (!idList.includes(ids)) return checkList.includes(ids);
-      }
-    });
 
-    setCheckList([...idArr, ...checkArr]);
-  };
-  // 라디오 버튼, select 박스 변경 이벤트
-  const handleChange = ({ value, type, name }) => {
-    if (type === 'radio') {
-      const data = [...menuList];
-      setMenuList(data);
-
-      return value;
-    } else if (type === 'select') {
-      const fieldNameArr = ['depth0', 'depth1', 'depth2', 'depth3'];
-      const flag = value === '' ? false : true;
-      let temp = isSelect;
-
-      fieldNameArr.map((fieldName) => {
-        if (fieldName !== name) {
-          temp[`${fieldName}`] = flag;
-        }
-      });
+  const getMenuList = useCallback(async () => {
+    try {
+      const menuResult = await apiCall(menuApi.getMenuList, { useYn: 'Y', isMenu: true });
 
-      setIsSelect({ ...temp });
-      return value;
-    }
-  };
-  // 삭제 버튼 클릭 이벤트
-  const handleDeleteButtonClick = () => {
-    const menuId = methods.getValues('menuId');
-    if (!menuId || checkList.length === 0) {
-      openModal({
-        message: `삭제할 메뉴를 우선 선택해 주십시오.`,
-      });
-    } else {
-      openModal({
-        message: `메뉴를 삭제하시겠습니까?`,
-        onConfirm: deleteMenu,
-      });
-    }
-  };
-  // 선택한 정보 삭제
-  const deleteMenu = async () => {
-    const result = await apiCall(menuApi.deleteMenu, checkList);
-    if (result.status === 200) {
-      const menuResult = await apiCall(menuApi.getMenuList, {
-        useYn: 'Y',
-        isMenu: true,
-        common: true,
-        isEdit: true,
-      });
-      if (menuResult.status === 200) {
+      if (menuResult?.status === 200) {
         dispatch(
           setMenuItem({
             topMenuItem: menuResult.data.menuList.map((menu) => ({
@@ -507,434 +142,49 @@
               menuId: menu.menuId,
               children: menu.children,
             })),
-            menuItem: menuResult.data.menuList.find((topMenu) => topMenu.menuId === selectedTopMenu)
-              .children,
           }),
         );
-        openModal({
-          message: `삭제되었습니다.`,
-          onConfirm: () => {
-            methods.reset();
-            getMenuList({ isEdit: true });
-            setCheckList([]);
-          },
-        });
       }
+    } catch (error) {
+      console.error('메뉴 데이터를 가져오는 중 오류 발생:', error);
     }
-  };
-  // 하위메뉴 id목록 생성(재귀 함수)
-  const getChildMenuId = (childList) => {
-    let idList = [];
-
-    childList &&
-      childList.map((item) => {
-        const { menuId, children } = item;
-        idList.push(menuId);
-
-        if (children) {
-          idList = [...idList, ...getChildMenuId(children)];
-        }
-      });
-
-    return idList;
-  };
-  // Tree 선택 이벤트
-  const handleSelect = (event, nodeIds) => {
-    if (
-      typeof event.target.className === 'string' &&
-      event.target.className.indexOf('MuiTreeItem') !== -1
-    ) {
-      if (nodeIds !== 'root') {
-        setSelected(nodeIds);
-        if (topItems.find((item) => item.menuId === nodeIds)) isTopMenu.current = true;
-        else isTopMenu.current = false;
-      } else {
-        setSelected(null);
-        isTopMenu.current = false;
-      }
-    }
-  };
-  // Tree 확장 이벤트
-  const handleToggle = (event, nodeIds) => {
-    if (event.target?.id === 'expand_icon' || event.target?.id === 'collapse_icon')
-      setExpanded(arrayValueToString(nodeIds));
-  };
-  // Treelist,상세정보 초기화
-  const handleReset = (data) => {
-    if (data) {
-      const { menuId, menuPidList } = data;
-
-      setSelected(menuId.toString());
-      setExpanded(['root', ...arrayValueToString(menuPidList)]);
-      methods.reset();
-      // setSelected(false);
-    } else {
-      methods.reset();
-      setSelected([]);
-      setExpanded([]);
-    }
-  };
-  // array타입의 값을 string으로 변환
-  const arrayValueToString = (array) => {
-    return array.map((value) => {
-      if (value && value !== null) {
-        return value.toString();
-      } else {
-        return null;
-      }
-    });
-  };
-  // 메뉴 그리는 함수
-  const childMenuDraw = (menuList = [], level) => {
-    return (
-      menuList.length !== 0 && (
-        <Droppable droppableId={level} type={level}>
-          {(provided) => (
-            <div ref={provided.innerRef} {...provided.droppableProps}>
-              {menuList.map((menu, index) => {
-                return (
-                  <Draggable key={menu.id} draggableId={String(menu.id)} index={index}>
-                    {(provided, snapshot) => {
-                      let nodeId = menu.id.toString();
-                      if ('adminYn' in menu) nodeId += `,${menu.adminYn.toString()}`;
-                      return (
-                        <div ref={provided.innerRef}>
-                          {/* 대메뉴넣고 해당되는 하위메뉴 넣기 */}
-                          <TreeListItem
-                            {...provided.draggableProps}
-                            {...provided.dragHandleProps}
-                            sx={getItemStyle(snapshot.isDragging, provided.draggableProps.style)}
-                            nodeId={nodeId}
-                            label={
-                              <>
-                                {level !== 'root_1' && (
-                                  <Checkbox
-                                    sx={{
-                                      transform: 'scale(1)',
-                                      p: 0,
-                                      mr: 1.5,
-                                    }}
-                                    disabled={menu.adminYn === 'Y' ? true : false}
-                                    value={menu.id}
-                                    checked={checkList.includes(menu.id)}
-                                    onChange={() => handleChangeCheck(menu)}
-                                  />
-                                )}
-                                {menu.title}
-                              </>
-                            }
-                            onClick={() => clickHandler(menu)}
-                          >
-                            {childMenuDraw(
-                              menu.children,
-                              String(menu.menuId + '_' + (Number(level.split('_')[1]) + 1)),
-                            )}
-                          </TreeListItem>
-                        </div>
-                      );
-                    }}
-                  </Draggable>
-                );
-              })}
-              {provided.placeholder}
-            </div>
-          )}
-        </Droppable>
-      )
-    );
-  };
-  // JSX
+  }, []);
+
   return (
-    <>
-      <GridItem container item divideColumn={12} spacing={2}>
-        <MainCard
-          title="메뉴 설정"
-          colSpan={3}
-          sx={{
-            height: 'calc(100vh - 200px)',
-          }}
-          contentSX={{ height: 'calc(100vh - 240px)', pb: '15px', overflow: 'hidden' }}
-          secondary={
-            <Button
-              size="small"
-              variant="outlined"
-              color="secondary"
-              onClick={() => setSettingAlertOpen(true)}
-            >
-              설정
-            </Button>
-          }
-        >
-          <Scrollbar
-            options={{
-              className: theme.palette.mode === 'dark' ? 'os-theme-light' : 'os-theme-dark',
-              scrollbars: {
-                autoHide: 'move',
-              },
-            }}
-          >
-            <DragDropContext onDragEnd={onDragEnd}>
-              <TreeList
-                expanded={expanded}
-                selected={selected}
-                onNodeToggle={handleToggle}
-                onNodeSelect={handleSelect}
-              >
-                {childMenuDraw(menuList, 'root_1')}
-              </TreeList>
-            </DragDropContext>
-          </Scrollbar>
-        </MainCard>
-        <MainCard
-          title="상세정보"
-          border={false}
-          className="tableCard"
-          secondary={
-            <Button
-              size="small"
-              variant="outlined"
-              color="secondary"
-              onClick={() => setAddAlertOpen(true)}
-            >
-              추가
-            </Button>
-          }
-          colSpan={9}
-        >
-          <FormProvider {...methods}>
-            <form id="menuListForm" onSubmit={methods.handleSubmit(editMenuList)}>
-              <GridItem
-                container
-                direction="row"
-                divideColumn={1}
-                borderFlag
-                sx={{
-                  '& .text': { maxWidth: '220px !important', minWidth: '220px !important' },
-                  '.inputBox': {
-                    maxWidth: '310px',
-                    minWidth: '310px',
-                  },
-                }}
-              >
-                <LabelInput
-                  label="메뉴 명"
-                  maxLength={50}
-                  required
-                  name="menuName"
-                  InputProps={{ readOnly: !selected && true, disabled: isDisabled }}
-                  placeholder="메뉴명을 클릭하세요."
-                  labelBackgroundFlag
-                />
-
-                {!isTopMenu.current && (
-                  <LabelInput
-                    label="메뉴 URL"
-                    maxLength={100}
-                    required
-                    name="menuUrl"
-                    InputProps={{ readOnly: !selected && true, disabled: isDisabled }}
-                    placeholder="메뉴명을 클릭하세요."
-                    labelBackgroundFlag
-                  />
-                )}
-                {!isTopMenu.current && contentClick && (
-                  <LabelInput
-                    label="서브 메뉴 URL 정규표현식"
-                    maxLength={100}
-                    name="subUrlRegex"
-                    InputProps={{ readOnly: !selected && true, disabled: isDisabled }}
-                    placeholder="정규 표현식"
-                    labelBackgroundFlag
-                  />
-                )}
-                {!isTopMenu.current && contentClick && (
-                  <Stack direction="row" alignItems="center" spacing={1} sx={{ height: '100%' }}>
-                    <LabelInput
-                      label="요청 URL 정규표현식"
-                      maxLength={100}
-                      name="processUrlRegex"
-                      InputProps={{ readOnly: !selected && true, disabled: isDisabled }}
-                      placeholder="정규 표현식"
-                      labelBackgroundFlag
-                    />
-                    <Button
-                      size="small"
-                      variant="outlined"
-                      color="secondary"
-                      onClick={() => setCommonRegexFlag(!commonRegexFlag)}
-                    >
-                      공통
-                    </Button>
-                  </Stack>
-                )}
-                {!isTopMenu.current && commonRegexFlag && (
-                  <LabelInput
-                    label="공통 요청 URL 정규표현식"
-                    maxLength={1024}
-                    name="commonUrlRegex"
-                    InputProps={{ readOnly: !selected && true, disabled: isDisabled }}
-                    placeholder="정규 표현식"
-                    labelBackgroundFlag
-                  />
-                )}
-
-                {!isTopMenu.current && (
-                  <LabelInput
-                    type="select"
-                    label="메뉴 아이콘"
-                    name="iconName"
-                    list={iconListGenerate()}
-                    disabled={isDisabled}
-                    labelBackgroundFlag
-                  />
-                )}
-                <Stack direction="row" alignItems="center" spacing={1} sx={{ height: '100%' }}>
-                  <LabelInput
-                    required
-                    type="radio"
-                    label="사용 여부"
-                    name="useYn"
-                    onHandleChange={handleChange}
-                    list={[
-                      { disabled: isDisabled, label: '사용', value: 'Y' },
-                      { disabled: isDisabled, label: '미사용', value: 'N' },
-                    ]}
-                    labelBackgroundFlag
-                  />
-                  {!isTopMenu.current && !contentClick && (
-                    <LabelInput
-                      type="checkbox"
-                      name="useSubCheck"
-                      disabled
-                      list={[
-                        {
-                          disabled: isDisabled,
-                          label: '하위메뉴 포함 시 체크',
-                          value: 'Y',
-                        },
-                      ]}
-                      labelBackgroundFlag
-                    />
-                  )}
-                </Stack>
-                <Stack direction="row" alignItems="center" spacing={1} sx={{ height: '100%' }}>
-                  <LabelInput
-                    required
-                    type="radio"
-                    label="관리자 전용"
-                    name="adminYn"
-                    onHandleChange={handleChange}
-                    list={[
-                      { disabled: isDisabled, label: '전용', value: 'Y' },
-                      { disabled: isDisabled, label: '미전용', value: 'N' },
-                    ]}
-                    labelBackgroundFlag
-                  />
-
-                  {!isTopMenu.current && !contentClick && (
-                    <LabelInput
-                      type="checkbox"
-                      name="adminSubCheck"
-                      list={[
-                        {
-                          disabled: isDisabled,
-                          label: '하위메뉴 포함 시 체크',
-                          value: 'Y',
-                        },
-                      ]}
-                      labelBackgroundFlag
-                    />
-                  )}
-                </Stack>
-
-                <LabelInput
-                  type="select"
-                  label="상단 메뉴"
-                  name="depth0"
-                  list={upperMenuList.depth0}
-                  onHandleChange={handleChange}
-                  disabled={isDisabled || isSelect.depth0}
-                  labelBackgroundFlag
-                />
-
-                <LabelInput
-                  type="select"
-                  label="1Depth 메뉴"
-                  name="depth1"
-                  list={upperMenuList.depth1}
-                  onHandleChange={handleChange}
-                  disabled={isDisabled || isSelect.depth1}
-                  labelBackgroundFlag
-                />
-
-                {configVal > '2' && (
-                  <LabelInput
-                    type="select"
-                    label="2Depth 메뉴"
-                    name="depth2"
-                    list={upperMenuList.depth2}
-                    onHandleChange={handleChange}
-                    disabled={isDisabled || isSelect.depth2}
-                    labelBackgroundFlag
-                  />
-                )}
-                {configVal > '3' && (
-                  <LabelInput
-                    type="select"
-                    label="3Depth 메뉴"
-                    name="depth3"
-                    list={upperMenuList.depth3}
-                    onHandleChange={handleChange}
-                    disabled={isDisabled || isSelect.depth3}
-                    labelBackgroundFlag
-                  />
-                )}
-              </GridItem>
-
-              <ConfirmPop name="menuListForm" anchorEl={popTarget} anchorChange={setPopTarget} />
-            </form>
-          </FormProvider>
-          {!isDisabled && (
-            <GridItem item directionHorizon="end" sx={{ mt: 1 }}>
-              <ButtonSet
-                type="custom"
-                options={[
-                  {
-                    label: '저장',
-                    callBack: (event) => setPopTarget(event.currentTarget),
-                    // role: 'update',
-                    color: 'primary',
-                    variant: 'contained',
-                  },
-                  {
-                    label: '삭제',
-                    callBack: handleDeleteButtonClick,
-                    // role: 'delete',
-                    color: 'secondary',
-                    variant: 'outlined',
-                  },
-                ]}
-              />
+    <GridItem container item divideColumn={12} spacing={2}>
+      <MainCard
+        title="메뉴 설정"
+        colSpan={3}
+        sx={{ height: 'calc(100vh - 200px)' }}
+        contentSX={{ height: 'calc(100vh - 240px)', pb: '15px', overflow: 'hidden' }}
+      >
+        <Scrollbar>
+          <TreeList expanded={expanded} selected={selected}>
+            {menuList.map((menu) => (
+              <TreeListItem key={menu.id} nodeId={menu.id.toString()} label={menu.title}>
+                {menu.children?.map((child) => (
+                  <TreeListItem key={child.id} nodeId={child.id.toString()} label={child.title} />
+                ))}
+              </TreeListItem>
+            ))}
+          </TreeList>
+        </Scrollbar>
+      </MainCard>
+
+      <MainCard title="상세정보" colSpan={9}>
+        <FormProvider {...methods}>
+          <form id="menuListForm">
+            <GridItem container direction="row" divideColumn={1} borderFlag>
+              <LabelInput label="메뉴 명" name="menuName" required placeholder="메뉴명을 입력하세요" />
+              <LabelInput label="메뉴 URL" name="menuUrl" required placeholder="메뉴 URL을 입력하세요" />
+              <Stack direction="row" alignItems="center" spacing={1} sx={{ height: '100%' }}>
+                <LabelInput label="요청 URL 정규표현식" name="processUrlRegex" placeholder="정규 표현식 입력" />
+              </Stack>
             </GridItem>
-          )}
-        </MainCard>
-      </GridItem>
-      <MenuModal
-        alertOpen={addAlertOpen}
-        setAlertOpen={setAddAlertOpen}
-        getMenuList={getMenuList}
-        listReset={handleReset}
-        clickHandler={clickHandler}
-        upperMenuList={upperMenuList}
-        configVal={configVal}
-      />
-      <MenuSettingModal
-        alertOpen={settingAlertOpen}
-        setAlertOpen={setSettingAlertOpen}
-        getMenuList={getMenuList}
-        listReset={handleReset}
-      />
-    </>
+          </form>
+        </FormProvider>
+      </MainCard>
+    </GridItem>
   );
 }
 
diff -urN ..\hss-frontend\src\/pages/system/permission/permissionList.jsx .\src\/pages/system/permission/permissionList.jsx
--- ..\hss-frontend\src\/pages/system/permission/permissionList.jsx	2024-10-18 16:27:14.237052800 +0900
+++ .\src\/pages/system/permission/permissionList.jsx	2025-03-07 09:42:17.807339000 +0900
@@ -1,89 +1,86 @@
-// libraries
 import { useState, useEffect, useCallback } from 'react';
 import { useRouter } from 'next/router';
 import { Button, Stack } from '@mui/material';
 import { Replay } from '@mui/icons-material';
 import { unstable_batchedUpdates } from 'react-dom';
-// components
 import Layout from '@components/layouts';
 import GridItem from '@components/modules/grid/GridItem';
 import ButtonSet from '@components/modules/button/ButtonSet';
 import LabelInput from '@components/modules/input/LabelInput';
 import SearchInput from '@components/modules/input/SearchInput';
 import ReactTable from '@components/modules/table/ReactTable';
-// functions
 import { AuthInstance } from '@modules/axios';
 import useApi from '@modules/hooks/useApi';
 import permissionApi from '@api/system/permissionApi';
 import HsLib from '@modules/common/HsLib';
 import useInput from '@modules/hooks/useInput';
+
 function PermissionList() {
-  // Axios 인트턴스(Http통신)
   const { instance, source } = AuthInstance();
   permissionApi.axios = instance;
-  // api 호출 함수, openModal 함수.
+
   const [apiCall, openModal] = useApi();
-  // Router Hook(페이지 이동, 쿼리 파라미터 처리)
   const router = useRouter();
-  // 검색조건 파라미터.
+
   const [parameters, changeParameters, resetParameters, setParameters, unControlRef] = useInput({
     userPermissionName: '',
     rank: '',
     useYn: '',
     searchAll: '',
   });
-  // 권한목록 상태값
+
   const [permissionList, setPermissionList] = useState([]);
-  // 컬럼정보 상태값
   const [columns, setColumns] = useState([]);
-  // 테이블정보 상태값
   const [gridInfo, setGridInfo] = useState({
     api: permissionApi,
     parameters: parameters,
     listInfo: {},
     total: 0,
   });
-  // 삭제목록 상태값
   const [deleteList, setDeleteList] = useState([]);
-  // Side effect Hook
+
+  // ✅ useEffect가 두 번 실행되지 않도록 예외 처리
+  const [hasFetched, setHasFetched] = useState(false);
+
   useEffect(() => {
-    // 초기화 함수
+    if (hasFetched) return; // 🔹 두 번째 호출 방지
+
+    setHasFetched(true); // 🔹 첫 번째 실행 이후 true로 설정
+
+    const init = async () => {
+      try {
+        const gridInfo = await HsLib.getGridInfo('PermissionList', permissionApi);
+        if (gridInfo) {
+          const permissionList = await apiCall(permissionApi.getPermissionList, {
+            ...parameters,
+            sort: `${gridInfo.listInfo.sortColumn ?? ''},${gridInfo.listInfo.sortDirection ?? ''}`,
+            size: gridInfo.listInfo.size,
+          });
+
+          unstable_batchedUpdates(() => {
+            responseGridInfo(gridInfo);
+            responsePermissionList(permissionList);
+          });
+        }
+      } catch (error) {
+        console.error('Error fetching permission list:', error);
+      }
+    };
+
     init();
-    // Clean-up
+
     return () => {
       source.cancel();
     };
   }, []);
-  // 초기화 함수
-  const init = async () => {
-    // 테이블, 컬럼정보 요청
-    const gridInfo = await HsLib.getGridInfo('PermissionList', permissionApi);
-    if (gridInfo) {
-      // 권한목록 요청
-      const permissionList = await apiCall(permissionApi.getPermissionList, {
-        ...parameters,
-        sort: `${gridInfo.listInfo.sortColumn ?? ''},${gridInfo.listInfo.sortDirection ?? ''}`,
-        size: gridInfo.listInfo.size,
-      });
-      // 일괄 변경처리
-      unstable_batchedUpdates(() => {
-        // 테이블, 컬럼정보 응답처리
-        responseGridInfo(gridInfo);
-        // 역할목록 응답처리
-        responsePermissionList(permissionList);
-      });
-    }
-  };
-  // 테이블, 컬럼정보 응답처리
+
   const responseGridInfo = (p_gridInfo) => {
     if (p_gridInfo) {
-      // 컬럼정보 상태값 변경
       setColumns(p_gridInfo.columns);
-      // 테이블정보 상태값 변경
-      setGridInfo((prev) => {
-        return { ...prev, listInfo: p_gridInfo.listInfo };
-      });
-      // 검색조건 변경
+      setGridInfo((prev) => ({
+        ...prev,
+        listInfo: p_gridInfo.listInfo,
+      }));
       setParameters({
         ...parameters,
         sort: `${p_gridInfo.listInfo.sortColumn ?? ''},${p_gridInfo.listInfo.sortDirection ?? ''}`,
@@ -91,38 +88,40 @@
       });
     }
   };
-  // 권한목록 응답처리
+
   const responsePermissionList = (p_roleList) => {
     if (p_roleList.status === 200) {
       setPermissionList(p_roleList.data.content);
-
-      setGridInfo((prev) => {
-        return { ...prev, total: p_roleList.data.totalElements };
-      });
+      setGridInfo((prev) => ({
+        ...prev,
+        total: p_roleList.data.totalElements,
+      }));
     }
   };
-  // 권한목록만 출력
+
   const getPermissionList = useCallback(async (parameters) => {
-    const result = await apiCall(permissionApi.getPermissionList, parameters);
-    if (result.status === 200) {
-      // 일괄 변경처리
-      unstable_batchedUpdates(() => {
-        if (!parameters) {
-          resetParameters();
-        }
-        // 권한목록 응답처리
-        responsePermissionList(result);
-      });
+    try {
+      const result = await apiCall(permissionApi.getPermissionList, parameters);
+      if (result.status === 200) {
+        unstable_batchedUpdates(() => {
+          if (!parameters) {
+            resetParameters();
+          }
+          responsePermissionList(result);
+        });
+      }
+    } catch (error) {
+      console.error('Error fetching permission list:', error);
     }
   }, []);
-  // 추가버튼 클릭 이벤트
+
   const handleInsertButtonClick = () => {
     router.push({
       pathname: '/system/permission/permissionForm',
       query: { flag: 'insert', id: '' },
     });
   };
-  // 삭제 버튼 클릭 이벤트
+
   const handleDeleteButtonClick = () => {
     if (deleteList.length !== 0) {
       openModal({
@@ -135,24 +134,28 @@
       });
     }
   };
-  // 선택한 정보 삭제
+
   const deletePermission = async () => {
-    const result = await apiCall(
-      permissionApi.deletePermission,
-      deleteList.map((item) => item.id),
-    );
+    try {
+      const result = await apiCall(
+        permissionApi.deletePermission,
+        deleteList.map((item) => item.id),
+      );
 
-    if (result.status === 200) {
-      openModal({
-        message: `${result.data}건이 삭제되었습니다.`,
-        onConfirm: () => {
-          setDeleteList([]);
-          getPermissionList(parameters);
-        },
-      });
+      if (result.status === 200) {
+        openModal({
+          message: `${result.data}건이 삭제되었습니다.`,
+          onConfirm: () => {
+            setDeleteList([]);
+            getPermissionList(parameters);
+          },
+        });
+      }
+    } catch (error) {
+      console.error('Error deleting permissions:', error);
     }
   };
-  // JSX
+
   return (
     <>
       <GridItem spacing={2} container direction="column">
@@ -198,67 +201,25 @@
           <ButtonSet
             type="custom"
             options={[
-              {
-                label: '추가',
-                color: 'secondary',
-                variant: 'outlined',
-                callBack: handleInsertButtonClick,
-                // role: 'insert',
-              },
-              {
-                label: '삭제',
-                callBack: handleDeleteButtonClick,
-                color: 'secondary',
-                variant: 'outlined',
-                // role: 'delete',
-              },
+              { label: '추가', color: 'secondary', variant: 'outlined', callBack: handleInsertButtonClick },
+              { label: '삭제', color: 'secondary', variant: 'outlined', callBack: handleDeleteButtonClick },
             ]}
           />
-
           <Stack direction="row" alignItems="center" spacing={1.3}>
-            <Button
-              color="secondary"
-              variant="outlined"
-              size="small"
-              onClick={() => {
-                // resetParameters();
-                getPermissionList();
-              }}
-            >
+            <Button color="secondary" variant="outlined" size="small" onClick={() => getPermissionList()}>
               <Replay />
             </Button>
             <ButtonSet
               type="search"
               options={[
-                {
-                  label: '초기화',
-                  callBack: resetParameters,
-                  color: 'secondary',
-                  variant: 'outlined',
-                },
-                {
-                  label: '검색',
-                  color: 'primary',
-                  variant: 'contained',
-                  callBack: () => getPermissionList(parameters),
-                },
+                { label: '초기화', callBack: resetParameters, color: 'secondary', variant: 'outlined' },
+                { label: '검색', color: 'primary', variant: 'contained', callBack: () => getPermissionList(parameters) },
               ]}
             />
           </Stack>
         </GridItem>
         <GridItem item>
-          <ReactTable
-            listFuncName="getPermissionList"
-            columns={columns}
-            data={permissionList}
-            checkList={deleteList}
-            onChangeChecked={setDeleteList}
-            setData={setPermissionList}
-            gridInfo={gridInfo}
-            setGridInfo={setGridInfo}
-            parameters={unControlRef}
-            setParameters={setParameters}
-          />
+          <ReactTable columns={columns} data={permissionList} checkList={deleteList} onChangeChecked={setDeleteList} />
         </GridItem>
       </GridItem>
     </>
diff -urN ..\hss-frontend\src\/sub_pages/sample/kanban/Columns.jsx .\src\/sub_pages/sample/kanban/Columns.jsx
--- ..\hss-frontend\src\/sub_pages/sample/kanban/Columns.jsx	2024-10-18 16:27:14.245052200 +0900
+++ .\src\/sub_pages/sample/kanban/Columns.jsx	2025-03-10 17:38:46.052534500 +0900
@@ -94,14 +94,14 @@
     }
   };
 
-  console.log(columns, columnItems);
+  const nodeRef = useRef(null);
   return (
     <>
       {column && (
-        <Draggable draggableId={column.id} index={index}>
+        <Draggable draggableId={column.id} index={index} nodeRef={nodeRef}>
           {(provided, snapshot) => (
             <div
-              ref={provided.innerRef}
+              ref={nodeRef}
               {...provided.draggableProps}
               {...provided.dragHandleProps}
               style={getDragWrapper(
diff -urN ..\hss-frontend\src\/sub_pages/sample/kanban/Items.jsx .\src\/sub_pages/sample/kanban/Items.jsx
--- ..\hss-frontend\src\/sub_pages/sample/kanban/Items.jsx	2024-10-18 16:27:14.246051700 +0900
+++ .\src\/sub_pages/sample/kanban/Items.jsx	2025-03-10 17:38:57.787619300 +0900
@@ -83,12 +83,12 @@
   const editStory = () => {
     setOpenStoryDrawer((prevState) => !prevState);
   };
-
+  const nodeRef = useRef(null);
   return (
-    <Draggable key={item.id} draggableId={item.id} index={index}>
+    <Draggable  nodeRef={nodeRef} key={item.id} draggableId={item.id} index={index}>
       {(provided, snapshot) => (
         <div
-          ref={provided.innerRef}
+          ref={nodeRef}
           {...provided.draggableProps}
           {...provided.dragHandleProps}
           style={getDragWrapper(snapshot.isDragging, provided.draggableProps.style, theme, `4px`)}
